// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package org.apache.doris.nereids;

import org.apache.doris.analysis.StatementBase;
import org.apache.doris.common.AnalysisException;
import org.apache.doris.common.UserException;
import org.apache.doris.common.util.VectorizedUtil;
import org.apache.doris.nereids.memo.Group;
import org.apache.doris.nereids.memo.GroupExpression;
import org.apache.doris.nereids.memo.Memo;
import org.apache.doris.nereids.properties.PhysicalProperties;
import org.apache.doris.nereids.trees.plans.PhysicalPlanTranslator;
import org.apache.doris.nereids.trees.plans.Plan;
import org.apache.doris.nereids.trees.plans.PlanTranslatorContext;
import org.apache.doris.nereids.trees.plans.logical.LogicalPlan;
import org.apache.doris.nereids.trees.plans.logical.LogicalPlanAdapter;
import org.apache.doris.nereids.trees.plans.physical.PhysicalPlan;
import org.apache.doris.planner.PlanFragment;
import org.apache.doris.planner.Planner;
import org.apache.doris.planner.ScanNode;
import org.apache.doris.qe.ConnectContext;

import com.google.common.collect.Lists;

import java.util.ArrayList;
import java.util.List;

/**
 * Planner to do query plan in Nereids.
 */
public class NereidsPlanner extends Planner {

    private PlannerContext plannerContext;
    private final ConnectContext ctx;
    private List<ScanNode> scanNodeList = null;

    public NereidsPlanner(ConnectContext ctx) {
        this.ctx = ctx;
    }

    @Override
    public void plan(StatementBase queryStmt,
            org.apache.doris.thrift.TQueryOptions queryOptions) throws UserException {
        if (!(queryStmt instanceof LogicalPlanAdapter)) {
            throw new RuntimeException("Wrong type of queryStmt, expected: <? extends LogicalPlanAdapter>");
        }
        LogicalPlanAdapter logicalPlanAdapter = (LogicalPlanAdapter) queryStmt;
        PhysicalPlan physicalPlan = plan(logicalPlanAdapter.getLogicalPlan(), new PhysicalProperties(), ctx);
        PhysicalPlanTranslator physicalPlanTranslator = new PhysicalPlanTranslator();
        PlanTranslatorContext planContext = new PlanTranslatorContext();
        physicalPlanTranslator.translatePlan(physicalPlan, planContext);
        fragments = new ArrayList<>(planContext.getPlanFragmentList());
        PlanFragment root = fragments.get(fragments.size() - 1);
        root.setOutputExprs(queryStmt.getResultExprs());
        if (VectorizedUtil.isVectorized()) {
            root.getPlanRoot().convertToVectoriezd();
        }
        scanNodeList = planContext.getScanNodeList();
    }

    /**
     * Do analyze and optimize for query plan.
     *
     * @param plan wait for plan
     * @param outputProperties physical properties constraints
     * @param connectContext connect context for this query
     * @return physical plan generated by this planner
     * @throws AnalysisException throw exception if failed in ant stage
     */
    // TODO: refactor, just demo code here
    public PhysicalPlan plan(LogicalPlan plan, PhysicalProperties outputProperties, ConnectContext connectContext)
            throws AnalysisException {
        Memo memo = new Memo();
        memo.initialize(plan);

        OptimizerContext optimizerContext = new OptimizerContext(memo);
        plannerContext = new PlannerContext(optimizerContext, connectContext, outputProperties);

        // Get plan directly. Just for SSB.
        return doPlan();
    }

    /**
     * The actual execution of the plan, including the generation and execution of the job.
     * @return PhysicalPlan.
     */
    private PhysicalPlan doPlan() {
        AnalyzeRulesJob analyzeRulesJob = new AnalyzeRulesJob(plannerContext);
        analyzeRulesJob.execute();

        OptimizeRulesJob optimizeRulesJob = new OptimizeRulesJob(plannerContext);
        optimizeRulesJob.execute();

        return getRoot().extractPlan();
    }

    @Override
    public List<ScanNode> getScanNodes() {
        return scanNodeList;
    }

    public Group getRoot() {
        return plannerContext.getOptimizerContext().getMemo().getRoot();
    }

    private PhysicalPlan chooseBestPlan(Group rootGroup, PhysicalProperties physicalProperties)
            throws AnalysisException {
        GroupExpression groupExpression = rootGroup.getLowestCostPlan(physicalProperties).orElseThrow(
                () -> new AnalysisException("lowestCostPlans with physicalProperties doesn't exist")).second;
        List<PhysicalProperties> inputPropertiesList = groupExpression.getInputPropertiesList(physicalProperties);

        List<Plan> planChildren = Lists.newArrayList();
        for (int i = 0; i < groupExpression.arity(); i++) {
            planChildren.add(chooseBestPlan(groupExpression.child(i), inputPropertiesList.get(i)));
        }

        Plan plan = ((PhysicalPlan) groupExpression.getOperator().toTreeNode(groupExpression)).withChildren(
                planChildren);
        if (!(plan instanceof PhysicalPlan)) {
            throw new AnalysisException("generate logical plan");
        }
        PhysicalPlan physicalPlan = (PhysicalPlan) plan;

        // TODO: set (logical and physical)properties/statistics/... for physicalPlan.

        return physicalPlan;
    }

    @Override
    public boolean isBlockQuery() {
        return true;
    }
}
