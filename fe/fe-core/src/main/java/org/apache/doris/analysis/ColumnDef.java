// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
// This file is copied from
// https://github.com/apache/impala/blob/branch-2.9.0/fe/src/main/java/org/apache/impala/ColumnDef.java
// and modified by Doris

package org.apache.doris.analysis;

import org.apache.doris.catalog.AggregateType;
import org.apache.doris.catalog.Column;
import org.apache.doris.catalog.GeneratedColumnInfo;
import org.apache.doris.catalog.KeysType;
import org.apache.doris.catalog.PrimitiveType;
import org.apache.doris.catalog.ScalarType;
import org.apache.doris.catalog.Type;
import org.apache.doris.common.AnalysisException;
import org.apache.doris.common.util.SqlUtils;
import org.apache.doris.common.util.TimeUtils;
import org.apache.doris.nereids.trees.plans.commands.info.ColumnDefinition;
import org.apache.doris.nereids.types.DataType;

import com.google.common.base.Preconditions;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Pattern;

// Column definition which is generated by SQL syntax parser
// Syntax:
//      name type [key] [agg_type] [NULL | NOT NULL] [AUTO_INCREMENT] [DEFAULT default_value] [comment]
// Example:
//      id bigint key NOT NULL DEFAULT "-1" "user id"
//      pv bigint sum NULL DEFAULT "-1" "page visit"
public class ColumnDef {
    private static final Logger LOG = LogManager.getLogger(ColumnDef.class);

    /*
     * User can set default value for a column
     * eg:
     *     k1 INT NOT NULL DEFAULT "10"
     *     k1 INT NULL
     *     k1 INT NULL DEFAULT NULL
     *
     * ColumnnDef will be transformed to Column in Analysis phase, and in Column, default value is a String.
     * No matter does the user set the default value as NULL explicitly, or not set default value, the default value
     * in Column will be "null", so that Doris can not distinguish between "not set" and "set as null".
     *
     * But this is OK because Column has another attribute "isAllowNull".
     * If the column is not allowed to be null, and user does not set the default value,
     * even if default value saved in Column is null, the "null" value can not be loaded into this column,
     * so data correctness can be guaranteed.
     */
    public static class DefaultValue {
        public boolean isSet;
        public String value;
        // used for column which defaultValue is an expression.
        public DefaultValueExprDef defaultValueExprDef;

        public DefaultValue(boolean isSet, Object value) {
            this.isSet = isSet;
            this.value = value == null ? null : value.toString();
            this.defaultValueExprDef = null;
        }

        /**
         * used for column which defaultValue is an expression.
         * @param isSet is Set DefaultValue
         * @param value default value
         * @param exprName default value expression
         */
        public DefaultValue(boolean isSet, String value, String exprName) {
            this.isSet = isSet;
            this.value = value;
            this.defaultValueExprDef = new DefaultValueExprDef(exprName);
        }

        public DefaultValue(boolean isSet, String value, String exprName, Long precision) {
            this.isSet = isSet;
            this.value = value;
            this.defaultValueExprDef = new DefaultValueExprDef(exprName, precision);
        }

        public static String E_NUM = "E";
        public static String PI = "PI";
        public static String CURRENT_DATE = "CURRENT_DATE";
        // default "CURRENT_TIMESTAMP", for datetime / datetimev2 type
        public static String CURRENT_TIMESTAMP = "CURRENT_TIMESTAMP";
        public static Pattern CURRENT_TIMESTAMP_PATTERN
                = Pattern.compile("^CURRENT_TIMESTAMP(?:\\(\\d?\\))?$");
        public static String NOW = "now";
        // no default value
        public static DefaultValue NOT_SET = new DefaultValue(false, null);
        // default null
        public static DefaultValue NULL_DEFAULT_VALUE = new DefaultValue(true, null);

        public static boolean isCurrentTimeStampDefaultValue(String defaultValue) {
            return CURRENT_TIMESTAMP_PATTERN.matcher(defaultValue.trim().toUpperCase()).matches();
        }

        public boolean isCurrentTimeStamp() {
            return "CURRENT_TIMESTAMP".equals(value) && defaultValueExprDef != null
                    && NOW.equals(defaultValueExprDef.getExprName());
        }

        public boolean isCurrentTimeStampWithPrecision() {
            return defaultValueExprDef != null && value.startsWith(CURRENT_TIMESTAMP + "(")
                    && NOW.equals(defaultValueExprDef.getExprName());
        }

        public long getCurrentTimeStampPrecision() {
            if (isCurrentTimeStampWithPrecision()) {
                return Long.parseLong(value.substring(CURRENT_TIMESTAMP.length() + 1, value.length() - 1));
            }
            return 0;
        }

        public String getValue() {
            if (isCurrentTimeStamp()) {
                return LocalDateTime.now(TimeUtils.getTimeZone().toZoneId()).toString().replace('T', ' ');
            } else if (isCurrentTimeStampWithPrecision()) {
                long precision = getCurrentTimeStampPrecision();
                String format = "yyyy-MM-dd HH:mm:ss";
                if (precision == 0) {
                    return LocalDateTime.now(TimeUtils.getTimeZone().toZoneId()).toString().replace('T', ' ');
                } else if (precision == 1) {
                    format = "yyyy-MM-dd HH:mm:ss.S";
                } else if (precision == 2) {
                    format = "yyyy-MM-dd HH:mm:ss.SS";
                } else if (precision == 3) {
                    format = "yyyy-MM-dd HH:mm:ss.SSS";
                } else if (precision == 4) {
                    format = "yyyy-MM-dd HH:mm:ss.SSSS";
                } else if (precision == 5) {
                    format = "yyyy-MM-dd HH:mm:ss.SSSSS";
                } else if (precision == 6) {
                    format = "yyyy-MM-dd HH:mm:ss.SSSSSS";
                }
                return LocalDateTime.now(TimeUtils.getTimeZone().toZoneId())
                        .format(DateTimeFormatter.ofPattern(format));
            }
            return value;
        }
    }

    // parameter initialized in constructor
    private String name;
    private Type type;
    private AggregateType aggregateType;

    private boolean isKey;
    private boolean isAllowNull;
    private boolean isAutoInc;
    private long autoIncInitValue;
    private KeysType keysType;
    private DefaultValue defaultValue;
    private String comment;
    private boolean visible;
    private int clusterKeyId = -1;
    private Optional<GeneratedColumnInfo> generatedColumnInfo = Optional.empty();
    private Set<String> generatedColumnsThatReferToThis = new HashSet<>();

    public ColumnDef(String name, Type type) {
        this(name, type, false, null, ColumnNullableType.NOT_NULLABLE, DefaultValue.NOT_SET, "");
    }

    public ColumnDef(String name, Type type, boolean isAllowNull) {
        this(name, type, false, null, isAllowNull, DefaultValue.NOT_SET, "");
    }

    public ColumnDef(String name, Type type, ColumnNullableType nullableType) {
        this(name, type, false, null, nullableType, DefaultValue.NOT_SET, "");
    }

    public ColumnDef(String name, Type type, boolean isKey, AggregateType aggregateType,
                     ColumnNullableType nullableType, long autoIncInitValue, DefaultValue defaultValue,
                     String comment) {
        this(name, type, isKey, aggregateType, nullableType, autoIncInitValue, defaultValue, comment, true,
                Optional.empty());
    }

    public ColumnDef(String name, Type type, boolean isKey, AggregateType aggregateType,
                     ColumnNullableType nullableType, DefaultValue defaultValue, String comment) {
        this(name, type, isKey, aggregateType, nullableType, -1, defaultValue, comment, true,
                Optional.empty());
    }

    public ColumnDef(String name, Type type, boolean isKey, AggregateType aggregateType,
                     ColumnNullableType nullableType, long autoIncInitValue, DefaultValue defaultValue, String comment,
                     boolean visible, Optional<GeneratedColumnInfo> generatedColumnInfo) {
        this.name = name;
        this.type = type;
        this.isKey = isKey;
        this.aggregateType = aggregateType;
        if (nullableType != ColumnNullableType.UNKNOWN) {
            isAllowNull = nullableType.getNullable(this.type.getPrimitiveType());
        }
        this.isAutoInc = autoIncInitValue != -1;
        this.autoIncInitValue = autoIncInitValue;
        this.defaultValue = defaultValue;
        this.comment = comment;
        this.visible = visible;
        this.generatedColumnInfo = generatedColumnInfo;
    }

    public ColumnDef(String name, Type type, boolean isKey, AggregateType aggregateType, boolean isAllowNull,
                     DefaultValue defaultValue, String comment) {
        this(name, type, isKey, aggregateType, isAllowNull, -1, defaultValue, comment, true);
    }

    public ColumnDef(String name, Type type, boolean isKey, AggregateType aggregateType,
                     boolean isAllowNull, long autoIncInitValue, DefaultValue defaultValue, String comment,
                     boolean visible) {
        this.name = name;
        this.type = type;
        this.isKey = isKey;
        this.aggregateType = aggregateType;
        this.isAllowNull = isAllowNull;
        this.isAutoInc = autoIncInitValue != -1;
        this.autoIncInitValue = autoIncInitValue;
        this.defaultValue = defaultValue;
        this.comment = comment;
        this.visible = visible;
    }

    public ColumnDefinition translateToColumnDefinition() {
        org.apache.doris.nereids.trees.plans.commands.info.DefaultValue value;
        if (!defaultValue.isSet) {
            value = null;
        } else {
            if (defaultValue.defaultValueExprDef != null) {
                value = new org.apache.doris.nereids
                    .trees.plans.commands.info.DefaultValue(
                    defaultValue.getValue(),
                    defaultValue.defaultValueExprDef.getExprName(),
                    defaultValue.defaultValueExprDef.getPrecision());
            } else {
                value = new org.apache.doris.nereids
                    .trees.plans.commands.info.DefaultValue(defaultValue.getValue());
            }
        }

        ColumnDefinition columnDefinition = new ColumnDefinition(
                name,
                DataType.fromCatalogType(type),
                isKey,
                aggregateType,
                isAllowNull ? ColumnNullableType.NULLABLE : ColumnNullableType.NOT_NULLABLE,
                autoIncInitValue,
                value == null ? Optional.empty() : Optional.of(value),
                Optional.empty(),
                comment,
                visible,
                Optional.empty());
        columnDefinition.setGeneratedColumnsThatReferToThis(generatedColumnsThatReferToThis);

        return columnDefinition;
    }

    public static ColumnDef newSequenceColumnDef(Type type, AggregateType aggregateType) {
        return new ColumnDef(Column.SEQUENCE_COL, type, false, aggregateType, ColumnNullableType.NULLABLE,
                -1, DefaultValue.NULL_DEFAULT_VALUE, "sequence column hidden column", false,
                Optional.empty());
    }

    public boolean isAllowNull() {
        return isAllowNull;
    }

    public String getDefaultValue() {
        return defaultValue.value;
    }

    public String getName() {
        return name;
    }

    public AggregateType getAggregateType() {
        return aggregateType;
    }

    public void setAggregateType(AggregateType aggregateType) {
        this.aggregateType = aggregateType;
    }

    public boolean isKey() {
        return isKey;
    }

    public void setIsKey(boolean isKey) {
        this.isKey = isKey;
    }

    public void setKeysType(KeysType keysType) {
        this.keysType = keysType;
    }

    public Type getType() {
        return type;
    }

    public String getComment() {
        return comment;
    }

    public boolean isVisible() {
        return visible;
    }

    public int getClusterKeyId() {
        return this.clusterKeyId;
    }

    public void setClusterKeyId(int clusterKeyId) {
        this.clusterKeyId = clusterKeyId;
    }

    public void analyze(boolean isOlap) throws AnalysisException {
    }


    @SuppressWarnings("checkstyle:Indentation")
    public static void validateDefaultValue(Type type, String defaultValue, DefaultValueExprDef defaultValueExprDef)
            throws AnalysisException {
        Preconditions.checkNotNull(defaultValue);
        Preconditions.checkArgument(type.isScalarType());
        ScalarType scalarType = (ScalarType) type;

        // check if default value is valid.
        // first, check if the type of defaultValue matches primitiveType.
        // if not check it first, some literal constructor will throw AnalysisException,
        // and it is not intuitive to users.
        PrimitiveType primitiveType = scalarType.getPrimitiveType();
        if (null != defaultValueExprDef && defaultValueExprDef.getExprName().equalsIgnoreCase("now")) {
            switch (primitiveType) {
                case DATETIME:
                case DATETIMEV2:
                    break;
                default:
                    throw new AnalysisException("Types other than DATETIME and DATETIMEV2 "
                            + "cannot use current_timestamp as the default value");
            }
        } else if (null != defaultValueExprDef
                && defaultValueExprDef.getExprName().equalsIgnoreCase(DefaultValue.CURRENT_DATE)) {
            switch (primitiveType) {
                case DATE:
                case DATEV2:
                    break;
                default:
                    throw new AnalysisException("Types other than DATE and DATEV2 "
                            + "cannot use current_date as the default value");
            }
        } else if (null != defaultValueExprDef
                && defaultValueExprDef.getExprName().equalsIgnoreCase(DefaultValue.PI)) {
            switch (primitiveType) {
                case DOUBLE:
                    break;
                default:
                    throw new AnalysisException("Types other than DOUBLE cannot use pi as the default value");
            }
        } else if (null != defaultValueExprDef
                && defaultValueExprDef.getExprName().equalsIgnoreCase(DefaultValue.E_NUM)) {
            switch (primitiveType) {
                case DOUBLE:
                    break;
                default:
                    throw new AnalysisException("Types other than DOUBLE cannot use e as the default value");
            }
        }
        switch (primitiveType) {
            case TINYINT:
            case SMALLINT:
            case INT:
            case BIGINT:
                new IntLiteral(defaultValue, type);
                break;
            case LARGEINT:
                new LargeIntLiteral(defaultValue);
                break;
            case FLOAT:
                FloatLiteral floatLiteral = new FloatLiteral(defaultValue);
                if (floatLiteral.getType().equals(Type.DOUBLE)) {
                    throw new AnalysisException("Default value will loose precision: " + defaultValue);
                }
                break;
            case DOUBLE:
                new FloatLiteral(defaultValue);
                break;
            case DECIMALV2:
                //no need to check precision and scale, since V2 is fixed point
                new DecimalLiteral(defaultValue);
                break;
            case DECIMAL32:
            case DECIMAL64:
            case DECIMAL128:
            case DECIMAL256:
                DecimalLiteral decimalLiteral = new DecimalLiteral(defaultValue);
                decimalLiteral.checkPrecisionAndScale(scalarType.getScalarPrecision(), scalarType.getScalarScale());
                break;
            case DATE:
            case DATEV2:
                if (defaultValueExprDef == null) {
                    new DateLiteral(defaultValue, scalarType);
                } else {
                    if (defaultValueExprDef.getExprName().equalsIgnoreCase(DefaultValue.CURRENT_DATE)) {
                        break;
                    } else {
                        throw new AnalysisException("date literal [" + defaultValue + "] is invalid");
                    }
                }
                break;
            case DATETIME:
            case DATETIMEV2:
                if (defaultValueExprDef == null) {
                    new DateLiteral(defaultValue, scalarType);
                } else {
                    if (defaultValueExprDef.getExprName().equals(DefaultValue.NOW)) {
                        if (defaultValueExprDef.getPrecision() != null) {
                            Long defaultValuePrecision = defaultValueExprDef.getPrecision();
                            String typeStr = scalarType.toString();
                            int typePrecision =
                                    Integer.parseInt(typeStr.substring(typeStr.indexOf("(") + 1, typeStr.indexOf(")")));
                            if (defaultValuePrecision > typePrecision) {
                                typeStr = typeStr.replace("V2", "");
                                throw new AnalysisException("default value precision: " + defaultValue
                                        + " can not be greater than type precision: " + typeStr);
                            }
                        }
                        break;
                    } else {
                        throw new AnalysisException("date literal [" + defaultValue + "] is invalid");
                    }
                }
                break;
            case CHAR:
            case VARCHAR:
            case HLL:
            case STRING:
            case JSONB:
                if (defaultValue.length() > scalarType.getLength()) {
                    throw new AnalysisException("Default value is too long: " + defaultValue);
                }
                break;
            case BITMAP:
            case ARRAY:
            case MAP:
            case STRUCT:
                break;
            case BOOLEAN:
                new BoolLiteral(defaultValue);
                break;
            case IPV4:
                new IPv4Literal(defaultValue);
                break;
            case IPV6:
                new IPv6Literal(defaultValue);
                break;
            default:
                throw new AnalysisException("Unsupported type: " + type);
        }
    }

    public String toSql() {
        StringBuilder sb = new StringBuilder();
        sb.append("`").append(name).append("` ");
        sb.append(type.toSql()).append(" ");

        if (aggregateType != null && aggregateType != AggregateType.NONE) {
            sb.append(aggregateType.name()).append(" ");
        }

        if (!isAllowNull) {
            sb.append("NOT NULL ");
        } else {
            // should append NULL to make result can be executed right.
            sb.append("NULL ");
        }

        if (isAutoInc) {
            sb.append("AUTO_INCREMENT ");
            sb.append("(");
            sb.append(autoIncInitValue);
            sb.append(")");
        }

        if (defaultValue.isSet) {
            if (defaultValue.value != null) {
                if (this.type.getPrimitiveType() != PrimitiveType.BITMAP
                        && this.type.getPrimitiveType() != PrimitiveType.HLL) {
                    if (defaultValue.defaultValueExprDef != null) {
                        sb.append("DEFAULT ").append(defaultValue.value).append(" ");
                    } else {
                        sb.append("DEFAULT ").append("\"").append(SqlUtils.escapeQuota(defaultValue.value)).append("\"")
                                .append(" ");
                    }
                } else if (this.type.getPrimitiveType() == PrimitiveType.BITMAP) {
                    sb.append("DEFAULT ").append(defaultValue.defaultValueExprDef.getExprName()).append(" ");
                }
            } else {
                sb.append("DEFAULT ").append("NULL").append(" ");
            }
        }
        sb.append("COMMENT \"").append(SqlUtils.escapeQuota(comment)).append("\"");

        return sb.toString();
    }

    public Column toColumn() {
        return new Column(name, this.type, isKey, aggregateType, isAllowNull, autoIncInitValue, defaultValue.value,
            comment, visible, defaultValue.defaultValueExprDef, Column.COLUMN_UNIQUE_ID_INIT_VALUE,
            defaultValue.getValue(), clusterKeyId, generatedColumnInfo.orElse(null), generatedColumnsThatReferToThis);
    }

    @Override
    public String toString() {
        return toSql();
    }
}
