// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

package org.apache.doris.nereids.trees.plans.logical;

import org.apache.doris.nereids.exceptions.AnalysisException;
import org.apache.doris.nereids.memo.GroupExpression;
import org.apache.doris.nereids.properties.LogicalProperties;
import org.apache.doris.nereids.trees.expressions.Alias;
import org.apache.doris.nereids.trees.expressions.Expression;
import org.apache.doris.nereids.trees.expressions.NamedExpression;
import org.apache.doris.nereids.trees.expressions.Slot;
import org.apache.doris.nereids.trees.expressions.VirtualSlotReference;
import org.apache.doris.nereids.trees.expressions.functions.scalar.Grouping;
import org.apache.doris.nereids.trees.expressions.functions.scalar.GroupingId;
import org.apache.doris.nereids.trees.expressions.functions.scalar.GroupingScalarFunction;
import org.apache.doris.nereids.trees.plans.Plan;
import org.apache.doris.nereids.trees.plans.PlanType;
import org.apache.doris.nereids.trees.plans.algebra.Repeat;
import org.apache.doris.nereids.trees.plans.visitor.PlanVisitor;
import org.apache.doris.nereids.types.BigIntType;
import org.apache.doris.nereids.util.Utils;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableList.Builder;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * Logical Repeat.
 * Operators generated for grouping sets, cube, rollup, acting under agg.
 * For the generation of each virtual column, see GroupingSetIdSlot.
 *
 * For detailed syntax design, see:
 * https://doris.apache.org/zh-CN/community/design/grouping_sets_design
 *
 * eg: select k1, grouping(k1), grouping(k1, k2) from t1 group by grouping sets ((k1), (k1, k2), (k3) ());
 */
public abstract class LogicalRepeat<CHILD_TYPE extends Plan>
        extends LogicalUnary<CHILD_TYPE> implements Repeat {

    public static final String COL_GROUPING_ID = "GROUPING_ID";
    public static final String GROUPING_PREFIX = "GROUPING_PREFIX_";
    // max num of distinct sets in grouping sets clause
    public static final int MAX_GROUPING_SETS_NUM = 64;

    // Including two categories:
    // one is a manually entered groupBy Slots.
    //      1.GroupingSets is the deduplication value calculated according to groupingSetsList.
    //      2.Cube/Rollup are deduplicated values of the input list.
    // eg: [k1, k2, k3]
    // the other is the virtual Slots.
    //      1.An additional virtual column generated by the operator to provide the same value for each GroupBy group.
    //      2.Virtual column generated by GroupingSetsFunc.
    // eg: [GROUPING_ID(), GROUPING_PREFIX_k1(k1), GROUPING_PREFIX_k1_k2(k1, k2)]
    //
    // complete groupByExpressions:
    // eg: [k1, k2, k3, GROUPING_ID(), GROUPING_PREFIX_k1(k1), GROUPING_PREFIX_k1_k2(k1, k2)]
    protected final List<Expression> groupByExpressions;

    // Output all expressions in group by.
    // eg: [k1, k2, k3, GROUPING_ID(), GROUPING_PREFIX_k1(k1), GROUPING_PREFIX_k1_k2(k1, k2)]
    protected final List<NamedExpression> outputExpressions;

    // list of input grouping sets.
    // 1. GroupingSets: Get direct input.
    // 2. Cube: Enter a permutation of columns.
    // 3. RollUp: Remove the last column in turn for groupBy.
    // eg: [(k1), (k1, k2), (k3) ()]
    protected final List<List<Expression>> groupingSets;

    // Virtual columns and GroupingFunc columns need to set the output column to be a null list.
    protected final List<GroupingSetShape> groupingSetShapes;

    protected final boolean expand;

    /**
     * initial construction method.
     */
    public LogicalRepeat(
            PlanType type,
            List<List<Expression>> groupingSets,
            List<Expression> groupByExpressions,
            List<NamedExpression> outputExpressions,
            Optional<GroupExpression> groupExpression,
            Optional<LogicalProperties> logicalProperties,
            CHILD_TYPE child) {
        super(type, groupExpression, logicalProperties, child);
        VirtualSlotReference virtualSlotReference = new VirtualSlotReference(
                COL_GROUPING_ID, BigIntType.INSTANCE, new ArrayList<>(), false);
        this.groupByExpressions = new ImmutableList.Builder<Expression>()
                .addAll(groupByExpressions)
                .add(virtualSlotReference)
                .build();
        this.outputExpressions = ImmutableList.copyOf(outputExpressions);
        this.groupingSets = ImmutableList.copyOf(groupingSets);
        this.groupingSetShapes = ImmutableList.of();
        this.expand = false;
    }

    /**
     * Constructor with all parameters.
     */
    public LogicalRepeat(
            PlanType type,
            List<List<Expression>> groupingSets,
            List<Expression> groupByExpressions,
            List<NamedExpression> outputExpressions,
            List<GroupingSetShape> groupingSetShapes,
            boolean expand,
            Optional<GroupExpression> groupExpression,
            Optional<LogicalProperties> logicalProperties,
            CHILD_TYPE child) {
        super(type, groupExpression, logicalProperties, child);
        this.groupingSets = ImmutableList.copyOf(groupingSets);
        this.groupByExpressions = ImmutableList.copyOf(groupByExpressions);
        this.outputExpressions = ImmutableList.copyOf(outputExpressions);
        this.groupingSetShapes = ImmutableList.copyOf(groupingSetShapes);
        this.expand = expand;
    }

    public List<List<Expression>> getGroupingSets() {
        return groupingSets;
    }

    public List<NamedExpression> getOutputExpressions() {
        return outputExpressions;
    }

    public List<Expression> getNonVirtualGroupByExpressions() {
        return groupByExpressions.stream()
                .filter(e -> !(e instanceof VirtualSlotReference))
                .collect(ImmutableList.toImmutableList());
    }

    public List<Expression> getGroupByExpressions() {
        return new ImmutableList.Builder<Expression>()
                .addAll(groupByExpressions)
                .build();
    }

    public List<Expression> getVirtualGroupByExpressions() {
        return groupByExpressions.stream()
                .filter(VirtualSlotReference.class::isInstance)
                .collect(ImmutableList.toImmutableList());
    }

    public List<GroupingSetShape> getGroupingSetShapes() {
        return groupingSetShapes;
    }

    public boolean isExpand() {
        return expand;
    }

    @Override
    public String toString() {
        return Utils.toSqlString("LogicalRepeat",
                "groupingSets", groupingSets,
                "groupByExpressions", groupByExpressions,
                "outputExpressions", outputExpressions,
                "groupingSetIdSlots", groupingSetShapes
        );
    }

    @Override
    public <R, C> R accept(PlanVisitor<R, C> visitor, C context) {
        return visitor.visitLogicalRepeat(this, context);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        LogicalRepeat that = (LogicalRepeat) o;
        return Objects.equals(groupByExpressions, that.groupByExpressions)
                && Objects.equals(outputExpressions, that.outputExpressions)
                && Objects.equals(groupingSetShapes, that.groupingSetShapes)
                && Objects.equals(groupingSets, that.groupingSets)
                && expand == that.expand;
    }

    @Override
    public int hashCode() {
        return Objects.hash(groupByExpressions, outputExpressions,
                groupingSetShapes, groupingSets, expand);
    }

    @Override
    public List<Expression> getExpressions() {
        return new ImmutableList.Builder<Expression>()
                .addAll(groupByExpressions)
                .addAll(outputExpressions)
                .build();
    }

    @Override
    public List<Slot> computeOutput() {
        return outputExpressions.stream()
                .map(NamedExpression::toSlot)
                .collect(ImmutableList.toImmutableList());
    }

    public abstract LogicalRepeat<Plan> replace(List<List<Expression>> groupByExprList,
            List<Expression> groupByExpressions,
            List<NamedExpression> outputExpressionList,
            List<GroupingSetShape> groupingSetIdSlots, boolean expand);

    public abstract LogicalRepeat<Plan> replaceWithChild(List<List<Expression>> groupByExprList,
            List<Expression> groupByExpressions,
            List<NamedExpression> outputExpressionList,
            List<GroupingSetShape> groupingSetIdSlots,
            boolean expand,
            Plan child);

    public List<GroupingSetShape> buildGroupingSetShapes(
            List<List<Expression>> groupingSets,
            List<Expression> nonVirtualGroupByExpressions,
            List<NamedExpression> outputExpressions) {
        return new ImmutableList.Builder<GroupingSetShape>()
                .add(buildExtraVirtualGroupingSetShape(groupingSets, nonVirtualGroupByExpressions))
                .addAll(buildGroupingFuncShapes(
                        groupingSets, outputExpressions))
                .build();
    }

    public GroupingSetShape buildExtraVirtualGroupingSetShape(
            List<List<Expression>> groupingSets, List<Expression> nonVirtualGroupByExpressions) {
        return new ExtraVirtualSlotShape(nonVirtualGroupByExpressions,
                genShouldBeErasedToNullForVirtualSlot(groupingSets, nonVirtualGroupByExpressions));
    }

    private List<GroupingSetShape> buildGroupingFuncShapes(
            List<List<Expression>> groupingSets,
            List<NamedExpression> outputExpressions) {
        List<GroupingSetShape> groupingSetIdSlots = new ArrayList<>();
        for (NamedExpression output : outputExpressions) {
            if (output instanceof Alias && ((Alias) output).child() instanceof GroupingScalarFunction) {
                Expression child = ((Alias) output).child();
                if (child instanceof Grouping) {
                    groupingSetIdSlots.add(new GroupingSlotShape(
                            ((Grouping) child).getRealChildren().get().get(0),
                            genShouldBeErasedToNullForGroupingFun((Grouping) child, groupingSets)
                    ));
                }
                if (child instanceof GroupingId) {
                    groupingSetIdSlots.add(new GroupingIdSlotShape(
                            ((GroupingId) child).getRealChildren().get(),
                            genShouldBeErasedToNullForGroupingFun((GroupingId) child, groupingSets)
                    ));
                }
            }
        }
        return groupingSetIdSlots;
    }

    /**
     * Generate the ShouldBeErasedToNull for the grouping scalar function.
     */
    public List<List<Boolean>> genShouldBeErasedToNullForGroupingFun(
            GroupingScalarFunction groupingScalarFunction, List<List<Expression>> groupingSets) {
        Builder<List<Boolean>> wholeGroupByBoolean = ImmutableList.builder();
        if (groupingScalarFunction.getRealChildren().isPresent()) {
            for (List<Expression> expressions : groupingSets) {
                Builder<Boolean> eachGroupByBoolean = ImmutableList.builder();
                for (Expression expression : groupingScalarFunction.getRealChildren().get()) {
                    if (expressions.contains(expression)) {
                        eachGroupByBoolean.add(false);
                    } else {
                        eachGroupByBoolean.add(true);
                    }
                }
                wholeGroupByBoolean.add(eachGroupByBoolean.build());
            }
        } else {
            throw new AnalysisException("Can not find the groupingId by the expression: " + groupingScalarFunction);
        }
        return wholeGroupByBoolean.build();
    }

    /**
     * Generate the ShouldBeErasedToNull for the hide VirtualSlot
     */
    public List<List<Boolean>> genShouldBeErasedToNullForVirtualSlot(
            List<List<Expression>> groupingSets, List<Expression> nonVirtualGroupByExpressions) {
        Builder<List<Boolean>> wholeGroupByBoolean = ImmutableList.builder();
        for (List<Expression> expressions : groupingSets) {
            Builder<Boolean> eachGroupByBoolean = ImmutableList.builder();
            for (Expression expression : nonVirtualGroupByExpressions) {
                if (expressions.contains(expression)) {
                    eachGroupByBoolean.add(false);
                } else {
                    eachGroupByBoolean.add(true);
                }
            }
            wholeGroupByBoolean.add(eachGroupByBoolean.build());
        }
        return wholeGroupByBoolean.build();
    }
}
