// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
// This file is copied from
// https://github.com/cloudera/Impala/blob/v0.7refresh/fe/src/main/cup/sql-parser.y
// and modified by Doris

package org.apache.doris.analysis;

import java.math.BigDecimal;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;

import org.apache.doris.analysis.AlterDatabaseQuotaStmt.QuotaType;
import org.apache.doris.analysis.SetOperationStmt.Qualifier;
import org.apache.doris.analysis.SetOperationStmt.Operation;
import org.apache.doris.analysis.SetOperationStmt.SetOperand;
import org.apache.doris.catalog.AccessPrivilege;
import org.apache.doris.catalog.AggregateType;
import org.apache.doris.catalog.KeysType;
import org.apache.doris.catalog.PrimitiveType;
import org.apache.doris.catalog.ScalarType;
import org.apache.doris.catalog.Type;
import org.apache.doris.catalog.ArrayType;
import org.apache.doris.catalog.MapType;
import org.apache.doris.catalog.StructField;
import org.apache.doris.catalog.StructType;
import org.apache.doris.catalog.View;
import org.apache.doris.common.AnalysisException;
import org.apache.doris.common.Version;
import org.apache.doris.mysql.MysqlPassword;
import org.apache.doris.load.loadv2.LoadTask;
import org.apache.doris.policy.PolicyTypeEnum;

import com.google.common.collect.Lists;
import com.google.common.collect.Maps;

import java_cup.runtime.Symbol;

// Commented by Zhao Chun
// Now we have 2 shift/reduce conflict
// between TIMESTAMP "20100101" and TIMESTAMP "alias"
// between DATE "20100101" and DATE "alias"

parser code {:
    private Symbol errorToken;
    public boolean isVerbose = false;
    public String wild;
    public Expr where;

    // List of expected tokens ids from current parsing state for generating syntax error message
    private final List<Integer> expectedTokenIds = Lists.newArrayList();

    // To avoid reporting trivial tokens as expected tokens in error messages
    private boolean reportExpectedToken(Integer tokenId) {
        if (SqlScanner.isKeyword(tokenId) ||
                tokenId.intValue() == SqlParserSymbols.COMMA ||
                tokenId.intValue() == SqlParserSymbols.DOT ||
                tokenId.intValue() == SqlParserSymbols.IDENT) {
            return true;
        } else {
            return false;
        }
    }

    private String getErrorTypeMessage(int lastTokenId) {
        String msg = null;
        switch(lastTokenId) {
            case SqlParserSymbols.UNMATCHED_STRING_LITERAL:
                msg = "Unmatched string literal";
                break;
            case SqlParserSymbols.NUMERIC_OVERFLOW:
                msg = "Numeric overflow";
                break;
            default:
                msg = "Syntax error";
                break;
        }
        return msg;
    }

    // Override to save error token, just update error information.
    @Override
    public void syntax_error(Symbol token) {
        errorToken = token;

        // derive expected tokens from current parsing state
        expectedTokenIds.clear();
        int state = ((Symbol)stack.peek()).parse_state;
        // get row of actions table corresponding to current parsing state
        // the row consists of pairs of <tokenId, actionId>
        // a pair is stored as row[i] (tokenId) and row[i+1] (actionId)
        // the last pair is a special error action
        short[] row = action_tab[state];
        short tokenId;
        // the expected tokens are all the symbols with a
        // corresponding action from the current parsing state
        for (int i = 0; i < row.length-2; ++i) {
            // Get tokenId and skip actionId
            tokenId = row[i++];
            expectedTokenIds.add(Integer.valueOf(tokenId));
        }
    }

    // Override to keep it from calling report_fatal_error()
    // This exception is not AnalysisException because we don't want this report to client.
    @Override
    public void unrecovered_syntax_error(Symbol cur_token) throws AnalysisException {
        throw new AnalysisException(getErrorTypeMessage(cur_token.sym));
    }


    // Manually throw a parse error on a given symbol for special circumstances.
    public void parseError(String symbolName, int symbolId) throws AnalysisException {
        Symbol errorToken = getSymbolFactory().newSymbol(symbolName, symbolId,
                ((Symbol) stack.peek()), ((Symbol) stack.peek()), null);
        // Call syntax error to gather information about expected tokens, etc.
        // syntax_error does not throw an exception
        syntax_error(errorToken);

        unrecovered_syntax_error(errorToken);
    }

    // Returns error string, consisting of the original
    // stmt with a '^' under the offending token. Assumes
    // that parse() has been called and threw an exception
    public String getErrorMsg(String stmt) {
        if (errorToken == null || stmt == null) {
            return null;
        }
        String[] lines = stmt.split("\n", -1);
        StringBuilder result = new StringBuilder();
        result.append(getErrorTypeMessage(errorToken.sym) + " in line ");
        result.append(errorToken.left);
        result.append(":\n");

        // errorToken_.left is the line number of error.
        // errorToken_.right is the column number of the error.
        // index is start from 0, so "minus 1" is the real error line idx
        String errorLine = lines[errorToken.left - 1];
        // If the error is that additional tokens are expected past the end,
        // errorToken_.right will be past the end of the string.
        int lastCharIndex = Math.min(errorLine.length(), errorToken.right);
        int maxPrintLength = 60;
        int errorLoc = 0;
        if (errorLine.length() <= maxPrintLength) {
            // The line is short. Print the entire line.
            result.append(errorLine);
            result.append('\n');
            errorLoc = errorToken.right;
        } else {
            // The line is too long. Print maxPrintLength/2 characters before the error and
            // after the error.
            int contextLength = maxPrintLength / 2 - 3;
            String leftSubStr;
            if (errorToken.right > maxPrintLength / 2) {
                leftSubStr = "..." + errorLine.substring(errorToken.right - contextLength,
                        lastCharIndex);
            } else {
                leftSubStr = errorLine.substring(0, errorToken.right);
            }
            errorLoc = leftSubStr.length();
            result.append(leftSubStr);
            if (errorLine.length() - errorToken.right > maxPrintLength / 2) {
                result.append(errorLine.substring(errorToken.right,
                            errorToken.right + contextLength) + "...");
            } else {
                result.append(errorLine.substring(lastCharIndex));
            }
            result.append("\n");
        }

        // print error indicator
        for (int i = 0; i < errorLoc - 1; ++i) {
            result.append(' ');
        }
        result.append("^\n");

        // only report encountered and expected tokens for syntax errors
        if (errorToken.sym == SqlParserSymbols.UNMATCHED_STRING_LITERAL ||
                errorToken.sym == SqlParserSymbols.NUMERIC_OVERFLOW) {
            return result.toString();
        }

        // append last encountered token
        result.append("Encountered: ");
        String lastToken = SqlScanner.tokenIdMap.get(Integer.valueOf(errorToken.sym));
        if (lastToken != null) {
            result.append(lastToken);
        } else if (SqlScanner.isKeyword((String) errorToken.value)) {
            result.append("A reserved word cannot be used as an identifier: ").append((String) errorToken.value);
        } else {
            result.append("Unknown last token with id: " + errorToken.sym);
        }

        // Append expected tokens
        result.append('\n');
        result.append("Expected: ");
        String expectedToken = null;
        Integer tokenId = null;
        for (int i = 0; i < expectedTokenIds.size(); ++i) {
            tokenId = expectedTokenIds.get(i);
            // keywords hints
            if (SqlScanner.isKeyword(lastToken) && tokenId.intValue() == SqlParserSymbols.IDENT) {
                result.append(String.format("%s is keyword, maybe `%s`", lastToken, lastToken) + ", ");
                continue;
            }

            if (reportExpectedToken(tokenId)) {
                expectedToken = SqlScanner.tokenIdMap.get(tokenId);
                result.append(expectedToken + ", ");
            }
        }
        // remove trailing ", "
        result.delete(result.length() - 2, result.length());
        result.append('\n');

        return result.toString();
    }

:};

// Total keywords of doris, keep them in lexicographical order
terminal String
    KW_ACCOUNT_LOCK,
    KW_ACCOUNT_UNLOCK,
    KW_ADD,
    KW_ADMIN,
    KW_AFTER,
    KW_AGGREGATE,
    KW_ALIAS,
    KW_ALL,
    KW_ALTER,
    KW_ANALYZE,
    KW_AND,
    KW_ANTI,
    KW_APPEND,
    KW_ARRAY,
    KW_AS,
    KW_ASC,
    KW_AUTHORS,
    KW_BACKEND,
    KW_BACKENDS,
    KW_BACKUP,
    KW_BEGIN,
    KW_BETWEEN,
    KW_BIGINT,
    KW_BIN,
    KW_BINLOG,
    KW_BITMAP,
    KW_BITMAP_UNION,
    KW_BLOB,
    KW_BOOLEAN,
    KW_BROKER,
    KW_BUCKETS,
    KW_BUILD,
    KW_BUILTIN,
    KW_BY,
    KW_CANCEL,
    KW_CASE,
    KW_CAST,
    KW_CATALOG,
    KW_CATALOGS,
    KW_CHAIN,
    KW_CHAR,
    KW_CHARSET,
    KW_CHECK,
    KW_CLEAN,
    KW_CLUSTER,
    KW_CLUSTERS,
    KW_COLLATE,
    KW_COLLATION,
    KW_COLUMN,
    KW_COLUMNS,
    KW_COMMENT,
    KW_COMMIT,
    KW_COMMITTED,
    KW_COMPACT,
    KW_COMPLETE,
    KW_CONFIG,
    KW_CONNECTION,
    KW_CONNECTION_ID,
    KW_CONSISTENT,
    KW_CONVERT,
    KW_COPY,
    KW_COUNT,
    KW_CREATE,
    KW_CREATION,
    KW_CROSS,
    KW_CUBE,
    KW_CURRENT,
    KW_CURRENT_TIMESTAMP,
    KW_CURRENT_USER,
    KW_DATA,
    KW_DATABASE,
    KW_DATABASES,
    KW_DATE,
    KW_DATETIME,
    KW_DATETIMEV2,
    KW_DATEV2,
    KW_DAY,
    KW_DECIMAL,
    KW_DECIMALV3,
    KW_DECOMMISSION,
    KW_DEFAULT,
    KW_DEFERRED,
    KW_DELETE,
    KW_DEMAND,
    KW_DESC,
    KW_DESCRIBE,
    KW_DIAGNOSE,
    KW_DISK,
    KW_DISTINCT,
    KW_DISTINCTPC,
    KW_DISTINCTPCSA,
    KW_DISTRIBUTED,
    KW_DISTRIBUTION,
    KW_DIV,
    KW_DOUBLE,
    KW_DROP,
    KW_DROPP,
    KW_DUPLICATE,
    KW_DYNAMIC,
    KW_ELSE,
    KW_ENABLE,
    KW_ENCRYPTKEY,
    KW_ENCRYPTKEYS,
    KW_END,
    KW_ENGINE,
    KW_ENGINES,
    KW_ENTER,
    KW_ERRORS,
    KW_EVENTS,
    KW_EXCEPT,
    KW_EXCLUDE,
    KW_EXISTS,
    KW_EXPORT,
    KW_EXTENDED,
    KW_EXTERNAL,
    KW_EXTRACT,
    KW_FAILED_LOGIN_ATTEMPTS,
    KW_FALSE,
    KW_FAST,
    KW_FEATURE,
    KW_FIELDS,
    KW_FILE,
    KW_FILTER,
    KW_FIRST,
    KW_FLOAT,
    KW_FOLLOWER,
    KW_FOLLOWING,
    KW_FOR,
    KW_FORCE,
    KW_FORMAT,
    KW_FREE,
    KW_FROM,
    KW_FRONTEND,
    KW_FRONTENDS,
    KW_FULL,
    KW_FUNCTION,
    KW_FUNCTIONS,
    KW_GLOBAL,
    KW_GRANT,
    KW_GRANTS,
    KW_GRAPH,
    KW_GROUP,
    KW_GROUPING,
    KW_HASH,
    KW_HAVING,
    KW_HDFS,
    KW_HELP,
    KW_HLL,
    KW_HLL_UNION,
    KW_HOUR,
    KW_HUB,
    KW_IDENTIFIED,
    KW_IF,
    KW_IMMEDIATE,
    KW_IN,
    KW_INDEX,
    KW_INDEXES,
    KW_INFILE,
    KW_INNER,
    KW_INSERT,
    KW_INSTALL,
    KW_INT,
    KW_INTERMEDIATE,
    KW_INTERSECT,
    KW_INTERVAL,
    KW_INTO,
    KW_IS,
    KW_ISNULL,
    KW_ISOLATION,
    KW_INVERTED,
    KW_JOB,
    KW_JOIN,
    KW_JSONB,
    KW_KEY,
    KW_KEYS,
    KW_KILL,
    KW_LABEL,
    KW_LARGEINT,
    KW_LAST,
    KW_LATERAL,
    KW_LDAP_ADMIN_PASSWORD,
    KW_LEFT,
    KW_LESS,
    KW_LEVEL,
    KW_LIKE,
    KW_LIMIT,
    KW_LINK,
    KW_LIST,
    KW_LOAD,
    KW_LOCAL,
    KW_LOCATION,
    KW_LOCK,
    KW_LOW_PRIORITY,
    KW_MAP,
    KW_MATERIALIZED,
    KW_MAX,
    KW_MAX_VALUE,
    KW_MERGE,
    KW_MIGRATE,
    KW_MIGRATIONS,
    KW_MIN,
    KW_MINUS,
    KW_MINUTE,
    KW_MODIFY,
    KW_MONTH,
    KW_NAME,
    KW_NAMES,
    KW_NATURAL,
    KW_NEGATIVE,
    KW_NEVER,
    KW_NEXT,
    KW_NO,
    KW_NOT,
    KW_NULL,
    KW_NULLS,
    KW_OBSERVER,
    KW_OFFSET,
    KW_ON,
    KW_ONLY,
    KW_OPEN,
    KW_OR,
    KW_ORDER,
    KW_OUTER,
    KW_OUTFILE,
    KW_OVER,
    KW_PARAMETER,
    KW_PARTITION,
    KW_PARTITIONS,
    KW_PASSWORD,
    KW_PASSWORD_EXPIRE,
    KW_PASSWORD_HISTORY,
    KW_PASSWORD_LOCK_TIME,
    KW_PASSWORD_REUSE,
    KW_PATH,
    KW_PAUSE,
    KW_PIPE,
    KW_PLUGIN,
    KW_PLUGINS,
    KW_POLICY,
    KW_PRECEDING,
    KW_PERCENT,
    KW_RECYCLE,
    KW_PROC,
    KW_PROCEDURE,
    KW_PROCESSLIST,
    KW_PROFILE,
    KW_PROPERTIES,
    KW_PROPERTY,
    KW_QUANTILE_STATE,
    KW_QUANTILE_UNION,
    KW_QUERY,
    KW_QUOTA,
    KW_RANDOM,
    KW_RANGE,
    KW_READ,
    KW_REBALANCE,
    KW_RECOVER,
    KW_REFRESH,
    KW_REGEXP,
    KW_RELEASE,
    KW_RENAME,
    KW_REPAIR,
    KW_REPEATABLE,
    KW_REPLACE,
    KW_REPLACE_IF_NOT_NULL,
    KW_REPLICA,
    KW_REPOSITORIES,
    KW_REPOSITORY,
    KW_RESOURCE,
    KW_RESOURCES,
    KW_RESTORE,
    KW_RESUME,
    KW_RETURNS,
    KW_REVOKE,
    KW_RIGHT,
    KW_ROLE,
    KW_ROLES,
    KW_ROLLBACK,
    KW_ROLLUP,
    KW_ROUTINE,
    KW_ROW,
    KW_ROWS,
    KW_S3,
    KW_SCHEMA,
    KW_SCHEMAS,
    KW_SECOND,
    KW_SELECT,
    KW_SEMI,
    KW_SERIALIZABLE,
    KW_SESSION,
    KW_SET,
    KW_SETS,
    KW_SHOW,
    KW_SIGNED,
    KW_SKEW,
    KW_SMALLINT,
    KW_SNAPSHOT,
    KW_SONAME,
    KW_SPLIT,
    KW_SQL_BLOCK_RULE,
    KW_START,
    KW_STATS,
    KW_STATUS,
    KW_STOP,
    KW_STORAGE,
    KW_STREAM,
    KW_STRING,
    KW_STRUCT,
    KW_SUM,
    KW_SUPERUSER,
    KW_SWITCH,
    KW_SYNC,
    KW_SYSTEM,
    KW_TABLE,
    KW_TABLES,
    KW_TABLESAMPLE,
    KW_TABLET,
    KW_TABLETS,
    KW_TASK,
    KW_TEMPORARY,
    KW_TERMINATED,
    KW_TEXT,
    KW_THAN,
    KW_THEN,
    KW_TIME,
    KW_TIMESTAMP,
    KW_TINYINT,
    KW_TO,
    KW_TRANSACTION,
    KW_TRASH,
    KW_TRIGGERS,
    KW_TRIM,
    KW_TRUE,
    KW_TRUNCATE,
    KW_TYPE,
    KW_TYPES,
    KW_UNBOUNDED,
    KW_UNCOMMITTED,
    KW_UNINSTALL,
    KW_UNION,
    KW_UNIQUE,
    KW_UNLOCK,
    KW_UNSIGNED,
    KW_UPDATE,
    KW_USE,
    KW_USER,
    KW_USING,
    KW_VALUE,
    KW_VALUES,
    KW_VARCHAR,
    KW_VARIABLES,
    KW_VERBOSE,
    KW_VIEW,
    KW_WARNINGS,
    KW_WEEK,
    KW_WHEN,
    KW_WHERE,
    KW_WHITELIST,
    KW_WITH,
    KW_WORK,
    KW_WRITE,
    KW_YEAR,
    KW_MTMV;

terminal COMMA, COLON, DOT, DOTDOTDOT, AT, STAR, LPAREN, RPAREN, SEMICOLON, LBRACKET, RBRACKET, DIVIDE, MOD, ADD, SUBTRACT;
terminal BITAND, BITOR, BITXOR, BITNOT;
terminal EQUAL, NOT, LESSTHAN, GREATERTHAN, SET_VAR;
terminal COMMENTED_PLAN_HINT_START, COMMENTED_PLAN_HINT_END;
terminal String IDENT;
terminal String NUMERIC_OVERFLOW;
terminal Long INTEGER_LITERAL;
terminal String LARGE_INTEGER_LITERAL;
terminal Double FLOATINGPOINT_LITERAL;
terminal BigDecimal DECIMAL_LITERAL;
terminal String STRING_LITERAL;
terminal String UNMATCHED_STRING_LITERAL;
terminal String COMMENTED_PLAN_HINTS;

// Statement that the result of this parser.
nonterminal List<StatementBase> stmts;
nonterminal StatementBase stmt, show_stmt, show_param, help_stmt, load_stmt,
    create_routine_load_stmt, pause_routine_load_stmt, resume_routine_load_stmt, stop_routine_load_stmt,
    show_routine_load_stmt, show_routine_load_task_stmt, show_create_routine_load_stmt,
    describe_stmt, alter_stmt,
    use_stmt, kill_stmt, drop_stmt, recover_stmt, grant_stmt, revoke_stmt, create_stmt, set_stmt, sync_stmt, cancel_stmt, cancel_param, delete_stmt,
    link_stmt, migrate_stmt, switch_stmt, enter_stmt, transaction_stmt, unsupported_stmt, export_stmt, admin_stmt, truncate_stmt,
    import_columns_stmt, import_delete_on_stmt, import_sequence_stmt, import_where_stmt, install_plugin_stmt, uninstall_plugin_stmt,
    import_preceding_filter_stmt, unlock_tables_stmt, lock_tables_stmt, refresh_stmt, clean_stmt, analyze_stmt, show_mtmv_stmt;

nonterminal String transaction_label;
nonterminal ImportColumnDesc import_column_desc;
nonterminal List<ImportColumnDesc> import_column_descs;

// unsupported statement
nonterminal opt_with_consistent_snapshot, opt_work, opt_chain, opt_release;

// Single select statement.
nonterminal SelectStmt select_stmt;
nonterminal ValueList value_clause;

// No return.
nonterminal describe_command, opt_full, opt_inner, opt_outer, from_or_in, keys_or_index, opt_storage, opt_wild_where,
            charset, equal, transaction_characteristics, isolation_level,
            transaction_access_mode, isolation_types;

// String
nonterminal String user, opt_user;
nonterminal UserIdentity user_identity;
nonterminal String quantity;

// Description of user
nonterminal UserDesc grant_user;

// Select or set operation(union/intersect/except) statement.
nonterminal QueryStmt query_stmt;
// Single select_stmt or parenthesized query_stmt.
nonterminal QueryStmt set_operand;
// List of select or set operation(union/intersect/except) blocks connected by  set operators or a single select block.
nonterminal List<SetOperand> set_operand_list;
// List of select blocks connected by set operators, with order by or limit.
nonterminal QueryStmt set_operation_with_order_by_or_limit;
nonterminal InsertStmt insert_stmt;
nonterminal InsertTarget insert_target;
nonterminal InsertSource insert_source;
nonterminal UpdateStmt update_stmt;

nonterminal BackupStmt backup_stmt;
nonterminal AbstractBackupTableRefClause opt_backup_table_ref_list;
nonterminal Boolean backup_exclude_or_not;
nonterminal RestoreStmt restore_stmt;

nonterminal SelectList select_clause, select_list, select_sublist;
nonterminal SelectListItem select_list_item, star_expr;
nonterminal Expr expr, non_pred_expr, arithmetic_expr, timestamp_arithmetic_expr, expr_or_default;
nonterminal Expr set_expr_or_default;
nonterminal ArrayList<Expr> expr_list, values, row_value, opt_values;
nonterminal ArrayList<Expr> func_arg_list;
nonterminal ArrayList<Expr> expr_pipe_list;
nonterminal String select_alias, opt_table_alias, lock_alias, opt_alias;
nonterminal ArrayList<String> ident_list;
nonterminal PartitionNames opt_partition_names, partition_names;
nonterminal ArrayList<Long> opt_tablet_list, tablet_list;
nonterminal TableSample opt_table_sample, table_sample;
nonterminal ClusterName cluster_name;
nonterminal ClusterName des_cluster_name;
nonterminal TableName table_name, opt_table_name;
nonterminal FunctionName function_name;
nonterminal EncryptKeyName encryptkey_name;
nonterminal Expr pre_filter_clause;
nonterminal Expr where_clause;
nonterminal Expr delete_on_clause;
nonterminal String sequence_col_clause;
nonterminal Predicate predicate, between_predicate, comparison_predicate,
  compound_predicate, in_predicate, like_predicate, exists_predicate;
nonterminal ArrayList<Expr> opt_partition_by_clause;
nonterminal Expr having_clause;
nonterminal ArrayList<OrderByElement> order_by_elements, order_by_clause;
nonterminal OrderByElement order_by_element;
nonterminal Boolean opt_order_param;
nonterminal Boolean opt_nulls_order_param;
nonterminal LimitElement limit_clause;
nonterminal TypeDef type_def, opt_intermediate_type;
nonterminal List<TypeDef> type_def_list;
nonterminal FunctionArgsDef func_args_def;
nonterminal Type type;
nonterminal Expr cast_expr, case_else_clause, analytic_expr;
nonterminal LiteralExpr literal;
nonterminal CaseExpr case_expr;
nonterminal ArrayList<CaseWhenClause> case_when_clause_list;
nonterminal FunctionParams function_params;
nonterminal Expr function_call_expr, array_expr;
nonterminal ArrayLiteral array_literal;
nonterminal StructField struct_field;
nonterminal ArrayList<StructField> struct_field_list;
nonterminal AnalyticWindow opt_window_clause;
nonterminal AnalyticWindow.Type window_type;
nonterminal AnalyticWindow.Boundary window_boundary;
nonterminal SlotRef column_ref;
nonterminal ArrayList<SlotRef> column_ref_list;
nonterminal FunctionCallExpr column_subscript;
nonterminal FunctionCallExpr column_slice;
nonterminal ArrayList<TableRef> table_ref_list, base_table_ref_list;
nonterminal ArrayList<LateralViewRef> opt_lateral_view_ref_list, lateral_view_ref_list;
nonterminal FromClause from_clause;
nonterminal TableRef table_ref;
nonterminal TableRef base_table_ref;
nonterminal LateralViewRef lateral_view_ref;
nonterminal WithClause opt_with_clause;
nonterminal ArrayList<View> with_view_def_list;
nonterminal View with_view_def;
nonterminal Subquery subquery;
nonterminal TableValuedFunctionRef table_valued_function_ref;
nonterminal InlineViewRef inline_view_ref;
nonterminal JoinOperator join_operator;
nonterminal ArrayList<String> opt_plan_hints;
nonterminal ArrayList<String> opt_sort_hints;
nonterminal Map<String, Map<String, String>> opt_select_hints;
nonterminal Map<String, Map<String, String>> query_hints;
nonterminal Map.Entry<String, Map<String, String>> query_hint;
nonterminal Map<String, String> query_hint_parameters;
nonterminal Map.Entry<String, String> query_hint_parameter;
nonterminal String query_hint_parameter_key;
nonterminal Expr sign_chain_expr;
nonterminal Qualifier opt_set_qualifier;
nonterminal Operation set_op;
nonterminal ArrayList<String> opt_common_hints;

nonterminal LoadTask.MergeType opt_merge_type, opt_with_merge_type;

// Set type
nonterminal SetType option_type, opt_var_type, var_ident_type;

// Set variable
nonterminal SetVar option_value, option_value_follow_option_type, option_value_no_option_type,
        user_property;

// List of set variable
nonterminal List<SetVar> option_value_list, option_value_list_continued, start_option_value_list,
        start_option_value_list_following_option_type, user_property_list;

nonterminal Map<String, String> key_value_map, opt_key_value_map, opt_properties,
            opt_ext_properties, opt_enable_feature_properties, properties;
nonterminal ColumnDef column_definition;
nonterminal IndexDef index_definition;
nonterminal ArrayList<ColumnDef> column_definition_list;
nonterminal ArrayList<IndexDef> index_definition_list;
nonterminal AggregateType opt_agg_type;
nonterminal PartitionDesc opt_partition;
nonterminal DistributionDesc opt_distribution;
nonterminal Integer opt_distribution_number;
nonterminal Long opt_field_length;
nonterminal KeysDesc opt_keys;
nonterminal KeysDesc opt_mv_keys;
nonterminal Long opt_id;

nonterminal PartitionKeyDesc partition_key_desc;
nonterminal PartitionKeyDesc list_partition_key_desc;
nonterminal PartitionKeyDesc fixed_partition_key_desc;
nonterminal List<PartitionValue> partition_key_list;
nonterminal List<PartitionValue> partition_value_list;
nonterminal List<PartitionValue> partition_key_item_list;
nonterminal List<List<PartitionValue>> list_partition_values_list;
nonterminal SinglePartitionDesc single_partition_desc;
nonterminal List<AllPartitionDesc> opt_all_partition_desc_list;
nonterminal List<AllPartitionDesc> all_partition_desc_list;
nonterminal PartitionKeyDesc fixed_multi_partition_key_desc;
nonterminal MultiPartitionDesc multi_partition_desc;

nonterminal List<AccessPrivilege> privilege_list;
nonterminal List<String> string_list;
nonterminal List<Long> integer_list, cancel_rollup_job_id_list;
nonterminal AccessPrivilege privilege_type;

nonterminal DataDescription data_desc;
nonterminal List<DataDescription> data_desc_list;
nonterminal LabelName job_label;
nonterminal String opt_with_label;
nonterminal String opt_system;
nonterminal BrokerDesc opt_broker;
nonterminal ResourceDesc resource_desc;
nonterminal List<String> opt_col_list, opt_dup_keys, opt_columns_from_path;
nonterminal List<ColWithComment> opt_col_with_comment_list, col_with_comment_list;
nonterminal ColWithComment col_with_comment;
nonterminal List<Expr> opt_col_mapping_list;
nonterminal Separator opt_field_term, separator;
nonterminal String opt_user_role;
nonterminal TablePattern tbl_pattern;
nonterminal ResourcePattern resource_pattern;
nonterminal String ident_or_star;

// password policy
nonterminal PasswordOptions opt_password_option;
nonterminal Integer opt_passwd_history_policy, opt_passwd_reuse_policy;
nonterminal Integer opt_failed_login_attempts, passwd_history_opt, passwd_reuse_opt, opt_lock_account, passwd_time_unit;
nonterminal Long opt_passwd_expire_policy, opt_password_lock_time, passwd_expire_opt, passwd_lock_time_opt;

// Routine load
nonterminal ParseNode load_property;
nonterminal List<ParseNode> opt_load_property_list;

// Boolean
nonterminal Boolean opt_negative, opt_is_allow_null, opt_is_key, opt_read_only, opt_aggregate;
nonterminal String opt_from_rollup, opt_to_rollup;
nonterminal ColumnPosition opt_col_pos;

// Alter statement
nonterminal AlterClause alter_system_clause, alter_table_clause;
nonterminal List<AlterClause> alter_table_clause_list, opt_rollup, add_rollup_clause_list, drop_rollup_clause_list;
nonterminal AddRollupClause add_rollup_clause;
nonterminal DropRollupClause drop_rollup_clause;

// grouping sets
nonterminal List<ArrayList<Expr>> grouping_set_list;
nonterminal ArrayList<Expr> grouping_set;
nonterminal GroupByClause group_by_clause, grouping_elements;
//
nonterminal String keyword, ident, ident_or_text, variable_name,
        charset_name_or_default, old_or_new_charset_name_or_default, opt_collate,
        collation_name_or_default, type_func_name_keyword, type_function_name, opt_file_format, time_unit,
        literal_or_ident;
nonterminal PassVar text_or_password;

// sync job
nonterminal List<ChannelDescription> channel_desc_list;
nonterminal ChannelDescription channel_desc;
nonterminal BinlogDesc binlog_desc;
nonterminal ResumeSyncJobStmt resume_sync_job_stmt;
nonterminal PauseSyncJobStmt pause_sync_job_stmt;
nonterminal StopSyncJobStmt stop_sync_job_stmt;
nonterminal JobName job_name;

nonterminal String opt_db, procedure_or_function, opt_comment, opt_engine;
nonterminal ColumnDef.DefaultValue opt_default_value;
nonterminal Boolean opt_if_exists, opt_if_not_exists;
nonterminal Boolean opt_external;
nonterminal Boolean opt_force;
nonterminal IndexDef.IndexType opt_index_type;

nonterminal ShowAlterStmt.AlterType opt_alter_type;
nonterminal Boolean opt_builtin;
nonterminal ExplainOptions opt_explain_options;

nonterminal Boolean opt_tmp;

nonterminal OutFileClause opt_outfile;
nonterminal RoutineLoadDataSourceProperties opt_datasource_properties;

nonterminal Boolean opt_signed_unsigned;

nonterminal StorageBackend storage_backend;

nonterminal ArrayList<LockTable> opt_lock_tables_list;
nonterminal LockTable lock_table;

// mv
nonterminal MVRefreshInfo.BuildMode build_mv;
nonterminal MVRefreshInfo.RefreshMethod opt_refresh_method;
nonterminal MVRefreshTriggerInfo opt_refresh_trigger;
nonterminal MVRefreshInfo opt_mv_refersh_info;
nonterminal PartitionDesc opt_mv_partition;

precedence nonassoc COMMA;
precedence nonassoc STRING_LITERAL;
precedence nonassoc KW_COLUMNS;
precedence nonassoc KW_WITH;

precedence left KW_FULL, KW_MERGE;
precedence left DOT;
precedence left SET_VAR;
precedence left KW_OR;
precedence left KW_AND;
precedence left KW_NOT, NOT;
precedence left KW_BETWEEN, KW_IN, KW_IS, KW_EXISTS;
precedence left KW_LIKE, KW_REGEXP;
precedence left EQUAL, LESSTHAN, GREATERTHAN;
precedence left ADD, SUBTRACT;
precedence left AT, STAR, DIVIDE, MOD, KW_DIV;
precedence left KW_EXCEPT;
precedence left BITAND, BITOR, BITXOR;
precedence left KW_PIPE;
precedence left BITNOT;
precedence left KW_ORDER, KW_BY, KW_LIMIT;
precedence right KW_PROPERTIES;
precedence left LPAREN, RPAREN;
// Support chaining of timestamp arithmetic exprs.
precedence left KW_INTERVAL;
precedence left KW_OVER;
precedence left KW_COLLATE;
precedence left KW_PARTITION;
precedence left KW_PARTITIONS;
precedence right KW_TEMPORARY;
precedence right LBRACKET;
precedence left KW_ENGINE;

// unused
// nonterminal Expr where_clause_without_null, List<String> col_list, opt_charset_name, AlterClause alter_cluster_clause;

start with stmts;

stmts ::=
    stmt:stmt
    {:
        RESULT = Lists.newArrayList(stmt);
    :}
    | stmts:stmts SEMICOLON stmt:stmt
    {:
        stmts.add(stmt);
        RESULT = stmts;
    :}
    | import_columns_stmt:stmt
    {:
        RESULT = Lists.newArrayList(stmt);
    :}
    | import_where_stmt:stmt
    {:
        RESULT = Lists.newArrayList(stmt);
    :}
    | import_delete_on_stmt:stmt
    {:
        RESULT = Lists.newArrayList(stmt);
    :}
    | import_sequence_stmt:stmt
    {:
        RESULT = Lists.newArrayList(stmt);
    :}
    | import_preceding_filter_stmt:stmt
    {:
        RESULT = Lists.newArrayList(stmt);
    :}
    ;

import_columns_stmt ::=
    KW_COLUMNS LPAREN import_column_descs:columns RPAREN
    {:
        RESULT = new ImportColumnsStmt(columns);
    :}
    ;

import_column_descs ::=
    import_column_desc:column
    {:
        RESULT = Lists.newArrayList(column);
    :}
    | import_column_descs:columns COMMA import_column_desc:column
    {:
        columns.add(column);
        RESULT = columns;
    :}
    ;

import_column_desc ::=
    ident:name
    {:
        RESULT = new ImportColumnDesc(name, null);
    :}
    | ident:name EQUAL expr:expr
    {:
        RESULT = new ImportColumnDesc(name, expr);
    :}
    ;

import_where_stmt ::=
    KW_WHERE expr:expr
    {:
        RESULT = new ImportWhereStmt(expr, false);
    :}
    ;

import_delete_on_stmt ::=
    KW_DELETE KW_ON expr:expr
    {:
        RESULT = new ImportDeleteOnStmt(expr);
    :}
    ;

import_sequence_stmt ::=
    KW_ORDER KW_BY ident:s
    {:
        RESULT = new ImportSequenceStmt(s);
    :}
    ;

import_preceding_filter_stmt ::=
    KW_PRECEDING KW_FILTER expr:expr
    {:
        RESULT = new ImportWhereStmt(expr, true);
    :}
    ;

stmt ::=
     alter_stmt:stmt
    {: RESULT = stmt; :}
    | create_stmt:query
    {: RESULT = query; :}
    | link_stmt:query
    {: RESULT = query; :}
    | migrate_stmt:query
    {: RESULT = query; :}
    | switch_stmt:stmt
    {: RESULT = stmt; :}
    | enter_stmt:enter
    {: RESULT = enter; :}
    | query_stmt:query
    {: RESULT = query; :}
    | drop_stmt:stmt
    {: RESULT = stmt; :}
    | recover_stmt:stmt
    {: RESULT = stmt; :}
    | use_stmt:use
    {: RESULT = use; :}
    | set_stmt:set
    {: RESULT = set; :}
    | kill_stmt:kill
    {: RESULT = kill; :}
    | describe_stmt:describe
    {: RESULT = describe; :}
    | show_stmt:show
    {: RESULT = show; :}
    | grant_stmt:grant
    {: RESULT = grant; :}
    | revoke_stmt:revoke
    {: RESULT = revoke; :}
    | help_stmt : stmt
    {: RESULT = stmt; :}
    | load_stmt : stmt
    {: RESULT = stmt; :}
    | create_routine_load_stmt : stmt
    {: RESULT = stmt; :}
    | pause_routine_load_stmt : stmt
    {: RESULT = stmt; :}
    | resume_routine_load_stmt : stmt
    {: RESULT = stmt; :}
    | pause_sync_job_stmt : stmt
    {: RESULT = stmt; :}
    | resume_sync_job_stmt : stmt
    {: RESULT = stmt; :}
    | stop_sync_job_stmt : stmt
    {: RESULT = stmt; :}
    | stop_routine_load_stmt : stmt
    {: RESULT = stmt; :}
    | show_routine_load_stmt : stmt
    {: RESULT = stmt; :}
    | show_routine_load_task_stmt : stmt
    {: RESULT = stmt; :}
    | show_create_routine_load_stmt : stmt
    {: RESULT = stmt; :}
    | cancel_stmt : stmt
    {: RESULT = stmt; :}
    | delete_stmt : stmt
    {: RESULT = stmt; :}
    | sync_stmt : stmt
    {: RESULT = stmt; :}
    | insert_stmt : stmt
    {: RESULT = stmt; :}
    | update_stmt : stmt
    {: RESULT = stmt; :}
    | backup_stmt : stmt
    {: RESULT = stmt; :}
    | restore_stmt : stmt
    {: RESULT = stmt; :}
    | transaction_stmt : stmt
    {: RESULT = stmt; :}
    | unsupported_stmt : stmt
    {: RESULT = stmt; :}
    | export_stmt : stmt
    {: RESULT = stmt; :}
    | admin_stmt : stmt
    {: RESULT = stmt; :}
    | truncate_stmt : stmt
    {: RESULT = stmt; :}
    | install_plugin_stmt : stmt
    {: RESULT = stmt; :}
    | uninstall_plugin_stmt : stmt
    {: RESULT = stmt; :}
    | lock_tables_stmt:stmt
    {: RESULT = stmt; :}
    | unlock_tables_stmt:stmt
    {: RESULT = stmt; :}
    | refresh_stmt:stmt
    {: RESULT = stmt; :}
    | clean_stmt:stmt
    {: RESULT = stmt; :}
    | analyze_stmt:stmt
    {: RESULT = stmt; :}
    | show_mtmv_stmt : stmt
    {: RESULT = stmt; :}
    | /* empty: query only has comments */
    {:
        RESULT = new EmptyStmt();
    :}
    ;

cluster_name ::=
    ident:cluster
    {:
        RESULT = new ClusterName(cluster, "");
    :}
    | ident:cluster DOT ident:db
    {:
        RESULT = new ClusterName(cluster, db);
    :}
    ;

des_cluster_name ::=
    ident:cluster
    {:
        RESULT = new ClusterName(cluster, "");
    :}
    | ident:cluster DOT ident:db
    {:
        RESULT = new ClusterName(cluster, db);
    :}
    ;

refresh_stmt ::=
    KW_REFRESH KW_TABLE table_name:tbl
    {:
        RESULT = new RefreshTableStmt(tbl);
    :}
    | KW_REFRESH KW_DATABASE ident:db opt_properties:properties
    {:
        RESULT = new RefreshDbStmt(db, properties);
    :}
    | KW_REFRESH KW_DATABASE ident:ctl DOT ident:db opt_properties:properties
    {:
        RESULT = new RefreshDbStmt(ctl, db, properties);
    :}
    | KW_REFRESH KW_MATERIALIZED KW_VIEW table_name:mv
    {:
        RESULT = new RefreshMaterializedViewStmt(mv, MVRefreshInfo.RefreshMethod.COMPLETE);
    :}
    | KW_REFRESH KW_MATERIALIZED KW_VIEW table_name:mv KW_COMPLETE
    {:
        RESULT = new RefreshMaterializedViewStmt(mv, MVRefreshInfo.RefreshMethod.COMPLETE);
    :}
    | KW_REFRESH KW_CATALOG ident:catalogName opt_properties:properties
    {:
        RESULT = new RefreshCatalogStmt(catalogName, properties);
    :}
    ;

clean_stmt ::=
    KW_CLEAN KW_LABEL from_or_in ident:db
    {:
        RESULT = new CleanLabelStmt(db, null);
    :}
    | KW_CLEAN KW_LABEL ident:label from_or_in ident:db
    {:
        RESULT = new CleanLabelStmt(db, label);
    :}
    ;

// plugin statement
install_plugin_stmt ::=
    KW_INSTALL KW_PLUGIN KW_FROM ident_or_text:source opt_properties:properties
    {:
        RESULT = new InstallPluginStmt(source, properties);
    :}
    ;

uninstall_plugin_stmt ::=
    KW_UNINSTALL KW_PLUGIN ident_or_text:name
    {:
        RESULT = new UninstallPluginStmt(name);
    :}
    ;

// link statement
link_stmt ::=
    KW_LINK KW_DATABASE cluster_name:src_name des_cluster_name:des_name
    {:
        RESULT = new LinkDbStmt(src_name, des_name);
    :}
    ;

// migrate statement
migrate_stmt ::=
    KW_MIGRATE KW_DATABASE cluster_name:src_name des_cluster_name:des_name
    {:
        RESULT = new MigrateDbStmt(src_name, des_name);
    :}
    ;

// Alter Statement
alter_stmt ::=
    KW_ALTER KW_TABLE table_name:tbl
    alter_table_clause_list:clauses
    {:
        RESULT = new AlterTableStmt(tbl, clauses);
    :}
    | KW_ALTER KW_TABLE table_name:tbl KW_ADD KW_ROLLUP add_rollup_clause_list:clauses
    {:
        RESULT = new AlterTableStmt(tbl, clauses);
    :}
    | KW_ALTER KW_TABLE table_name:tbl KW_DROP KW_ROLLUP drop_rollup_clause_list:clauses
    {:
        RESULT = new AlterTableStmt(tbl, clauses);
    :}
    | KW_ALTER KW_VIEW table_name:tbl
    opt_col_with_comment_list:columns KW_AS query_stmt:view_def
    {:
        RESULT = new AlterViewStmt(tbl, columns, view_def);
    :}
    | KW_ALTER KW_SYSTEM alter_system_clause:clause
    {:
        RESULT = new AlterSystemStmt(clause);
    :}
    | KW_ALTER KW_CLUSTER ident:name opt_properties:properties
    {:
        RESULT = new AlterClusterStmt(name, properties);
    :}
    | KW_ALTER KW_DATABASE ident:dbName KW_SET KW_DATA KW_QUOTA quantity:quota_quantity
    {:
        RESULT = new AlterDatabaseQuotaStmt(dbName, QuotaType.DATA, quota_quantity);
    :}
    | KW_ALTER KW_DATABASE ident:dbName KW_SET KW_REPLICA KW_QUOTA INTEGER_LITERAL:number
    {:
        RESULT = new AlterDatabaseQuotaStmt(dbName, QuotaType.REPLICA, String.valueOf(number));
    :}
    | KW_ALTER KW_DATABASE ident:dbName KW_RENAME ident:newDbName
    {:
        RESULT = new AlterDatabaseRename(dbName, newDbName);
    :}
    | KW_ALTER KW_DATABASE ident:dbName KW_SET KW_PROPERTIES LPAREN key_value_map:map RPAREN
    {:
        RESULT = new AlterDatabasePropertyStmt(dbName, map);
    :}
    /* Catalog */
    | KW_ALTER KW_CATALOG ident:catalogName KW_RENAME ident:newCatalogName
    {:
        RESULT = new AlterCatalogNameStmt(catalogName, newCatalogName);
    :}
    | KW_ALTER KW_CATALOG ident:catalogName KW_SET KW_PROPERTIES LPAREN key_value_map:map RPAREN
    {:
        RESULT = new AlterCatalogPropertyStmt(catalogName, map);
    :}
    | KW_ALTER KW_RESOURCE ident_or_text:resourceName opt_properties:properties
    {:
        RESULT = new AlterResourceStmt(resourceName, properties);
    :}
    | KW_ALTER KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel opt_properties:jobProperties
      opt_datasource_properties:datasourceProperties
    {:
        RESULT = new AlterRoutineLoadStmt(jobLabel, jobProperties, datasourceProperties);
    :}
    | KW_ALTER KW_SQL_BLOCK_RULE ident:ruleName
    opt_properties:properties
    {:
        RESULT = new AlterSqlBlockRuleStmt(ruleName, properties);
    :}
    | KW_ALTER KW_TABLE table_name:tbl KW_MODIFY KW_COLUMN ident:columnName
      KW_SET KW_STATS LPAREN key_value_map:map RPAREN opt_partition_names:partitionNames
    {:
        RESULT = new AlterColumnStatsStmt(tbl, columnName, map, partitionNames);
    :}
    | KW_ALTER KW_TABLE table_name:tbl KW_SET LPAREN key_value_map:properties RPAREN
    {:
        ModifyTablePropertiesClause clause = new ModifyTablePropertiesClause(properties);
        RESULT = new AlterTableStmt(tbl, Lists.newArrayList(clause));
    :}
    | KW_ALTER KW_STORAGE KW_POLICY ident_or_text:policyName opt_properties:properties
    {:
        RESULT = new AlterPolicyStmt(policyName, properties);
    :}
    | KW_ALTER KW_MATERIALIZED KW_VIEW table_name:mv opt_mv_refersh_info:refreshInfo
    {:
        RESULT = new AlterMaterializedViewStmt(mv, refreshInfo);
    :}
    | KW_ALTER KW_USER
      opt_if_exists:ifExists
      grant_user:user
      opt_user_role:userRole
      opt_password_option:passwdOptions
    {:
        RESULT = new AlterUserStmt(ifExists, user, userRole, passwdOptions);
    :}
    ;

opt_datasource_properties ::=
    // empty
    {:
        RESULT = new RoutineLoadDataSourceProperties();
    :}
    | KW_FROM ident:type LPAREN key_value_map:customProperties RPAREN
    {:
        // the 3rd parameter "true" means this is for AlterRoutineLoad operation.
        RESULT = new RoutineLoadDataSourceProperties(type, customProperties, true);
    :}
    ;

quantity ::=
    INTEGER_LITERAL:number
    {:
        RESULT = number.toString();
    :}
    | ident:number_unit
    {:
        RESULT = number_unit;
    :}
    ;

opt_user ::=
    /* empty */
    | KW_FOR user:user

    {:
        RESULT = user;

    :}
    ;

add_rollup_clause ::=
    ident:rollupName LPAREN ident_list:cols RPAREN opt_dup_keys:dup_keys opt_from_rollup:baseRollup opt_properties:properties
    {:
        RESULT = new AddRollupClause(rollupName, cols, dup_keys, baseRollup, properties);
    :}
    ;

add_rollup_clause_list ::=
    add_rollup_clause:clause
    {:
        RESULT = Lists.newArrayList(clause);
    :}
    | add_rollup_clause_list:list COMMA add_rollup_clause:clause
    {:
        list.add(clause);
        RESULT = list;
    :}
    ;

drop_rollup_clause ::=
    ident:rollupName opt_properties:properties
    {:
        RESULT = new DropRollupClause(rollupName, properties);
    :}
    ;

drop_rollup_clause_list ::=
    drop_rollup_clause:clause
    {:
        RESULT = Lists.newArrayList(clause);
    :}
    | drop_rollup_clause_list:list COMMA drop_rollup_clause:clause
    {:
        list.add(clause);
        RESULT = list;
    :}
    ;

alter_table_clause_list ::=
    alter_table_clause:clause
    {:
        RESULT = Lists.newArrayList(clause);
    :}
    | alter_table_clause_list:list COMMA alter_table_clause:clause
    {:
        list.add(clause);
        RESULT = list;
    :}
    ;

opt_to_rollup ::=
    {:
        RESULT = null;
    :}
    | KW_TO ident:rollup
    {:
        RESULT = rollup;
    :}
    | KW_IN ident:rollup
    {:
        RESULT = rollup;
    :}
    ;

opt_from_rollup ::=
    {:
        RESULT = null;
    :}
    | KW_FROM ident:rollup
    {:
        RESULT = rollup;
    :}
    ;

opt_col_pos ::=
    {:
        RESULT = null;
    :}
    | KW_FIRST
    {:
        RESULT = ColumnPosition.FIRST;
    :}
    | KW_AFTER ident:col
    {:
        RESULT = new ColumnPosition(col);
    :}
    ;

opt_dup_keys ::=
    {:
        RESULT = null;
    :}
    | KW_DUPLICATE KW_KEY LPAREN ident_list:cols RPAREN
    {:
        RESULT = cols;
    :}
    ;

alter_table_clause ::=
    KW_ADD KW_COLUMN column_definition:col opt_col_pos:col_pos opt_to_rollup:rollup opt_properties:properties
    {:
        RESULT = new AddColumnClause(col, col_pos, rollup, properties);
    :}
    | KW_ADD KW_COLUMN LPAREN column_definition_list:cols RPAREN opt_to_rollup:rollup opt_properties:properties
    {:
        RESULT = new AddColumnsClause(cols, rollup, properties);
    :}
    | KW_DROP KW_COLUMN ident:col opt_from_rollup:rollup opt_properties:properties
    {:
        RESULT = new DropColumnClause(col, rollup, properties);
    :}
    | KW_MODIFY KW_COLUMN column_definition:col opt_col_pos:col_pos opt_from_rollup:rollup opt_properties:properties
    {:
        RESULT = new ModifyColumnClause(col, col_pos, rollup, properties);
    :}
    | KW_ORDER KW_BY LPAREN ident_list:cols RPAREN opt_from_rollup:rollup opt_properties:properties
    {:
        RESULT = new ReorderColumnsClause(cols, rollup, properties);
    :}
    | KW_ADD opt_tmp:isTempPartition single_partition_desc:desc opt_distribution:distribution opt_properties:properties
    {:
        RESULT = new AddPartitionClause(desc, distribution, properties, isTempPartition);
    :}
    | KW_DROP opt_tmp:isTempPartition KW_PARTITION opt_if_exists:ifExists ident:partitionName opt_force:force
    {:
        RESULT = new DropPartitionClause(ifExists, partitionName, isTempPartition, force ? force : isTempPartition);
    :}
    | KW_MODIFY KW_PARTITION ident:partitionName KW_SET LPAREN key_value_map:properties RPAREN
    {:
        ArrayList<String> partitions = new ArrayList<String>();
        partitions.add(partitionName);
        RESULT = new ModifyPartitionClause(partitions, properties);
    :}
    | KW_MODIFY KW_PARTITION LPAREN ident_list:partitions RPAREN KW_SET LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new ModifyPartitionClause(partitions, properties);
    :}
    | KW_MODIFY KW_PARTITION LPAREN STAR RPAREN KW_SET LPAREN key_value_map:properties RPAREN
    {:
        RESULT = ModifyPartitionClause.createStarClause(properties);
    :}
    | KW_REPLACE opt_partition_names:partitions KW_WITH opt_partition_names:tempPartitions opt_properties:properties
    {:
        RESULT = new ReplacePartitionClause(partitions, tempPartitions, properties);
    :}
    | KW_REPLACE KW_WITH KW_TABLE ident:tblName opt_properties:properties
    {:
        RESULT = new ReplaceTableClause(tblName, properties);
    :}
    | KW_RENAME ident:newTableName
    {:
        RESULT = new TableRenameClause(newTableName);
    :}
    | KW_RENAME KW_ROLLUP ident:rollupName ident:newRollupName
    {:
        RESULT = new RollupRenameClause(rollupName, newRollupName);
    :}
    | KW_RENAME KW_PARTITION ident:partitionName ident:newPartitionName
    {:
        RESULT = new PartitionRenameClause(partitionName, newPartitionName);
    :}
    | KW_RENAME KW_COLUMN ident:colName ident:newColName
    {:
        RESULT = new ColumnRenameClause(colName, newColName);
    :}
    | KW_ADD index_definition:indexDef
    {:
        RESULT = new CreateIndexClause(null, indexDef, true);
    :}
    | KW_DROP KW_INDEX opt_if_exists:ifExists ident:indexName
    {:
        RESULT = new DropIndexClause(indexName, ifExists, null, true);
    :}
    | KW_ENABLE KW_FEATURE STRING_LITERAL:featureName opt_enable_feature_properties:properties
    {:
        RESULT = new EnableFeatureClause(featureName, properties);
    :}
    | KW_MODIFY KW_DISTRIBUTION opt_distribution:distribution
    {:
        RESULT = new ModifyDistributionClause(distribution);
    :}
    | KW_MODIFY KW_COMMENT STRING_LITERAL:comment
    {:
        RESULT = new ModifyTableCommentClause(comment);
    :}
    | KW_MODIFY KW_COLUMN ident:colName KW_COMMENT STRING_LITERAL:comment
    {:
        RESULT = new ModifyColumnCommentClause(colName, comment);
    :}
    | KW_MODIFY KW_ENGINE KW_TO ident:engine opt_properties:properties
    {:
        RESULT = new ModifyEngineClause(engine, properties);
    :}
    ;

opt_enable_feature_properties ::=
    {:
    RESULT = null;
    :}
    | KW_WITH properties:properties
    {:
    RESULT = properties;
    :}
    ;

alter_system_clause ::=
    KW_ADD KW_BACKEND string_list:hostPorts opt_properties:properties
    {:
        RESULT = new AddBackendClause(hostPorts, false, properties);
    :}
    | KW_ADD KW_FREE KW_BACKEND string_list:hostPorts
    {:
        RESULT = new AddBackendClause(hostPorts, true, Maps.newHashMap());
    :}
    | KW_ADD KW_BACKEND KW_TO ident:clusterName string_list:hostPorts
    {:
        RESULT = new AddBackendClause(hostPorts, clusterName);
    :}
    | KW_DROP KW_BACKEND string_list:hostPorts
    {:
        RESULT = new DropBackendClause(hostPorts, false);
    :}
    | KW_DROPP KW_BACKEND string_list:hostPorts
    {:
        RESULT = new DropBackendClause(hostPorts, true);
    :}
    | KW_DECOMMISSION KW_BACKEND string_list:hostPorts
    {:
        RESULT = new DecommissionBackendClause(hostPorts);
    :}
    | KW_ADD KW_OBSERVER STRING_LITERAL:hostPort
    {:
        RESULT = new AddObserverClause(hostPort);
    :}
    | KW_DROP KW_OBSERVER STRING_LITERAL:hostPort
    {:
        RESULT = new DropObserverClause(hostPort);
    :}
    | KW_ADD KW_FOLLOWER STRING_LITERAL:hostPort
    {:
        RESULT = new AddFollowerClause(hostPort);
    :}
    | KW_DROP KW_FOLLOWER STRING_LITERAL:hostPort
    {:
        RESULT = new DropFollowerClause(hostPort);
    :}
    /* Broker manipulation */
    | KW_ADD KW_BROKER ident_or_text:brokerName string_list:hostPorts
    {:
        RESULT = ModifyBrokerClause.createAddBrokerClause(brokerName, hostPorts);
    :}
    | KW_DROP KW_BROKER ident_or_text:brokerName string_list:hostPorts
    {:
        RESULT = ModifyBrokerClause.createDropBrokerClause(brokerName, hostPorts);
    :}
    | KW_DROP KW_ALL KW_BROKER ident_or_text:brokerName
    {:
        RESULT = ModifyBrokerClause.createDropAllBrokerClause(brokerName);
    :}
    // set load errors hub
    | KW_SET KW_LOAD KW_ERRORS KW_HUB opt_properties:properties
    {:
        RESULT = new AlterLoadErrorUrlClause(properties);
    :}
	| KW_MODIFY KW_BACKEND string_list:hostPorts KW_SET LPAREN key_value_map:properties RPAREN
	{:
		RESULT = new ModifyBackendClause(hostPorts, properties);
	:}
    ;

// Sync Stmt
sync_stmt ::=
    KW_SYNC
    {:
        RESULT = new SyncStmt();
    :}
    ;

opt_intermediate_type ::=
    {:
        RESULT = null;
    :}
    | KW_INTERMEDIATE type_def:intermediateType
    {:
        RESULT = intermediateType;
    :}
    ;

build_mv ::=
    KW_BUILD KW_IMMEDIATE
    {:
        RESULT = MVRefreshInfo.BuildMode.IMMEDIATE;
    :}
    | KW_BUILD KW_DEFERRED
    {:
        RESULT = MVRefreshInfo.BuildMode.DEFERRED;
    :}
    ;

opt_refresh_method ::=
    {:
        RESULT = null;
    :}
    | KW_FAST
    {:
        RESULT = MVRefreshInfo.RefreshMethod.FAST;
    :}
    | KW_COMPLETE
    {:
        RESULT = MVRefreshInfo.RefreshMethod.COMPLETE;
    :}
    | KW_FORCE
    {:
        RESULT = MVRefreshInfo.RefreshMethod.FORCE;
    :}
    ;

opt_refresh_trigger ::=
    {:
        RESULT = new MVRefreshTriggerInfo(MVRefreshInfo.RefreshTrigger.DEMAND);
    :}
    | KW_ON KW_DEMAND
    {:
        RESULT = new MVRefreshTriggerInfo(MVRefreshInfo.RefreshTrigger.DEMAND);
    :}
    | KW_ON KW_COMMIT
    {:
        RESULT = new MVRefreshTriggerInfo(MVRefreshInfo.RefreshTrigger.COMMIT);
    :}
    | KW_START KW_WITH ident:start_time
    {:
        RESULT = new MVRefreshTriggerInfo(new MVRefreshIntervalTriggerInfo(start_time, -1, null));
    :}
    | KW_START KW_WITH STRING_LITERAL:start_time KW_NEXT INTEGER_LITERAL:interval time_unit:unit
    {:
        RESULT = new MVRefreshTriggerInfo(new MVRefreshIntervalTriggerInfo(start_time, interval, unit));
    :}
    | KW_NEXT INTEGER_LITERAL:interval time_unit:unit
    {:
        RESULT = new MVRefreshTriggerInfo(new MVRefreshIntervalTriggerInfo(null, interval, unit));
    :}
    ;

opt_mv_refersh_info ::=
    {:
        RESULT = null;
    :}
    | KW_REFRESH opt_refresh_method:refreshMethod opt_refresh_trigger:refreshTrigger
    {:
        RESULT = new MVRefreshInfo(refreshMethod, refreshTrigger);
    :}
    | KW_NEVER KW_REFRESH
    {:
        RESULT = new MVRefreshInfo(false);
    :}
    ;

opt_mv_keys ::=
    {:
        RESULT = null;
    :}
    | KW_KEY LPAREN ident_list:keys RPAREN
    {:
        RESULT = new KeysDesc(KeysType.DUP_KEYS, keys);
    :}
    ;

opt_mv_partition ::=
    /* Empty: no partition */
    {:
        RESULT = null;
    :}
    /* Column partition */
    | KW_PARTITION KW_BY LPAREN column_ref_list:columns RPAREN
    {:
        RESULT = new ColumnPartitionDesc(columns);
    :}
    ;

// Create Statement
create_stmt ::=
    /* Database */
    KW_CREATE KW_DATABASE opt_if_not_exists:ifNotExists ident:db opt_properties:properties
    {:
        RESULT = new CreateDbStmt(ifNotExists, db, properties);
    :}
    | KW_CREATE KW_SCHEMA opt_if_not_exists:ifNotExists ident:db
    {:
        RESULT = new CreateDbStmt(ifNotExists, db, null);
    :}
    /* Catalog */
    | KW_CREATE KW_CATALOG opt_if_not_exists:ifNotExists ident:catalogName opt_properties:properties
    {:
         RESULT = new CreateCatalogStmt(ifNotExists, catalogName, properties);
    :}
    /* cluster */
   /* KW_CREATE KW_CLUSTER ident:name  opt_properties:properties KW_IDENTIFIED KW_BY STRING_LITERAL:password
    {:
        RESULT = new CreateClusterStmt(name, properties, password);
    :}*/
    /* Function */
    | KW_CREATE opt_aggregate:isAggregate KW_FUNCTION opt_if_not_exists:ifNotExists function_name:functionName LPAREN func_args_def:args RPAREN
            KW_RETURNS type_def:returnType opt_intermediate_type:intermediateType opt_properties:properties
    {:
        RESULT = new CreateFunctionStmt(ifNotExists, isAggregate, functionName, args, returnType, intermediateType, properties);
    :}
    | KW_CREATE KW_ALIAS KW_FUNCTION opt_if_not_exists:ifNotExists function_name:functionName LPAREN func_args_def:args RPAREN
            KW_WITH KW_PARAMETER LPAREN ident_list:parameters RPAREN KW_AS expr:func
    {:
        RESULT = new CreateFunctionStmt(ifNotExists, functionName, args, parameters, func);
    :}
    /* Table */
    | KW_CREATE opt_external:isExternal KW_TABLE opt_if_not_exists:ifNotExists table_name:name KW_LIKE table_name:existed_name KW_WITH KW_ROLLUP LPAREN ident_list:rollupNames RPAREN
    {:
        RESULT = new CreateTableLikeStmt(ifNotExists, name, existed_name, rollupNames, false);
    :}
    | KW_CREATE opt_external:isExternal KW_TABLE opt_if_not_exists:ifNotExists table_name:name KW_LIKE table_name:existed_name KW_WITH KW_ROLLUP
    {:
        RESULT = new CreateTableLikeStmt(ifNotExists, name, existed_name, null, true);
    :}
    | KW_CREATE opt_external:isExternal KW_TABLE opt_if_not_exists:ifNotExists table_name:name KW_LIKE table_name:existed_name
    {:
        RESULT = new CreateTableLikeStmt(ifNotExists, name, existed_name, null, false);
    :}
    | KW_CREATE opt_external:isExternal KW_TABLE opt_if_not_exists:ifNotExists table_name:name
            LPAREN column_definition_list:columns RPAREN opt_engine:engineName
            opt_keys:keys
            opt_comment:tableComment
            opt_partition:partition
            opt_distribution:distribution
            opt_rollup:index
            opt_properties:tblProperties
            opt_ext_properties:extProperties
    {:
        RESULT = new CreateTableStmt(ifNotExists, isExternal, name, columns, engineName, keys, partition,
        distribution, tblProperties, extProperties, tableComment, index);
    :}
    | KW_CREATE opt_external:isExternal KW_TABLE opt_if_not_exists:ifNotExists table_name:name
            LPAREN column_definition_list:columns COMMA index_definition_list:indexes RPAREN opt_engine:engineName
            opt_keys:keys
            opt_comment:tableComment
            opt_partition:partition
            opt_distribution:distribution
            opt_rollup:index
            opt_properties:tblProperties
            opt_ext_properties:extProperties
    {:
        RESULT = new CreateTableStmt(ifNotExists, isExternal, name, columns, indexes, engineName, keys, partition,
        distribution, tblProperties, extProperties, tableComment, index);
    :}
    | KW_CREATE opt_external:isExternal KW_TABLE opt_if_not_exists:ifNotExists table_name:name KW_ENGINE EQUAL ident:engineName
          properties:properties opt_comment:tableComment
    {:
       RESULT = new CreateTableStmt(ifNotExists, isExternal, name, engineName, properties, tableComment);
    :}
    | KW_CREATE opt_external:isExternal KW_TABLE opt_if_not_exists:ifNotExists table_name:name
            opt_col_list:columns
            opt_engine:engineName
            opt_keys:keys
            opt_comment:tableComment
            opt_partition:partition
            opt_distribution:distribution
            opt_rollup:index
            opt_properties:tblProperties
            opt_ext_properties:extProperties
            KW_AS query_stmt:query_def
    {:
        RESULT = new CreateTableAsSelectStmt(new CreateTableStmt(ifNotExists, isExternal, name, null, engineName, keys, partition,
        distribution, tblProperties, extProperties, tableComment, index), columns, query_def);
    :}
    /* User */
    | KW_CREATE KW_USER
      opt_if_not_exists:ifNotExists
      grant_user:user
      opt_user_role:userRole
      opt_password_option:passwdOptions
    {:
        RESULT = new CreateUserStmt(ifNotExists, user, userRole, passwdOptions);
    :}
    | KW_CREATE KW_VIEW opt_if_not_exists:ifNotExists table_name:viewName
        opt_col_with_comment_list:columns opt_comment:comment KW_AS query_stmt:view_def
    {:
        RESULT = new CreateViewStmt(ifNotExists, viewName, columns, comment, view_def);
    :}
    /* cluster */
    | KW_CREATE KW_CLUSTER ident:name opt_properties:properties KW_IDENTIFIED KW_BY STRING_LITERAL:password
    {:
        RESULT = new CreateClusterStmt(name, properties, password);
    :}
    | KW_CREATE opt_read_only:isReadOnly KW_REPOSITORY ident:repoName KW_WITH storage_backend:storage
    {:
        RESULT = new CreateRepositoryStmt(isReadOnly, repoName, storage);
    :}
    | KW_CREATE KW_ROLE opt_if_not_exists:ifNotExists ident:role
    {:
        RESULT = new CreateRoleStmt(ifNotExists, role);
    :}
    | KW_CREATE KW_FILE STRING_LITERAL:fileName opt_db:db KW_PROPERTIES LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new CreateFileStmt(fileName, db, properties);
    :}
    | KW_CREATE KW_MATERIALIZED KW_VIEW ident:mvName KW_AS select_stmt:selectStmt opt_properties:properties
    {:
        RESULT = new CreateMaterializedViewStmt(mvName, selectStmt, properties);
    :}
    | KW_CREATE KW_MATERIALIZED KW_VIEW ident:mvName build_mv:buildMethod
         opt_mv_refersh_info:refreshInfo
         opt_mv_keys:keyDesc
         opt_mv_partition:partitionDesc
         opt_distribution:distributionDesc
         opt_properties:properties
         KW_AS query_stmt:query
    {:
        RESULT = new CreateMultiTableMaterializedViewStmt(mvName, buildMethod, refreshInfo, keyDesc, partitionDesc, distributionDesc, properties, query);
    :}
    | KW_CREATE KW_INDEX opt_if_not_exists:ifNotExists ident:indexName KW_ON table_name:tableName LPAREN ident_list:cols RPAREN opt_index_type:indexType opt_properties:properties opt_comment:comment
    {:
        RESULT = new AlterTableStmt(tableName, Lists.newArrayList(new CreateIndexClause(tableName, new IndexDef(indexName, ifNotExists, cols, indexType, properties, comment), false)));
    :}
    /* resource */
    | KW_CREATE opt_external:isExternal KW_RESOURCE opt_if_not_exists:ifNotExists ident_or_text:resourceName opt_properties:properties
    {:
        RESULT = new CreateResourceStmt(isExternal, ifNotExists, resourceName, properties);
    :}
    /* encryptkey */
    | KW_CREATE KW_ENCRYPTKEY opt_if_not_exists:ifNotExists encryptkey_name:keyName KW_AS STRING_LITERAL:keyString
    {:
        RESULT = new CreateEncryptKeyStmt(ifNotExists, keyName, keyString);
    :}
    /* sync job */
    | KW_CREATE KW_SYNC ident:db DOT ident_or_text:jobName LPAREN channel_desc_list:channelDescList RPAREN binlog_desc:binlog opt_properties:properties
    {:
        RESULT = new CreateDataSyncJobStmt(jobName, db, channelDescList, binlog, properties);
    :}
    /* sql_block_rule */
    | KW_CREATE KW_SQL_BLOCK_RULE opt_if_not_exists:ifNotExists ident:ruleName opt_properties:properties
    {:
        RESULT = new CreateSqlBlockRuleStmt(ifNotExists, ruleName, properties);
    :}
    /* row policy */
    | KW_CREATE KW_ROW KW_POLICY opt_if_not_exists:ifNotExists ident:policyName KW_ON table_name:tbl KW_AS ident:filterType KW_TO user_identity:user
    KW_USING LPAREN expr:wherePredicate RPAREN
    {:
        RESULT = new CreatePolicyStmt(PolicyTypeEnum.ROW, ifNotExists, policyName, tbl, filterType, user, wherePredicate);
    :}
    /* storage policy */
    | KW_CREATE KW_STORAGE KW_POLICY opt_if_not_exists:ifNotExists ident:policyName opt_properties:properties
    {:
        RESULT = new CreatePolicyStmt(PolicyTypeEnum.STORAGE, ifNotExists, policyName, properties);
    :}
    ;

channel_desc_list ::=
    channel_desc:desc
    {:
        RESULT = Lists.newArrayList(desc);
    :}
    | channel_desc_list:list COMMA channel_desc:desc
    {:
        list.add(desc);
        RESULT = list;
    :}
    ;

channel_desc ::=
    KW_FROM ident:srcDatabase DOT ident:srcTableName KW_INTO ident:desTableName opt_partition_names:partitionNames opt_col_list:colList
    {:
        RESULT = new ChannelDescription(srcDatabase, srcTableName, desTableName, partitionNames, colList);
    :}
    ;

binlog_desc ::=
    KW_FROM KW_BINLOG LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new BinlogDesc(properties);
    :}
;

resume_sync_job_stmt ::=
    KW_RESUME KW_SYNC KW_JOB job_name:jobName
    {:
        RESULT = new ResumeSyncJobStmt(jobName);
    :}
    ;

pause_sync_job_stmt ::=
    KW_PAUSE KW_SYNC KW_JOB job_name:jobName
    {:
        RESULT = new PauseSyncJobStmt(jobName);
    :}
    ;

stop_sync_job_stmt ::=
    KW_STOP KW_SYNC KW_JOB job_name:jobName
    {:
        RESULT = new StopSyncJobStmt(jobName);
    :}
    ;

job_name ::=
    ident:jobName
    {:
        RESULT = new JobName("", jobName);
    :}
    | ident:db DOT ident:jobName
    {:
        RESULT = new JobName(db, jobName);
    :}
    ;

opt_aggregate ::=
    {:
        RESULT = false;
    :}
    | KW_AGGREGATE
    {:
        RESULT = true;
    :}
    ;

storage_backend ::=
    | KW_BROKER ident:brokerName KW_ON KW_LOCATION STRING_LITERAL:location opt_properties:properties
    {:
        RESULT = new StorageBackend(brokerName, location, StorageBackend.StorageType.BROKER, properties);
    :}
    | KW_S3 KW_ON KW_LOCATION STRING_LITERAL:location opt_properties:properties
    {:
        RESULT = new StorageBackend("", location, StorageBackend.StorageType.S3, properties);
    :}
    | KW_HDFS KW_ON KW_LOCATION STRING_LITERAL:location opt_properties:properties
    {:
        RESULT = new StorageBackend("", location, StorageBackend.StorageType.HDFS, properties);
    :}
    | KW_LOCAL KW_ON KW_LOCATION STRING_LITERAL:location opt_properties:properties
    {:
        RESULT = new StorageBackend("", location, StorageBackend.StorageType.LOCAL, properties);
    :}
    ;

opt_read_only ::=
    {:
        RESULT = false;
    :}
    | KW_READ KW_ONLY
    {:
        RESULT = true;
    :}
    ;

grant_user ::=
    user_identity:user_id
    {:
        /* No password */
        RESULT = new UserDesc(user_id);
    :}
    | user_identity:user_id KW_IDENTIFIED KW_BY STRING_LITERAL:password
    {:
        /* plain text password */
        RESULT = new UserDesc(user_id, new PassVar(password, true));
    :}
    | user_identity:user_id KW_IDENTIFIED KW_BY KW_PASSWORD STRING_LITERAL:password
    {:
        /* hashed password */
        RESULT = new UserDesc(user_id, new PassVar(password, false));
    :}
    ;

opt_user_role ::=
    /* Empty */
    {:
        RESULT = null;
    :}
    | KW_SUPERUSER /* for forward compatibility*/
    {:
        RESULT = "superuser";
    :}
    | KW_DEFAULT KW_ROLE STRING_LITERAL:role
    {:
        RESULT = role;
    :}
    ;

opt_password_option ::=
    opt_passwd_history_policy:historyPolicy
    opt_passwd_expire_policy:expirePolicy
    opt_passwd_reuse_policy:reusePolicy
    opt_failed_login_attempts:loginAttempts
    opt_password_lock_time:passwdLockTime
    opt_lock_account:lockAccount
    {:
        RESULT = new PasswordOptions(expirePolicy, historyPolicy, reusePolicy, loginAttempts, passwdLockTime, lockAccount);
    :}
    ;

opt_passwd_expire_policy ::=
    {:
        RESULT = (long) PasswordOptions.UNSET;
    :}
    | KW_PASSWORD_EXPIRE passwd_expire_opt:opt
    {:
        RESULT = opt;
    :}
    ;

opt_passwd_history_policy ::=
    {:
        RESULT = PasswordOptions.UNSET;
    :}
    | KW_PASSWORD_HISTORY passwd_history_opt:opt
    {:
        RESULT = opt;
    :}
    ;

opt_passwd_reuse_policy ::=
    {:
        RESULT = PasswordOptions.UNSET;
    :}
    | KW_PASSWORD_REUSE KW_INTERVAL passwd_reuse_opt:opt
    {:
        RESULT = opt;
    :}
    ;

opt_lock_account ::=
    {:
        RESULT = PasswordOptions.UNSET;
    :}
    | KW_ACCOUNT_LOCK
    {:
        RESULT = -1;
    :}
    | KW_ACCOUNT_UNLOCK
    {:
        RESULT = 1;
    :}
    ;

passwd_expire_opt ::=
    KW_DEFAULT
    {:
        RESULT = -1L;
    :}
    | KW_NEVER
    {:
        RESULT = 0L;
    :}
    | KW_INTERVAL INTEGER_LITERAL:n passwd_time_unit:unit
    {:
        RESULT = n * unit;
    :}
    ;

passwd_time_unit ::=
    KW_DAY
    {:
        RESULT = 86400;
    :}
    | KW_HOUR
    {:
        RESULT = 3600;
    :}
    | KW_SECOND
    {:
        RESULT = 1;
    :}
    ;

passwd_history_opt ::=
    KW_DEFAULT
    {:
        RESULT = -1;
    :}
    | INTEGER_LITERAL:n
    {:
        RESULT = n.intValue();
    :}
    ;

passwd_reuse_opt ::=
    KW_DEFAULT
    {:
        RESULT = -1;
    :}
    | INTEGER_LITERAL:n KW_DAY
    {:
        RESULT = n.intValue();
    :}
    ;

opt_failed_login_attempts ::=
    {:
        RESULT = PasswordOptions.UNSET;
    :}
    | KW_FAILED_LOGIN_ATTEMPTS INTEGER_LITERAL:n
    {:
        RESULT = n.intValue();
    :}
    ;

opt_password_lock_time ::=
    {:
        RESULT = (long) PasswordOptions.UNSET;
    :}
    | KW_PASSWORD_LOCK_TIME passwd_lock_time_opt:opt
    {:
        RESULT = opt;
    :} 
    ;

passwd_lock_time_opt ::=
    INTEGER_LITERAL:n passwd_time_unit:unit
    {:
        RESULT = n * unit;
    :}
    | KW_UNBOUNDED
    {:
        RESULT = -1L;
    :}
    ;

user ::=
    ident_or_text:user
    {:
        RESULT = user;
    :}
    ;

user_identity ::=
    ident_or_text:user
    {:
        RESULT = new UserIdentity(user, "%", false);
    :}
    | ident_or_text:user AT ident_or_text:host
    {:
        RESULT = new UserIdentity(user, host, false);
    :}
    | ident_or_text:user AT LBRACKET ident_or_text:host RBRACKET
    {:
        RESULT = new UserIdentity(user, host, true);
    :}
    ;

// Help statement
help_stmt ::=
    KW_HELP ident_or_text:mark
    {:
        RESULT = new HelpStmt(mark);
    :}
    ;

// Export statement
export_stmt ::=
    KW_EXPORT KW_TABLE base_table_ref:tblRef
    where_clause:whereExpr
    KW_TO STRING_LITERAL:path
    opt_properties:properties
    opt_broker:broker
    {:
        RESULT = new ExportStmt(tblRef, whereExpr, path, properties, broker);
    :}
    ;

// Load
load_stmt ::=
    KW_LOAD KW_LABEL job_label:label
    LPAREN data_desc_list:dataDescList RPAREN
    opt_broker:broker
    opt_system:system
    opt_properties:properties
    {:
        RESULT = new LoadStmt(label, dataDescList, broker, system, properties);
    :}
    | KW_LOAD KW_LABEL job_label:label
    LPAREN data_desc_list:dataDescList RPAREN
    resource_desc:resource
    opt_properties:properties
    {:
        RESULT = new LoadStmt(label, dataDescList, resource, properties);
    :}
    ;

job_label ::=
    ident:label
    {:
        RESULT = new LabelName("", label);
    :}
    | ident:db DOT ident:label
    {:
        RESULT = new LabelName(db, label);
    :}
    ;

data_desc_list ::=
    data_desc:desc
    {:
        RESULT = Lists.newArrayList(desc);
    :}
    | data_desc_list:list COMMA data_desc:desc
    {:
        list.add(desc);
        RESULT = list;
    :}
    ;

opt_merge_type ::=
    {:
        RESULT = LoadTask.MergeType.APPEND;
    :}
    | KW_APPEND
    {:
        RESULT = LoadTask.MergeType.APPEND;
    :}
    | KW_DELETE
    {:
        RESULT = LoadTask.MergeType.DELETE;
    :}
    | KW_MERGE
    {:
        RESULT = LoadTask.MergeType.MERGE;
    :}
    | KW_WITH KW_APPEND
    {:
        RESULT = LoadTask.MergeType.APPEND;
    :}
    | KW_WITH KW_DELETE
    {:
        RESULT = LoadTask.MergeType.DELETE;
    :}
    | KW_WITH KW_MERGE
    {:
        RESULT = LoadTask.MergeType.MERGE;
    :}
    ;

opt_with_merge_type ::=
    {:
        RESULT = LoadTask.MergeType.APPEND;
    :}
    | KW_WITH KW_APPEND
    {:
        RESULT = LoadTask.MergeType.APPEND;
    :}
    | KW_WITH KW_DELETE
    {:
        RESULT = LoadTask.MergeType.DELETE;
    :}
    | KW_WITH KW_MERGE
    {:
        RESULT = LoadTask.MergeType.MERGE;
    :}
    ;

data_desc ::=
    opt_merge_type:mergeType
    KW_DATA KW_INFILE LPAREN string_list:files RPAREN
    opt_negative:isNeg
    KW_INTO KW_TABLE ident:tableName
    opt_partition_names:partitionNames
    opt_field_term:colSep
    opt_file_format:fileFormat
    opt_col_list:colList
    opt_columns_from_path:columnsFromPath
    opt_col_mapping_list:colMappingList
    pre_filter_clause:preFilterExpr
    where_clause:whereExpr
    delete_on_clause:deleteExpr
    sequence_col_clause:sequenceColName
    opt_properties:properties
    {:
        RESULT = new DataDescription(tableName, partitionNames, files, colList, colSep, fileFormat,
        columnsFromPath, isNeg, colMappingList, preFilterExpr, whereExpr, mergeType, deleteExpr, sequenceColName, properties);
    :}
    | opt_merge_type:mergeType KW_DATA KW_FROM KW_TABLE ident:srcTableName
    opt_negative:isNeg
    KW_INTO KW_TABLE ident:tableName
    opt_partition_names:partitionNames
    opt_col_mapping_list:colMappingList
    where_clause:whereExpr
    delete_on_clause:deleteExpr
    opt_properties:properties
    {:
        RESULT = new DataDescription(tableName, partitionNames, srcTableName, isNeg, colMappingList, whereExpr,
        mergeType, deleteExpr, properties);
    :}
    ;

opt_negative ::=
    {:
        RESULT = false;
    :}
    | KW_NEGATIVE
    {:
        RESULT = true;
    :}
    ;

opt_field_term ::=
    /* Empty */
    {:
        RESULT = null;
    :}
    | KW_COLUMNS KW_TERMINATED KW_BY STRING_LITERAL:sep
    {:
        RESULT = new Separator(sep);
    :}
    ;

separator ::=
    KW_COLUMNS KW_TERMINATED KW_BY STRING_LITERAL:sep
    {:
        RESULT = new Separator(sep);
    :}
    ;

opt_file_format ::=
    /* Empty */
    {: RESULT = null; :}
    | KW_FORMAT KW_AS ident_or_text:format
    {: RESULT = format; :}
    ;

opt_columns_from_path ::=
    /* Empty */
    {: RESULT = null; :}
    | KW_COLUMNS KW_FROM KW_PATH KW_AS LPAREN ident_list:columnsFromPath RPAREN
    {: RESULT = columnsFromPath; :}
    ;

opt_col_list ::=
    {:
        RESULT = null;
    :}
    | LPAREN ident_list:colList RPAREN
    {:
        RESULT = colList;
    :}
    ;

opt_col_with_comment_list ::=
    {:
        RESULT = null;
    :}
    | LPAREN col_with_comment_list:colList RPAREN
    {:
        RESULT = colList;
    :}
    ;

col_with_comment_list ::=
    col_with_comment:col
    {:
        ArrayList<ColWithComment> list = new ArrayList<ColWithComment>();
        list.add(col);
        RESULT = list;
    :}
    | col_with_comment_list:list COMMA col_with_comment:col
    {:
        list.add(col);
        RESULT = list;
    :}
    ;

col_with_comment ::=
    ident:col opt_comment:comment
    {:
        RESULT = new ColWithComment(col, comment);
    :}
    ;

opt_col_mapping_list ::=
    /* Empty */
    {:
        RESULT = null;
    :}
    | KW_SET LPAREN expr_list:list RPAREN
    {:
        RESULT = list;
    :}
    ;

opt_system ::=
    {:
        RESULT = null;
    :}
    | KW_BY ident_or_text:system
    {:
        RESULT = system;
    :}
    ;

opt_broker ::=
    {:
        RESULT = null;
    :}
    | KW_WITH KW_S3 LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new BrokerDesc("S3", StorageBackend.StorageType.S3, properties);
    :}
    | KW_WITH KW_HDFS LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new BrokerDesc("HDFS", StorageBackend.StorageType.HDFS, properties);
    :}
    | KW_WITH KW_LOCAL LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new BrokerDesc("LOCAL", StorageBackend.StorageType.LOCAL, properties);
    :}
    | KW_WITH KW_BROKER ident_or_text:name
    {:
        RESULT = new BrokerDesc(name, null);
    :}
    | KW_WITH KW_BROKER ident_or_text:name LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new BrokerDesc(name, properties);
    :}
    ;

resource_desc ::=                                                               
    KW_WITH KW_RESOURCE ident_or_text:resourceName                                 
    {:                                                                               
        RESULT = new ResourceDesc(resourceName, null);                               
    :}                                                                               
    | KW_WITH KW_RESOURCE ident_or_text:resourceName LPAREN key_value_map:properties RPAREN
    {:                                                                               
        RESULT = new ResourceDesc(resourceName, properties);                         
    :}                                                                               
    ; 

// Routine load statement
create_routine_load_stmt ::=
    KW_CREATE KW_ROUTINE KW_LOAD job_label:jobLabel KW_ON ident:tableName
    opt_with_merge_type:mergeType
    opt_load_property_list:loadPropertyList
    opt_properties:properties
    KW_FROM ident:type LPAREN key_value_map:customProperties RPAREN
    {:
        RESULT = new CreateRoutineLoadStmt(jobLabel, tableName, loadPropertyList,
         properties, type, customProperties, mergeType);
    :}
    ;

opt_load_property_list ::=
    {:
        RESULT = null;
    :}
    | load_property:loadProperty
    {:
        RESULT = Lists.newArrayList(loadProperty);
    :}
    | opt_load_property_list:list COMMA load_property:loadProperty
    {:
        list.add(loadProperty);
        RESULT = list;
    :}
    ;

load_property ::=
    separator:colSep
    {:
        RESULT = colSep;
    :}
    | import_columns_stmt:columnsInfo
    {:
        RESULT = columnsInfo;
    :}
    | import_preceding_filter_stmt:preFilter
    {:
        RESULT = preFilter;
    :}
    | import_where_stmt:wherePredicate
    {:
        RESULT = wherePredicate;
    :}
    | import_delete_on_stmt:deletePredicate
    {:
        RESULT = deletePredicate;
    :}
    | import_sequence_stmt:sequenceColumn
    {:
        RESULT = sequenceColumn;
    :}
    | partition_names:partitionNames
    {:
        RESULT = partitionNames;
    :}
    ;

pause_routine_load_stmt ::=
    KW_PAUSE KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
    {:
        RESULT = new PauseRoutineLoadStmt(jobLabel);
    :}
    | KW_PAUSE KW_ALL KW_ROUTINE KW_LOAD
    {:
        RESULT = new PauseRoutineLoadStmt(null);
    :}
    ;

resume_routine_load_stmt ::=
    KW_RESUME KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
    {:
        RESULT = new ResumeRoutineLoadStmt(jobLabel);
    :}
    | KW_RESUME KW_ALL KW_ROUTINE KW_LOAD
    {:
        RESULT = new ResumeRoutineLoadStmt(null);
    :}
    ;

stop_routine_load_stmt ::=
    KW_STOP KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
    {:
        RESULT = new StopRoutineLoadStmt(jobLabel);
    :}
    ;

show_routine_load_stmt ::=
    KW_SHOW KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
    {:
        RESULT = new ShowRoutineLoadStmt(jobLabel, false, null);
    :}
    | KW_SHOW KW_ALL KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
    {:
        RESULT = new ShowRoutineLoadStmt(jobLabel, true, null);
    :}
    | KW_SHOW KW_ROUTINE KW_LOAD opt_wild_where
    {:
        RESULT = new ShowRoutineLoadStmt(null, false, parser.wild);
    :}
    | KW_SHOW KW_ALL KW_ROUTINE KW_LOAD opt_wild_where
    {:
        RESULT = new ShowRoutineLoadStmt(null, true, parser.wild);
    :}
    ;

show_routine_load_task_stmt ::=
    KW_SHOW KW_ROUTINE KW_LOAD KW_TASK opt_db:dbName opt_wild_where
    {:
        RESULT = new ShowRoutineLoadTaskStmt(dbName, parser.where);
    :}
    ;

show_mtmv_stmt ::=
    KW_SHOW KW_MTMV KW_JOB
    {:
        RESULT = new ShowMTMVJobStmt();
    :}
    | KW_SHOW KW_MTMV KW_JOB KW_FOR ident:jobName
    {:
        RESULT = new ShowMTMVJobStmt(jobName);
    :}
    | KW_SHOW KW_MTMV KW_JOB KW_FROM ident:dbName
    {:
        RESULT = new ShowMTMVJobStmt(dbName, null);
    :}
    | KW_SHOW KW_MTMV KW_JOB KW_ON table_name:tbl
    {:
        RESULT = new ShowMTMVJobStmt(null, tbl);
    :}
    | KW_SHOW KW_MTMV KW_JOB KW_FROM ident:dbName KW_ON table_name:tbl
    {:
        RESULT = new ShowMTMVJobStmt(dbName, tbl);
    :}
    | KW_SHOW KW_MTMV KW_TASK
    {:
        RESULT = new ShowMTMVTaskStmt();
    :}
    | KW_SHOW KW_MTMV KW_TASK KW_FOR ident:taskId
    {:
        RESULT = new ShowMTMVTaskStmt(taskId);
    :}
    | KW_SHOW KW_MTMV KW_TASK KW_FROM ident:dbName
    {:
        RESULT = new ShowMTMVTaskStmt(dbName, null);
    :}
    | KW_SHOW KW_MTMV KW_TASK KW_ON table_name:tbl
    {:
        RESULT = new ShowMTMVTaskStmt(null, tbl);
    :}
    | KW_SHOW KW_MTMV KW_TASK KW_FROM ident:dbName KW_ON table_name:tbl
    {:
        RESULT = new ShowMTMVTaskStmt(dbName, tbl);
    :}
    ;

show_create_routine_load_stmt ::=
    KW_SHOW KW_CREATE KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
    {:
        RESULT = new ShowCreateRoutineLoadStmt(jobLabel, false);
    :}
    | KW_SHOW KW_ALL KW_CREATE KW_ROUTINE KW_LOAD KW_FOR job_label:jobLabel
    {:
        RESULT = new ShowCreateRoutineLoadStmt(jobLabel, true);
    :}
    ;

// analyze statment
analyze_stmt ::=
    KW_ANALYZE table_name:tbl opt_col_list:cols opt_partition_names:partitionNames opt_properties:properties
    {:
        RESULT = new AnalyzeStmt(tbl, cols, partitionNames, properties);
    :}
    ;

// Grant statement
grant_stmt ::=
    KW_GRANT privilege_list:privs KW_ON tbl_pattern:tblPattern KW_TO user_identity:userId
    {:
        RESULT = new GrantStmt(userId, null, tblPattern, privs);
    :}
    | KW_GRANT privilege_list:privs KW_ON tbl_pattern:tblPattern KW_TO KW_ROLE STRING_LITERAL:role
    {:
        RESULT = new GrantStmt(null, role, tblPattern, privs);
    :}
    | KW_GRANT privilege_list:privs KW_ON KW_RESOURCE resource_pattern:resourcePattern KW_TO user_identity:userId
    {:
        RESULT = new GrantStmt(userId, null, resourcePattern, privs);
    :}
    | KW_GRANT privilege_list:privs KW_ON KW_RESOURCE resource_pattern:resourcePattern KW_TO KW_ROLE STRING_LITERAL:role
    {:
        RESULT = new GrantStmt(null, role, resourcePattern, privs);
    :}
    ;

tbl_pattern ::=
    ident_or_star:db
    {:
        RESULT = new TablePattern(db, "*");
    :}
    | ident_or_star:db DOT ident_or_star:tbl
    {:
        RESULT = new TablePattern(db, tbl);
    :}
    | ident_or_star:ctl DOT ident_or_star:db DOT ident_or_star:tbl
    {:
        RESULT = new TablePattern(ctl, db, tbl);
    :}
    ;

resource_pattern ::=
    ident_or_star:resourceName
    {:
        RESULT = new ResourcePattern(resourceName);
    :}
    | STRING_LITERAL:resourceName
    {:
        RESULT = new ResourcePattern(resourceName);
    :}
    ;

ident_or_star ::=
    STAR
    {:
        RESULT = "*";
    :}
    | ident:ident
    {:
        RESULT = ident;
    :}
    ;

// Revoke statement
revoke_stmt ::=
    KW_REVOKE privilege_list:privs KW_ON tbl_pattern:tblPattern KW_FROM user_identity:userId
    {:
        RESULT = new RevokeStmt(userId, null, tblPattern, privs);
    :}
    | KW_REVOKE privilege_list:privs KW_ON tbl_pattern:tblPattern KW_FROM KW_ROLE STRING_LITERAL:role
    {:
        RESULT = new RevokeStmt(null, role, tblPattern, privs);
    :}
    | KW_REVOKE privilege_list:privs KW_ON KW_RESOURCE resource_pattern:resourcePattern KW_FROM user_identity:userId
    {:
        RESULT = new RevokeStmt(userId, null, resourcePattern, privs);
    :}
    | KW_REVOKE privilege_list:privs KW_ON KW_RESOURCE resource_pattern:resourcePattern KW_FROM KW_ROLE STRING_LITERAL:role
    {:
        RESULT = new RevokeStmt(null, role, resourcePattern, privs);
    :}
    ;

// Drop statement
drop_stmt ::=
    /* Database */
    KW_DROP KW_DATABASE opt_if_exists:ifExists ident:db opt_force:force
    {:
        RESULT = new DropDbStmt(ifExists, db, force);
    :}
    | KW_DROP KW_SCHEMA opt_if_exists:ifExists ident:db opt_force:force
    {:
        RESULT = new DropDbStmt(ifExists, db, force);
    :}
    /* Catalog */
    | KW_DROP KW_CATALOG opt_if_exists:ifExists ident:catalogName
    {:
        RESULT = new DropCatalogStmt(ifExists, catalogName);
    :}
    /* cluster */
    | KW_DROP KW_CLUSTER opt_if_exists:ifExists ident:cluster
    {:
        RESULT = new DropClusterStmt(ifExists, cluster);
    :}
    /* Function */
    | KW_DROP KW_FUNCTION opt_if_exists:ifExists function_name:functionName LPAREN func_args_def:args RPAREN
    {:
        RESULT = new DropFunctionStmt(ifExists, functionName, args);
    :}
    /* Table */
    | KW_DROP KW_TABLE opt_if_exists:ifExists table_name:name opt_force:force
    {:
        RESULT = new DropTableStmt(ifExists, name, force);
    :}
    /* User */
    | KW_DROP KW_USER opt_if_exists:ifExists user_identity:userId
    {:
        RESULT = new DropUserStmt(ifExists, userId);
    :}
    /* View */
    | KW_DROP KW_VIEW opt_if_exists:ifExists table_name:name
    {:
        RESULT = new DropTableStmt(ifExists, name, true, false);
    :}
    | KW_DROP KW_REPOSITORY ident:repoName
    {:
        RESULT = new DropRepositoryStmt(repoName);
    :}
    | KW_DROP KW_ROLE opt_if_exists:ifExists ident:role
    {:
        RESULT = new DropRoleStmt(ifExists, role);
    :}
    | KW_DROP KW_FILE STRING_LITERAL:fileName opt_db:dbName KW_PROPERTIES LPAREN key_value_map:properties RPAREN
    {:
        RESULT = new DropFileStmt(fileName, dbName, properties);
    :}
    | KW_DROP KW_INDEX opt_if_exists:ifExists ident:indexName KW_ON table_name:tableName
    {:
        RESULT = new AlterTableStmt(tableName, Lists.newArrayList(new DropIndexClause(indexName, ifExists, tableName, false)));
    :}
    | KW_DROP KW_MATERIALIZED KW_VIEW opt_if_exists:ifExists table_name:mvName
    {:
        RESULT = new DropMaterializedViewStmt(ifExists, mvName);
    :}
    | KW_DROP KW_MATERIALIZED KW_VIEW opt_if_exists:ifExists ident:mvName KW_ON table_name:tableName
    {:
        RESULT = new DropMaterializedViewStmt(ifExists, mvName, tableName);
    :}
    | KW_DROP KW_RESOURCE opt_if_exists:ifExists ident_or_text:resourceName
    {:
        RESULT = new DropResourceStmt(ifExists, resourceName);
    :}
    | KW_DROP KW_ENCRYPTKEY opt_if_exists:ifExists encryptkey_name:keyName
    {:
        RESULT = new DropEncryptKeyStmt(ifExists, keyName);
    :}
    | KW_DROP KW_SQL_BLOCK_RULE opt_if_exists:ifExists ident_list:ruleNames
    {:
        RESULT = new DropSqlBlockRuleStmt(ifExists, ruleNames);
    :}
    | KW_DROP KW_ROW KW_POLICY opt_if_exists:ifExists ident:policyName KW_ON table_name:tbl
    {:
        RESULT = new DropPolicyStmt(PolicyTypeEnum.ROW, ifExists, policyName, tbl, null);
    :}
    | KW_DROP KW_ROW KW_POLICY opt_if_exists:ifExists ident:policyName KW_ON table_name:tbl KW_FOR user_identity:user
    {:
        RESULT = new DropPolicyStmt(PolicyTypeEnum.ROW, ifExists, policyName, tbl, user);
    :}
    | KW_DROP KW_STORAGE KW_POLICY opt_if_exists:ifExists ident:policyName
    {:
        RESULT = new DropPolicyStmt(PolicyTypeEnum.STORAGE, ifExists, policyName, null, null);
    :}
    /* statistics */
    | KW_DROP KW_STATS opt_table_name:tbl opt_partition_names:partitionNames
    {:
        RESULT = new DropTableStatsStmt(tbl, partitionNames);
    :}
    ;

// Recover statement
recover_stmt ::=
    KW_RECOVER KW_DATABASE ident:dbName opt_id:dbId opt_alias:alias
    {:
        RESULT = new RecoverDbStmt(dbName, dbId, alias);
    :}
    | KW_RECOVER KW_TABLE table_name:dbTblName opt_id:tableId opt_alias:alias
    {:
        RESULT = new RecoverTableStmt(dbTblName, tableId, alias);
    :}
    | KW_RECOVER KW_PARTITION ident:partitionName opt_id:partitionId opt_alias:alias KW_FROM table_name:dbTblName
    {:
        RESULT = new RecoverPartitionStmt(dbTblName, partitionName, partitionId, alias);
    :}
    ;

opt_agg_type ::=
    /* not set */
    {: RESULT = null; :}
    | KW_SUM
    {:
    RESULT = AggregateType.SUM;
    :}
    | KW_MAX
    {:
    RESULT = AggregateType.MAX;
    :}
    | KW_MIN
    {:
    RESULT = AggregateType.MIN;
    :}
    | KW_REPLACE
    {:
    RESULT = AggregateType.REPLACE;
    :}
    | KW_REPLACE_IF_NOT_NULL
    {:
    RESULT = AggregateType.REPLACE_IF_NOT_NULL;
    :}
    | KW_HLL_UNION
    {:
    RESULT = AggregateType.HLL_UNION;
    :}
    | KW_BITMAP_UNION
    {:
    RESULT = AggregateType.BITMAP_UNION;
    :}


    | KW_QUANTILE_UNION
    {:
    RESULT = AggregateType.QUANTILE_UNION;
    :}
    ;

opt_partition ::=
    /* Empty: no partition */
    {:
        RESULT = null;
    :}
    /* Range partition */
    | KW_PARTITION KW_BY KW_RANGE LPAREN ident_list:columns RPAREN
            LPAREN opt_all_partition_desc_list:list RPAREN
    {:
        RESULT = new RangePartitionDesc(columns, list);
    :}
    /* List partition */
    | KW_PARTITION KW_BY KW_LIST LPAREN ident_list:columns RPAREN
            LPAREN opt_all_partition_desc_list:list RPAREN
    {:
        RESULT = new ListPartitionDesc(columns, list);
    :}
    ;

opt_distribution ::=
    /* Empty: no distributed */
    {:
        RESULT = null;
    :}
    /* Hash distributed */
    | KW_DISTRIBUTED KW_BY KW_HASH LPAREN ident_list:columns RPAREN opt_distribution_number:numDistribution
    {:
        RESULT = new HashDistributionDesc(numDistribution, columns);
    :}
    /* Random distributed */
    | KW_DISTRIBUTED KW_BY KW_RANDOM opt_distribution_number:numDistribution
    {:
        RESULT = new RandomDistributionDesc(numDistribution);
    :}
    ;

opt_rollup ::=
    /* Empty: no rollup */
    {:
        RESULT = new ArrayList<>();
    :}
    | KW_ROLLUP LPAREN add_rollup_clause_list:list RPAREN
    {:
        RESULT = list;
    :}
    ;

opt_distribution_number ::=
    /* Empty */
    {:
        /* If distribution number is null, default distribution number is 10. */
        RESULT = 10;
    :}
    | KW_BUCKETS INTEGER_LITERAL:numDistribution
    {:
        RESULT = numDistribution.intValue();
    :}
    ;

opt_keys ::=
    /* Empty */
    {:
        RESULT = null;
    :}
    /* dup_keys */
    | KW_DUPLICATE KW_KEY LPAREN ident_list:keys RPAREN
    {:
        RESULT = new KeysDesc(KeysType.DUP_KEYS, keys);
    :}
    /* unique_keys */
    | KW_UNIQUE KW_KEY LPAREN ident_list:keys RPAREN
    {:
        RESULT = new KeysDesc(KeysType.UNIQUE_KEYS, keys);
    :}
    /* agg_keys */
    | KW_AGGREGATE KW_KEY LPAREN ident_list:keys RPAREN
    {:
        RESULT = new KeysDesc(KeysType.AGG_KEYS, keys);
    :}
    ;

opt_all_partition_desc_list ::=
    /* Empty */
    {:
        RESULT = null;
    :}
    | all_partition_desc_list:list
    {:
        RESULT = list;
    :}
    ;

all_partition_desc_list ::=
    all_partition_desc_list:list COMMA single_partition_desc:desc
    {:
        list.add(desc);
        RESULT = list;
    :}
    | single_partition_desc:desc
    {:
        RESULT = Lists.newArrayList(desc);
    :}
    | all_partition_desc_list:list COMMA multi_partition_desc:desc
    {:
        list.add(desc);
        RESULT = list;
    :}
    | multi_partition_desc:desc
    {:
        RESULT = Lists.newArrayList(desc);
    :}
    ;

single_partition_desc ::=
    KW_PARTITION opt_if_not_exists:ifNotExists ident:partName KW_VALUES KW_LESS KW_THAN partition_key_desc:desc
        opt_key_value_map:properties
    {:
        RESULT = new SinglePartitionDesc(ifNotExists, partName, desc, properties);
    :}
    | KW_PARTITION opt_if_not_exists:ifNotExists ident:partName KW_VALUES fixed_partition_key_desc:desc
        opt_key_value_map:properties
    {:
        RESULT = new SinglePartitionDesc(ifNotExists, partName, desc, properties);
    :}
    /* list partition */
    | KW_PARTITION opt_if_not_exists:ifNotExists ident:partName KW_VALUES KW_IN list_partition_key_desc:desc
        opt_key_value_map:properties
    {:
        RESULT = new SinglePartitionDesc(ifNotExists, partName, desc, properties);
    :}
    ;

multi_partition_desc ::=
    fixed_multi_partition_key_desc:desc
        opt_key_value_map:properties
    {:
        RESULT = new MultiPartitionDesc(desc, properties);
    :}
    ;

fixed_multi_partition_key_desc ::=
    // FROM (lower) TO (upper) INTERVAL time_interval time_type
    KW_FROM LPAREN partition_key_list:lower RPAREN KW_TO LPAREN partition_key_list:upper RPAREN KW_INTERVAL INTEGER_LITERAL:time_interval ident:time_unit
    {:
        RESULT = PartitionKeyDesc.createMultiFixed(lower, upper, time_interval, time_unit);
    :}
    ;

partition_key_desc ::=
    KW_MAX_VALUE
    {:
        RESULT = PartitionKeyDesc.createMaxKeyDesc();
    :}
    | LPAREN partition_key_list:keys RPAREN
    {:
        RESULT = PartitionKeyDesc.createLessThan(keys);
    :}
    ;

/* list partition PartitionKeyDesc */
list_partition_key_desc ::=
    LPAREN list_partition_values_list:keys RPAREN
    {:
        RESULT = PartitionKeyDesc.createIn(keys);
    :}
    ;

/* List<List<PartitionValue>> inValues */
list_partition_values_list ::=
    partition_value_list:item
    {:
        ArrayList<List<PartitionValue>> l = new ArrayList();
        l.add(item);
        RESULT = l;
    :}
    | list_partition_values_list:l COMMA partition_value_list:item
    {:
        l.add(item);
        RESULT = l;
    :}
    ;

/* List<PartitionValue> */
partition_value_list ::=
    /* single partition key */
    STRING_LITERAL:item
    {:
        RESULT = Lists.newArrayList(new PartitionValue(item));
    :}
    /* multi partition keys : (1, "beijing") */
    | LPAREN partition_key_item_list:l RPAREN
    {:
        RESULT = l;
    :}
    ;

/* List<PartitionValue> */
partition_key_item_list ::=
    STRING_LITERAL:item
    {:
        RESULT = Lists.newArrayList(new PartitionValue(item));
    :}
    | partition_key_item_list:l COMMA STRING_LITERAL:item
    {:
        l.add(new PartitionValue(item));
        RESULT = l;
    :}
    ;

partition_key_list ::=
    /* empty */
    {:
        List<PartitionValue> l = new ArrayList<PartitionValue>();
        RESULT = l;
    :}
    | partition_key_list:l COMMA STRING_LITERAL:item
    {:
        l.add(new PartitionValue(item));
        RESULT = l;
    :}
    | partition_key_list:l COMMA KW_MAX_VALUE
    {:
        l.add(PartitionValue.MAX_VALUE);
        RESULT = l;
    :}
    | STRING_LITERAL:item
    {:
        RESULT = Lists.newArrayList(new PartitionValue(item));
    :}
    | KW_MAX_VALUE
    {:
        RESULT = Lists.newArrayList(PartitionValue.MAX_VALUE);
    :}
    ;

fixed_partition_key_desc ::=
    /* format: [(lower), (upper))*/
    LBRACKET LPAREN partition_key_list:lower RPAREN COMMA LPAREN partition_key_list:upper RPAREN RPAREN
    {:
        RESULT = PartitionKeyDesc.createFixed(lower, upper);
    :}
    ;

opt_engine ::=
    {: RESULT = null; :}
    | KW_ENGINE EQUAL ident:engineName
    {: RESULT = engineName; :}
    ;

opt_key_value_map ::=
    {:
    RESULT = Maps.newHashMap();
    :}
    | LPAREN key_value_map:map RPAREN
    {:
    RESULT = map;
    :}
    ;

key_value_map ::=
    STRING_LITERAL:name EQUAL STRING_LITERAL:value
    {:
    RESULT = Maps.newHashMap();
    RESULT.put(name, value);
    :}
    | key_value_map:map COMMA STRING_LITERAL:name EQUAL STRING_LITERAL:value
    {:
    map.put(name, value);
    RESULT = map;
    :}
    ;

opt_properties ::=
    {:
    RESULT = null;
    :}
    | properties:properties
    {:
    RESULT = properties;
    :}
    ;

opt_ext_properties ::=
    {:
    RESULT = null;
    :}
    | KW_BROKER properties:properties
    {:
    RESULT = properties;
    :}
    ;

properties ::=
    KW_PROPERTIES LPAREN key_value_map:map RPAREN
    {:
    RESULT = map;
    :}
    ;

column_definition_list ::=
    column_definition:column
    {:
    RESULT = Lists.newArrayList();
    RESULT.add(column);
    :}
    | column_definition_list:list COMMA column_definition:column
    {:
    list.add(column);
    RESULT = list;
    :}
    ;

index_definition_list ::=
    index_definition:index
    {:
        RESULT = Lists.newArrayList();
        RESULT.add(index);
    :}
    | index_definition_list:list COMMA index_definition:index
    {:
        list.add(index);
        RESULT = list;
    :}
    ;

opt_default_value ::=
    /* Empty */
    {:
        RESULT = ColumnDef.DefaultValue.NOT_SET;
    :}
    | KW_DEFAULT STRING_LITERAL:value
    {:
        RESULT = new ColumnDef.DefaultValue(true, value);
    :}
    | KW_DEFAULT KW_NULL
    {:
        RESULT = ColumnDef.DefaultValue.NULL_DEFAULT_VALUE;
    :}
    | KW_DEFAULT KW_CURRENT_TIMESTAMP
    {:
        RESULT = ColumnDef.DefaultValue.CURRENT_TIMESTAMP_DEFAULT_VALUE;
    :}
    ;

opt_is_key ::=
    {:
        RESULT = false;
    :}
    | KW_KEY:key
    {:
        RESULT = true;
    :}
    ;

column_definition ::=
    ident:columnName type_def:typeDef opt_is_key:isKey opt_agg_type:aggType opt_is_allow_null:isAllowNull opt_default_value:defaultValue opt_comment:comment
    {:
        ColumnDef columnDef = new ColumnDef(columnName, typeDef, isKey, aggType, isAllowNull, defaultValue, comment);
        RESULT = columnDef;
    :}
    ;

index_definition ::=
    KW_INDEX opt_if_not_exists:ifNotExists ident:indexName LPAREN ident_list:cols RPAREN opt_index_type:indexType opt_properties:properties opt_comment:comment
    {:
        RESULT = new IndexDef(indexName, ifNotExists, cols, indexType, properties, comment);
    :}
    ;

opt_is_allow_null ::=
    {:
        RESULT = true;
    :}
    | KW_NULL
    {:
        RESULT = true;
    :}
    | KW_NOT KW_NULL
    {:
        RESULT = false;
    :}
    ;

opt_comment ::=
    /* empty */
    {:
        RESULT = "";
    :}
    | KW_COMMENT STRING_LITERAL:comment
    {:
        RESULT = comment;
    :}
    ;

opt_index_type ::=
    {:
        RESULT = null;
    :}
    | KW_USING KW_BITMAP
    {:
        RESULT = IndexDef.IndexType.BITMAP;
    :}
    | KW_USING KW_INVERTED
    {:
        RESULT = IndexDef.IndexType.INVERTED;
    :}
    ;

opt_if_exists ::=
    {:
        RESULT = false;
    :}
    | KW_IF KW_EXISTS
    {:
        RESULT = true;
    :}
    ;

opt_if_not_exists ::=
    {:
        RESULT = false;
    :}
    | KW_IF KW_NOT KW_EXISTS
    {:
        RESULT = true;
    :}
    ;

opt_external ::=
    /* empty */
    {:
        RESULT = false;
    :}
    | KW_EXTERNAL
    {:
        RESULT = true;
    :}
    ;

opt_force ::=
     /* empty */
    {:
        RESULT = false;
    :}
    | KW_FORCE
    {:
        RESULT = true;
    :}
    ;

// Show statement
show_stmt ::=
    KW_SHOW show_param:stmt
    {:
        RESULT = stmt;
    :}
    | KW_SHOW KW_SQL_BLOCK_RULE KW_FOR ident:ruleName
    {:
        RESULT = new ShowSqlBlockRuleStmt(ruleName);
    :}
    | KW_SHOW KW_SQL_BLOCK_RULE
    {:
        RESULT = new ShowSqlBlockRuleStmt(null);
    :}
    | KW_SHOW KW_ROW KW_POLICY KW_FOR user_identity:user
    {:
        RESULT = new ShowPolicyStmt(PolicyTypeEnum.ROW, user);
    :}
    | KW_SHOW KW_ROW KW_POLICY
    {:
        RESULT = new ShowPolicyStmt(PolicyTypeEnum.ROW, null);
    :}
    | KW_SHOW KW_STORAGE KW_POLICY
    {:
        RESULT = new ShowPolicyStmt(PolicyTypeEnum.STORAGE, null);
    :}
    ;

show_param ::=
    KW_WHITELIST
    {:
        RESULT = new ShowWhiteListStmt();
    :}
    /* show variables */
    | opt_var_type:type KW_VARIABLES opt_wild_where
    {:
        RESULT = new ShowVariablesStmt(type, parser.wild, parser.where);
    :}
    /* show open tables */
    | KW_OPEN KW_TABLES opt_db:db opt_wild_where
    {:
        RESULT = new ShowOpenTableStmt();
    :}
    /* show table status */
    | KW_TABLE KW_STATUS opt_db:db opt_wild_where
    {:
        RESULT = new ShowTableStatusStmt(db, parser.wild, parser.where);
    :}
    /* show table status */
    | opt_full KW_TABLES opt_db:db opt_wild_where
    {:
        RESULT = new ShowTableStmt(db, parser.isVerbose, parser.wild, parser.where);
    :}
    /* show table id */
    | KW_TABLE INTEGER_LITERAL:tableId
    {:
        RESULT = new ShowTableIdStmt(tableId);
    :}
    /* show processlist */
    | opt_full KW_PROCESSLIST
    {:
        RESULT = new ShowProcesslistStmt(parser.isVerbose);
    :}
    /* routine */
    | procedure_or_function KW_STATUS opt_wild_where
    {:
        RESULT = new ShowProcedureStmt();
    :}
    /* status */
    | opt_var_type KW_STATUS opt_wild_where
    {:
        RESULT = new ShowStatusStmt();
    :}
    /* triggers */
    | opt_full KW_TRIGGERS opt_db:db opt_wild_where
    {:
        RESULT = new ShowTriggersStmt();
    :}
    /* events */
    | KW_EVENTS opt_db:db opt_wild_where
    {:
        RESULT = new ShowEventsStmt();
    :}
    /* plugins */
    | KW_PLUGINS
    {:
        RESULT = new ShowPluginsStmt();
    :}
    /* engines */
    | opt_storage KW_ENGINES
    {:
        RESULT = new ShowEnginesStmt();
    :}
    /* Authors */
    | KW_AUTHORS
    {:
        RESULT = new ShowAuthorStmt();
    :}
    /* Create table */
    | KW_CREATE KW_TABLE table_name:table
    {:
        RESULT = new ShowCreateTableStmt(table);
    :}
    | KW_CREATE KW_VIEW table_name:table
    {:
        RESULT = new ShowCreateTableStmt(table, true);
    :}
    /* Create database */
    | KW_CREATE KW_DATABASE ident:db
    {:
        RESULT = new ShowCreateDbStmt(db);
    :}
    | KW_CREATE KW_SCHEMA ident:db
    {:
        RESULT = new ShowCreateDbStmt(db);
    :}
    | KW_CREATE KW_CATALOG ident:catalogName
        {:
            RESULT = new ShowCreateCatalogStmt(catalogName);
        :}
    /* Create Function */
    | KW_CREATE KW_FUNCTION function_name:functionName LPAREN func_args_def:args RPAREN opt_db:dbName
    {:
        RESULT = new ShowCreateFunctionStmt(dbName, functionName, args);
    :}
    /* Cluster */
    | KW_CLUSTERS
    {:
        RESULT = new ShowClusterStmt();
    :}
    | KW_MIGRATIONS
    {:
        RESULT = new ShowMigrationsStmt();
    :}
    /* Database */
    | KW_DATABASES opt_wild_where
    {:
        RESULT = new ShowDbStmt(parser.wild, parser.where);
    :}
    | KW_DATABASES KW_FROM ident:catalogName
    {:
        RESULT = new ShowDbStmt(null, null, catalogName);
    :}
    /* show database id */
    | KW_DATABASE INTEGER_LITERAL:dbId
    {:
        RESULT = new ShowDbIdStmt(dbId);
    :}
    | KW_SCHEMAS opt_wild_where
    {:
        RESULT = new ShowDbStmt(parser.wild, parser.where);
    :}
    | KW_SCHEMAS KW_FROM ident:catalogName
    {:
        RESULT = new ShowDbStmt(null, null, catalogName);
    :}
    /* Catalog */
    | KW_CATALOGS opt_wild_where
    {:
        RESULT = new ShowCatalogStmt(null, parser.wild);
    :}
    /* show Catalog name */
    | KW_CATALOG ident:catalogName
    {:
        RESULT = new ShowCatalogStmt(catalogName, null);
    :}
    /* Dynamic Partition */
    | KW_DYNAMIC KW_PARTITION KW_TABLES opt_db:db
    {:
        RESULT = new ShowDynamicPartitionStmt(db);
    :}
    /* Columns */
    | opt_full KW_COLUMNS from_or_in table_name:table opt_db:db opt_wild_where
    {:
        RESULT = new ShowColumnStmt(table, db, parser.wild, parser.isVerbose, parser.where);
    :}
    /* collation */
    | KW_COLLATION opt_wild_where
    {:
        RESULT = new ShowCollationStmt(parser.wild);
    :}
    /* Show charset */
    | charset opt_wild_where
    {:
        RESULT = new ShowCharsetStmt(parser.wild);
    :}
    /* Show proc */
    | KW_PROC STRING_LITERAL:path
    {:
        RESULT = new ShowProcStmt(path);
    :}
    /* Show Warnings */
    | KW_COUNT LPAREN STAR RPAREN KW_WARNINGS
    {:
        SelectList list = new SelectList();
        list.addItem(new SelectListItem(new IntLiteral((long)0), null));
        RESULT = new SelectStmt(list, null, null, null, null, null, null);
    :}
    | KW_COUNT LPAREN STAR RPAREN KW_ERRORS
    {:
        SelectList list = new SelectList();
        list.addItem(new SelectListItem(new IntLiteral((long)0), null));
        RESULT = new SelectStmt(list, null, null, null, null, null, null);
    :}
    | KW_WARNINGS limit_clause
    {:
        RESULT = new ShowWarningStmt();
    :}
    | KW_ERRORS limit_clause
    {:
        RESULT = new ShowWarningStmt();
    :}
    // show load warnings
    | KW_LOAD KW_WARNINGS opt_db:db opt_wild_where limit_clause:limitClause
    {:
        RESULT = new ShowLoadWarningsStmt(db, null, parser.where, limitClause);
    :}
    | KW_LOAD KW_WARNINGS KW_ON STRING_LITERAL:url
    {:
        RESULT = new ShowLoadWarningsStmt(null, url, null, null);
    :}
    /* Show load statement */
    | KW_LOAD opt_db:db opt_wild_where order_by_clause:orderByClause limit_clause:limitClause
    {:
        RESULT = new ShowLoadStmt(db, parser.where, orderByClause, limitClause);
    :}
    /* Show stream load statement */
    | KW_STREAM KW_LOAD opt_db:db opt_wild_where order_by_clause:orderByClause limit_clause:limitClause
    {:
        RESULT = new ShowStreamLoadStmt(db, parser.where, orderByClause, limitClause);
    :}
    /* Show export statement */
    | KW_EXPORT opt_db:db opt_wild_where order_by_clause:orderByClause limit_clause:limitClause
    {:
        RESULT = new ShowExportStmt(db, parser.where, orderByClause, limitClause);
    :}
    /* Show delete statement */
    | KW_DELETE opt_db:db
    {:
        RESULT = new ShowDeleteStmt(db);
    :}
    /* Show alter table statement: used to show process of alter table statement */
    | KW_ALTER KW_TABLE opt_alter_type:type opt_db:db opt_wild_where order_by_clause:orderByClause limit_clause:limitClause
    {:
        RESULT = new ShowAlterStmt(type, db, parser.where, orderByClause, limitClause);
    :}
    | KW_DATA KW_SKEW KW_FROM base_table_ref:table_ref
    {:
        RESULT = new ShowDataSkewStmt(table_ref);
    :}
    /* Show data statement: used to show data size of specified range */
     | KW_DATA order_by_clause:orderByClause
    {:
        RESULT = new ShowDataStmt(null, orderByClause);
    :}
    | KW_DATA KW_FROM table_name:dbTblName order_by_clause:orderByClause
    {:
        RESULT = new ShowDataStmt(dbTblName, orderByClause);
    :}
    | opt_tmp:tmp KW_PARTITIONS KW_FROM table_name:tblName opt_wild_where order_by_clause:orderByClause limit_clause: limitClause
    {:
        RESULT = new ShowPartitionsStmt(tblName, parser.where, orderByClause, limitClause, tmp);
    :}
    /* show partition id */
    | KW_PARTITION INTEGER_LITERAL:partitionId
    {:
        RESULT = new ShowPartitionIdStmt(partitionId);
    :}
    | KW_TABLET INTEGER_LITERAL:tabletId
    {:
        RESULT = new ShowTabletStmt(null, tabletId);
    :}
    | KW_TABLETS KW_FROM table_name:dbTblName opt_partition_names:partitionNames opt_wild_where order_by_clause:orderByClause limit_clause:limitClause
    {:
        RESULT = new ShowTabletStmt(dbTblName, -1L, partitionNames, parser.where, orderByClause, limitClause);
    :}
    | KW_PROPERTY opt_user:user opt_wild_where
    {:
        RESULT = new ShowUserPropertyStmt(user, parser.wild);
    :}
    | KW_BACKUP opt_db:db opt_wild_where
    {:
        RESULT = new ShowBackupStmt(db, parser.where);
    :}
    | KW_RESTORE opt_db:db opt_wild_where
    {:
        RESULT = new ShowRestoreStmt(db, parser.where);
    :}
    | KW_BROKER
    {:
        RESULT = new ShowBrokerStmt();
    :}
    | KW_RESOURCES opt_wild_where order_by_clause:orderByClause limit_clause:limitClause
    {:
        RESULT = new ShowResourcesStmt(parser.where, orderByClause, limitClause);
    :}
    | KW_BACKENDS
    {:
        RESULT = new ShowBackendsStmt();
    :}
    | KW_TRASH KW_ON STRING_LITERAL:backend
    {:
        RESULT = new ShowTrashDiskStmt(backend);
    :}
    | KW_TRASH 
    {:
        RESULT = new ShowTrashStmt();
    :}
    | KW_FRONTENDS
    {:
        RESULT = new ShowFrontendsStmt();
    :}
    | KW_REPOSITORIES
    {:
       RESULT = new ShowRepositoriesStmt();
    :}
    | KW_SNAPSHOT KW_ON ident:repo opt_wild_where
    {:
        RESULT = new ShowSnapshotStmt(repo, parser.where);
    :}
    | KW_ALL KW_GRANTS
    {:
        RESULT = new ShowGrantsStmt(null, true);
    :}
    | KW_GRANTS
    {:
        RESULT = new ShowGrantsStmt(null, false);
    :}
    | KW_GRANTS KW_FOR user_identity:userIdent
    {:
        RESULT = new ShowGrantsStmt(userIdent, false);
    :}
    | KW_ROLES
    {:
        RESULT = new ShowRolesStmt();
    :}
    | opt_full opt_builtin:isBuiltin KW_FUNCTIONS opt_db:dbName opt_wild_where
    {:
        RESULT = new ShowFunctionsStmt(dbName, isBuiltin, parser.isVerbose, parser.wild, parser.where);
    :}
    | KW_FILE opt_db:dbName
    {:
        RESULT = new ShowSmallFilesStmt(dbName);
    :}
    | keys_or_index from_or_in table_name:dbTblName opt_db:dbName
    {:
        RESULT = new ShowIndexStmt(dbName, dbTblName);
    :}
    | KW_VIEW from_or_in table_name:dbTblName opt_db:dbName
    {:
        RESULT = new ShowViewStmt(dbName, dbTblName);
    :}
    | KW_TRANSACTION opt_db:dbName opt_wild_where
    {:
        RESULT = new ShowTransactionStmt(dbName, parser.where);
    :}
    | KW_QUERY KW_PROFILE STRING_LITERAL:queryIdPath
    {:
        RESULT = new ShowQueryProfileStmt(queryIdPath);
    :}
    | KW_LOAD KW_PROFILE STRING_LITERAL:loadIdPath
    {:
        RESULT = new ShowLoadProfileStmt(loadIdPath);
    :}
    | KW_ENCRYPTKEYS opt_db:dbName opt_wild_where
    {:
        RESULT = new ShowEncryptKeysStmt(dbName, parser.wild);
    :}
    /* Show Sync Job */
    | KW_SYNC KW_JOB opt_db:dbName
    {:
        RESULT = new ShowSyncJobStmt(dbName);
    :}
    /* show column stats */
    | KW_COLUMN KW_STATS table_name:tbl opt_partition_names:partitionNames
    {:
        RESULT = new ShowColumnStatsStmt(tbl, partitionNames);
    :}
    /* show table creation statement */
    | KW_TABLE KW_CREATION opt_db:db opt_wild_where
    {:
        RESULT = new ShowTableCreationStmt(db, parser.wild);
    :}
    /* show last insert */
    | KW_LAST KW_INSERT
    {:
        RESULT = new ShowLastInsertStmt();
    :}
    | KW_CREATE KW_MATERIALIZED KW_VIEW ident:mvName KW_ON table_name:tableName
    {:
        RESULT = new ShowCreateMaterializedViewStmt(mvName, tableName);
    :}
    /* show analyze job */
    | KW_ANALYZE integer_list:jobIds
    {:
        RESULT = new ShowAnalyzeStmt(jobIds);
    :}
    | KW_ANALYZE opt_table_name:tbl opt_wild_where order_by_clause:orderByClause limit_clause:limitClause
    {:
        RESULT = new ShowAnalyzeStmt(tbl, parser.where, orderByClause, limitClause);
    :}
    | KW_CATALOG KW_RECYCLE KW_BIN opt_wild_where
    {:
        RESULT = new ShowCatalogRecycleBinStmt(parser.where);
    :}
    ;

opt_tmp ::=
    /* empty */
    {:
        RESULT = false;
    :}
    | KW_TEMPORARY
    {:
        RESULT = true;
    :}
    ;

keys_or_index ::=
    KW_KEY
    | KW_KEYS
    | KW_INDEX
    | KW_INDEXES
    ;

opt_db ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | from_or_in ident:db
    {:
        RESULT = db;
    :}
    ;

charset ::=
    KW_CHAR KW_SET
    | KW_CHARSET
    ;

charset_name_or_default ::=
    ident_or_text:id
    {:
        RESULT = id;
    :}
    | KW_DEFAULT
    {:
        RESULT = null;
    :}
    ;

old_or_new_charset_name_or_default ::=
    ident_or_text:id
    {:
        RESULT = id;
    :}
    | KW_DEFAULT
    {:
        RESULT = null;
    :}
    ;

opt_collate ::=
    /* Empty */
    {:
        RESULT = null;
    :}
    | KW_COLLATE collation_name_or_default:collate
    {:
        RESULT = collate;
    :}
    ;

collation_name_or_default ::=
    ident_or_text:id
    {:
        RESULT = id;
    :}
    | KW_DEFAULT
    {:
        RESULT = null;
    :}
    ;

opt_storage ::=
    /* Empty */
    | KW_STORAGE
    ;

procedure_or_function ::=
    KW_PROCEDURE
    | KW_FUNCTION
    ;

from_or_in ::=
    KW_FROM
    | KW_IN
    ;

opt_full ::=
    /* empty */
    {:
        parser.isVerbose = false;
    :}
    | KW_FULL
    {:
        parser.isVerbose = true;
    :}
    ;

opt_wild_where ::=
    /* empty */
    | KW_LIKE STRING_LITERAL:wild
    {:
        parser.wild = wild;
    :}
    | KW_WHERE expr:where
    {:
        parser.where = where;
    :}
    ;

opt_id ::=
    /* empty */
    {:
        RESULT = (long)-1;
    :}
    | INTEGER_LITERAL:id
    {:
        RESULT = id;
    :}
    ;

opt_alter_type ::=
    KW_ROLLUP
    {:
        RESULT = ShowAlterStmt.AlterType.ROLLUP;
    :}
    | KW_MATERIALIZED KW_VIEW
    {:
        RESULT =  ShowAlterStmt.AlterType.ROLLUP;
    :}
    | KW_COLUMN
    {:
        RESULT = ShowAlterStmt.AlterType.COLUMN;
    :}
    ;

opt_builtin ::=
    {:
        RESULT = false;
    :}
    | KW_BUILTIN
    {:
        RESULT = true;
    :}
    ;

opt_explain_options ::=
    {:
        RESULT = new ExplainOptions(false, false);
    :}
    | KW_VERBOSE
    {:
        RESULT = new ExplainOptions(true, false);
    :}
    | KW_GRAPH
    {:
        RESULT = new ExplainOptions(false, true);
    :}
    ;

// Describe statement
describe_stmt ::=
    describe_command table_name:table
    {:
        RESULT = new DescribeStmt(table, false);
    :}
    | KW_SHOW KW_FIELDS KW_FROM table_name:table
    {:
        RESULT = new DescribeStmt(table, false);
    :}
    | KW_SHOW KW_COLUMNS KW_FROM table_name:table
    {:
        RESULT = new DescribeStmt(table, false);
    :}
    | describe_command KW_FUNCTION table_valued_function_ref:tvf
    {:
        RESULT = new DescribeStmt(tvf);
    :}
    | describe_command table_name:table KW_ALL
    {:
        RESULT = new DescribeStmt(table, true);
    :}
    | KW_SHOW KW_EXTENDED KW_FIELDS KW_FROM table_name:table
    {:
        RESULT = new DescribeStmt(table, true);
    :}
    | KW_SHOW KW_EXTENDED KW_COLUMNS KW_FROM table_name:table
    {:
        RESULT = new DescribeStmt(table, true);
    :}
    | describe_command opt_explain_options:options query_stmt:query
    {:
        query.setIsExplain(options);
        RESULT = query;
    :}   
    | describe_command opt_explain_options:options insert_stmt:stmt
    {:
        stmt.getQueryStmt().setIsExplain(options);
        RESULT = stmt;
    :}
    ;

describe_command ::=
    KW_DESCRIBE
    | KW_DESC
    ;

// Cancel statement
cancel_stmt ::=
    KW_CANCEL cancel_param:stmt
    {:
        RESULT = stmt;
    :}
    ;

cancel_rollup_job_id_list ::=
    {:
        RESULT = null;
    :}
    | LPAREN integer_list:list RPAREN
    {:
        RESULT = list;
    :}
    ;

cancel_param ::=
    KW_LOAD opt_db:db opt_wild_where
    {:
        RESULT = new CancelLoadStmt(db, parser.where);
    :}
    | KW_ALTER KW_TABLE opt_alter_type:type KW_FROM table_name:table cancel_rollup_job_id_list:list
    {:
        RESULT = new CancelAlterTableStmt(type, table, list);
    :}
    | KW_DECOMMISSION KW_BACKEND string_list:hostPorts
    {:
        RESULT = new CancelAlterSystemStmt(hostPorts);
    :}
    | KW_BACKUP opt_db:db
    {:
        RESULT = new CancelBackupStmt(db, false);
    :}
    | KW_RESTORE opt_db:db
    {:
        RESULT = new CancelBackupStmt(db, true);
    :}
    ;

// Delete stmt
delete_stmt ::=
    KW_DELETE KW_FROM table_name:table opt_partition_names:partitionNames where_clause:wherePredicate
    {:
        RESULT = new DeleteStmt(table, partitionNames, wherePredicate);
    :}
    ;

// Our parsing of UNION is slightly different from MySQL's:
// http://dev.mysql.com/doc/refman/5.5/en/union.html
//
// Imo, MySQL's parsing of union is not very clear.
// For example, MySQL cannot parse this query:
// select 3 order by 1 limit 1 union all select 1;
//
// On the other hand, MySQL does parse this query, but associates
// the order by and limit with the union, not the select:
// select 3 as g union all select 1 order by 1 limit 2;
//
// MySQL also allows some combinations of select blocks
// with and without parenthesis, but also disallows others.
//
// Our parsing:
// Select blocks may or may not be in parenthesis,
// even if the union has order by and limit.
// ORDER BY and LIMIT bind to the preceding select statement by default.
query_stmt ::=
    opt_with_clause:w set_operand_list:operands opt_outfile:outfile
    {:
        QueryStmt queryStmt = null;
        if (operands.size() == 1) {
          queryStmt = operands.get(0).getQueryStmt();
        } else {
          queryStmt = new SetOperationStmt(operands, null, LimitElement.NO_LIMIT);
        }
        queryStmt.setWithClause(w);
        queryStmt.setOutFileClause(outfile);
        RESULT = queryStmt;
    :}
    | opt_with_clause:w set_operation_with_order_by_or_limit:set_operation opt_outfile:outfile
    {:
        set_operation.setWithClause(w);
        set_operation.setOutFileClause(outfile);
        RESULT = set_operation;
    :}
    ;

opt_outfile ::=
    {:
        RESULT = null;
    :}
    | KW_INTO KW_OUTFILE STRING_LITERAL:file opt_file_format:fileFormat opt_properties:properties
    {:
        RESULT = new OutFileClause(file, fileFormat, properties);
    :}
    ;

opt_with_clause ::=
    KW_WITH with_view_def_list:list
    {: RESULT = new WithClause(list); :}
    | /* empty */
    {: RESULT = null; :}
    ;

with_view_def ::=
    ident:alias KW_AS LPAREN query_stmt:query RPAREN
    {: RESULT = new View(alias, query, null); :}
    | STRING_LITERAL:alias KW_AS LPAREN query_stmt:query RPAREN
    {: RESULT = new View(alias, query, null); :}
    | ident:alias LPAREN ident_list:col_names RPAREN KW_AS LPAREN
      query_stmt:query RPAREN
    {: RESULT = new View(alias, query, col_names); :}
    | STRING_LITERAL:alias LPAREN ident_list:col_names RPAREN
      KW_AS LPAREN query_stmt:query RPAREN
    {: RESULT = new View(alias, query, col_names); :}
    ;

with_view_def_list ::=
    with_view_def:v
    {:
        ArrayList<View> list = new ArrayList<View>();
        list.add(v);
        RESULT = list;
    :}
    | with_view_def_list:list COMMA with_view_def:v
    {:
        list.add(v);
        RESULT = list;
    :}
    ;

// We must have a non-empty order by or limit for them to bind to the union.
// We cannot reuse the existing order_by_clause or
// limit_clause because they would introduce conflicts with EOF,
// which, unfortunately, cannot be accessed in the parser as a nonterminal
// making this issue unresolvable.
// We rely on the left precedence of KW_ORDER, KW_BY, and KW_LIMIT,
// to resolve the ambiguity with select_stmt in favor of select_stmt
// (i.e., ORDER BY and LIMIT bind to the select_stmt by default, and not the set operation).
// There must be at least two set operands for ORDER BY or LIMIT to bind to a set operation,
// and we manually throw a parse error if we reach this production
// with only a single operand.
set_operation_with_order_by_or_limit ::=
    set_operand_list:operands
    KW_LIMIT INTEGER_LITERAL:limit
  {:
    if (operands.size() == 1) {
      parser.parseError("limit", SqlParserSymbols.KW_LIMIT);
    }
    RESULT = new SetOperationStmt(operands, null, new LimitElement(limit.longValue()));
  :}
  |
    set_operand_list:operands
    KW_LIMIT INTEGER_LITERAL:offset COMMA INTEGER_LITERAL:limit
  {:
    if (operands.size() == 1) {
      parser.parseError("limit", SqlParserSymbols.KW_LIMIT);
    }
    RESULT = new SetOperationStmt(operands, null, new LimitElement(offset.longValue(), limit.longValue()));
  :}
  |
    set_operand_list:operands
    KW_LIMIT INTEGER_LITERAL:limit KW_OFFSET INTEGER_LITERAL:offset
  {:
    if (operands.size() == 1) {
      parser.parseError("limit", SqlParserSymbols.KW_LIMIT);
    }
    RESULT = new SetOperationStmt(operands, null, new LimitElement(offset.longValue(), limit.longValue()));
  :}
  |
    set_operand_list:operands
    KW_ORDER KW_BY order_by_elements:orderByClause
  {:
    if (operands.size() == 1) {
      parser.parseError("order", SqlParserSymbols.KW_ORDER);
    }
    RESULT = new SetOperationStmt(operands, orderByClause, LimitElement.NO_LIMIT);
  :}
  |
    set_operand_list:operands
    KW_ORDER KW_BY order_by_elements:orderByClause
    KW_LIMIT INTEGER_LITERAL:limit
  {:
    if (operands.size() == 1) {
      parser.parseError("order", SqlParserSymbols.KW_ORDER);
    }
    RESULT = new SetOperationStmt(operands, orderByClause, new LimitElement(limit.longValue()));
  :}
  |
    set_operand_list:operands
    KW_ORDER KW_BY order_by_elements:orderByClause
    KW_LIMIT INTEGER_LITERAL:offset COMMA INTEGER_LITERAL:limit
  {:
    if (operands.size() == 1) {
      parser.parseError("order", SqlParserSymbols.KW_ORDER);
    }
    RESULT = new SetOperationStmt(operands, orderByClause, new LimitElement(offset.longValue(), limit.longValue()));
  :}
  |
    set_operand_list:operands
    KW_ORDER KW_BY order_by_elements:orderByClause
    KW_LIMIT INTEGER_LITERAL:limit KW_OFFSET INTEGER_LITERAL:offset
  {:
    if (operands.size() == 1) {
      parser.parseError("order", SqlParserSymbols.KW_ORDER);
    }
    RESULT = new SetOperationStmt(operands, orderByClause, new LimitElement(offset.longValue(), limit.longValue()));
  :}
  ;


set_operand ::=
  select_stmt:select
  {:
    RESULT = select;
  :}
  | LPAREN query_stmt:query RPAREN
  {:
    RESULT = query;
  :}
  ;

set_operand_list ::=
  set_operand:operand
  {:
    List<SetOperand> operands = new ArrayList<SetOperand>();
    operands.add(new SetOperand(operand, null, null));
    RESULT = operands;
  :}
  | set_operand_list:operands set_op:op opt_set_qualifier:qualifier set_operand:operand
  {:
    operands.add(new SetOperand(operand, op, qualifier));
    RESULT = operands;
  :}
  ;

set_op ::=
  KW_UNION
  {: RESULT = Operation.UNION; :}
  | KW_INTERSECT
  {: RESULT = Operation.INTERSECT; :}
  | KW_EXCEPT
  {: RESULT = Operation.EXCEPT; :}
  | KW_MINUS
  {: RESULT = Operation.EXCEPT; :}
  ;

opt_set_qualifier ::=
  {: RESULT = Qualifier.DISTINCT; :}
  | KW_DISTINCT
  {: RESULT = Qualifier.DISTINCT; :}
  | KW_ALL
  {: RESULT = Qualifier.ALL; :}
  ;

// Change catalog
switch_stmt ::=
    KW_SWITCH ident:catalog
    {:
        RESULT = new SwitchStmt(catalog);
    :}
    ;

// Change cluster
enter_stmt ::=
    KW_ENTER ident:cluster
    {:
        RESULT = new EnterStmt(cluster);
    :}
    ;
// Change database
use_stmt ::=
    KW_USE ident:db
    {:
        RESULT = new UseStmt(db);
    :}
    | KW_USE ident:ctl DOT ident:db
    {:
        RESULT = new UseStmt(ctl, db);
    :}
    ;

// Insert statement
insert_stmt ::=
    KW_INSERT KW_INTO insert_target:target opt_with_label:label opt_col_list:cols opt_plan_hints:hints insert_source:source
    {:
        RESULT = new InsertStmt(target, label, cols, source, hints);
    :}
    // TODO(zc) add default value for SQL-2003
    // | KW_INSERT KW_INTO insert_target:target KW_DEFAULT KW_VALUES
    ;

insert_target ::=
    table_name:tbl opt_partition_names:partitionNames
    {:
        RESULT = new InsertTarget(tbl, partitionNames);
    :}
    ;

opt_with_label ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | KW_WITH KW_LABEL ident:label
    {:
        RESULT = label;
    :}
    ;

insert_source ::=
    query_stmt:query
    {:
        RESULT = new InsertSource(query);
    :}
    ;

// update stmt
update_stmt ::=
    KW_UPDATE table_name:tbl KW_SET expr_list:setExprs where_clause:whereClause
    {:
        RESULT = new UpdateStmt(tbl, setExprs, whereClause);
    :}
    ;

// backup stmt
backup_stmt ::=
    KW_BACKUP KW_SNAPSHOT job_label:label
    KW_TO ident:repoName
    opt_backup_table_ref_list:tblRefClause
    opt_properties:properties
    {:
        RESULT = new BackupStmt(label, repoName, tblRefClause, properties);
    :}
    ;

unlock_tables_stmt ::=
    KW_UNLOCK KW_TABLES
    {:
        RESULT = new UnlockTablesStmt();
    :}
    ;
lock_alias ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | KW_AS ident:ident
    {:
        RESULT = ident;
    :}
    | KW_AS STRING_LITERAL:l
    {:
        RESULT = l;
    :}
    ;

lock_table ::=
    table_name:name lock_alias:alias KW_READ
    {:
        RESULT = new LockTable(name, alias, LockTable.LockType.READ);
    :}
    |
    table_name:name lock_alias:alias KW_READ KW_LOCAL
    {:
        RESULT = new LockTable(name, alias, LockTable.LockType.READ_LOCAL);
    :}
    |
    table_name:name lock_alias:alias KW_WRITE
    {:
        RESULT = new LockTable(name, alias, LockTable.LockType.WRITE);
    :}
    |
    table_name:name lock_alias:alias KW_LOW_PRIORITY KW_WRITE
    {:
        RESULT = new LockTable(name, alias, LockTable.LockType.LOW_PRIORITY_WRITE);
    :}
    ;

opt_lock_tables_list ::=
  lock_table: table
  {:
    ArrayList<LockTable> lock_tables = new ArrayList<LockTable>();
    lock_tables.add(table);
    RESULT = lock_tables;
  :}
  | opt_lock_tables_list:lock_tables COMMA lock_table:table
  {:
    lock_tables.add(table);
    RESULT = lock_tables;
  :}
  |
  {:
       RESULT = new ArrayList<LockTable>();
  :}
  ;

lock_tables_stmt ::=
    KW_LOCK KW_TABLES opt_lock_tables_list:lock_tables
    {:
        RESULT = new LockTablesStmt(lock_tables);
    :}
    ;

opt_backup_table_ref_list ::=
    backup_exclude_or_not:isExclude LPAREN base_table_ref_list:tbls RPAREN
    {:
        RESULT = new AbstractBackupTableRefClause(isExclude, tbls);
    :}
    | /* empty */
    {:
        RESULT = null;
    :}
    ;

backup_exclude_or_not ::=
    KW_ON
    {:
        RESULT = false;
    :}
    | KW_EXCLUDE
    {:
        RESULT = true;
    :}
    ;

// Restore statement
restore_stmt ::=
    KW_RESTORE KW_SNAPSHOT job_label:label
    KW_FROM ident:repoName
    opt_backup_table_ref_list:tblRefClause
    opt_properties:properties
    {:
        RESULT = new RestoreStmt(label, repoName, tblRefClause, properties);
    :}
    ;

// Kill statement
kill_stmt ::=
    KW_KILL INTEGER_LITERAL:value
    {:
        RESULT = new KillStmt(true, value.intValue());
    :}
    | KW_KILL KW_CONNECTION INTEGER_LITERAL:value
    {:
        RESULT = new KillStmt(true, value.intValue());
    :}
    | KW_KILL KW_QUERY INTEGER_LITERAL:value
    {:
        RESULT = new KillStmt(false, value.intValue());
    :}
    ;

// TODO(zhaochun): stolen from MySQL. Why not use value list, maybe avoid shift/reduce conflict
// Set statement
set_stmt ::=
    KW_SET start_option_value_list:list
    {:
        RESULT = new SetStmt(list);
    :}
    | KW_SET KW_PROPERTY opt_user:user user_property_list:property_list
    {:
        RESULT = new SetUserPropertyStmt(user, property_list);
    :}
    ;

user_property_list ::=
    user_property:property
    {:
        RESULT = Lists.newArrayList(property);
    :}
    | user_property_list:list COMMA user_property:property
    {:
        list.add(property);
        RESULT = list;
    :}
    ;

user_property ::=
    STRING_LITERAL:key equal STRING_LITERAL:value
    {:
        RESULT = new SetUserPropertyVar(key, value);
    :}
    | STRING_LITERAL:key equal KW_NULL
    {:
        RESULT = new SetUserPropertyVar(key, null);
    :}
    ;

// Start of set value list
start_option_value_list ::=
    /* Variable starts with keyword and have no option */
    option_value_no_option_type:value option_value_list_continued:list
    {:
        if (list == null) {
            list = Lists.newArrayList(value);
        } else {
            list.add(value);
        }
        RESULT = list;
    :}
    /* Do not support transaction, return null */
    | KW_TRANSACTION transaction_characteristics
    {:
        RESULT = Lists.newArrayList((SetVar) new SetTransaction());
    :}
    | option_type:type start_option_value_list_following_option_type:list
    {:
        if (list == null || list.isEmpty()) {
        } else {
            list.get(0).setType(type);
        }
        RESULT = list;
    :}
    ;

// Following the start of value list with option
start_option_value_list_following_option_type ::=
    option_value_follow_option_type:var option_value_list_continued:list
    {:
        list.add(var);
        RESULT = list;
    :}
    | KW_TRANSACTION transaction_characteristics
    {:
        RESULT = Lists.newArrayList((SetVar) new SetTransaction());
    :}
    ;

// option values after first value;
option_value_list_continued ::=
    /* empty */
    {:
        RESULT = Lists.newArrayList();
    :}
    | COMMA option_value_list:list
    {:
        RESULT = list;
    :}
    ;

option_value_list ::=
    option_value:var
    {:
        RESULT = Lists.newArrayList(var);
    :}
    | option_value_list:list COMMA option_value:item
    {:
        list.add(item);
        RESULT = list;
    :}
    ;

option_value ::=
    option_type:type option_value_follow_option_type:var
    {:
        var.setType(type);
        RESULT = var;
    :}
    | option_value_no_option_type:var
    {:
        RESULT = var;
    :}
    ;

option_value_follow_option_type ::=
    variable_name:variable equal set_expr_or_default:expr
    {:
        RESULT = new SetVar(variable, expr);
    :}
    ;

option_value_no_option_type ::=
    /* Normal set value */
    variable_name:variable equal set_expr_or_default:expr
    {:
        RESULT = new SetVar(variable, expr);
    :}
    | AT ident_or_text:var equal literal:expr
    {:
        RESULT = new SetVar(var, expr);
    :}
    /* Ident */
    | AT AT variable_name:variable equal set_expr_or_default:expr
    {:
        RESULT = new SetVar(variable, expr);
    :}
    | AT AT var_ident_type:type variable_name:variable equal set_expr_or_default:expr
    {:
        RESULT = new SetVar(type, variable, expr);
    :}
    /* charset */
    | charset old_or_new_charset_name_or_default:charset
    {:
        RESULT = new SetNamesVar(charset);
    :}
    | KW_NAMES equal expr
    {:
        parser.parseError("names", SqlParserSymbols.KW_NAMES);
    :}
    | KW_NAMES charset_name_or_default:charset opt_collate:collate
    {:
        RESULT = new SetNamesVar(charset, collate);
    :}
    /* Password */
    | KW_PASSWORD equal text_or_password:passwd
    {:
        RESULT = new SetPassVar(null, passwd);
    :}
    | KW_PASSWORD KW_FOR user_identity:userId equal text_or_password:passwd
    {:
        RESULT = new SetPassVar(userId, passwd);
    :}
    | KW_LDAP_ADMIN_PASSWORD equal text_or_password:passwd
    {:
        RESULT = new SetLdapPassVar(passwd);
    :}
    ;

variable_name ::=
    ident:name
    {:
        RESULT = name;
    :}
    ;

text_or_password ::=
    STRING_LITERAL:text
    {:
        // This is hashed text
        RESULT = new PassVar(text, false);
    :}
    | KW_PASSWORD LPAREN STRING_LITERAL:text RPAREN
    {:
        // This is plain text
        RESULT = new PassVar(text, true);
    :}
    ;

option_type ::=
    KW_GLOBAL
    {:
        RESULT = SetType.GLOBAL;
    :}
    | KW_LOCAL
    {:
        RESULT = SetType.SESSION;
    :}
    | KW_SESSION
    {:
        RESULT = SetType.SESSION;
    :}
    ;

opt_var_type ::=
    /* empty */
    {: RESULT = SetType.DEFAULT; :}
    | KW_GLOBAL
    {: RESULT = SetType.GLOBAL; :}
    | KW_LOCAL
    {: RESULT = SetType.SESSION; :}
    | KW_SESSION
    {: RESULT = SetType.SESSION; :}
    ;

var_ident_type ::=
    KW_GLOBAL DOT
    {:
        RESULT = SetType.GLOBAL;
    :}
    | KW_LOCAL DOT
    {:
        RESULT = SetType.SESSION;
    :}
    | KW_SESSION DOT
    {:
        RESULT = SetType.SESSION;
    :}
    ;

equal ::=
    EQUAL
    | SET_VAR
    ;

transaction_characteristics ::=
    transaction_access_mode
    | isolation_level
    | transaction_access_mode COMMA isolation_level
    | isolation_level COMMA transaction_access_mode
    ;

transaction_access_mode ::=
    KW_READ KW_ONLY
    | KW_READ KW_WRITE
    ;

isolation_level ::=
    KW_ISOLATION KW_LEVEL isolation_types
    ;

isolation_types ::=
    KW_READ KW_UNCOMMITTED
    | KW_READ KW_COMMITTED
    | KW_REPEATABLE KW_READ
    | KW_SERIALIZABLE
    ;

set_expr_or_default ::=
    KW_DEFAULT
    {:
        RESULT = null;
    :}
    | KW_ON
    {:
        RESULT = new StringLiteral("ON");
    :}
    | KW_ALL
    {:
        RESULT = new StringLiteral("ALL");
    :}
    | expr:expr
    {:
        RESULT = expr;
    :}
    ;

select_stmt ::=
  select_clause:selectList
    limit_clause:limitClause
  {: RESULT = new SelectStmt(selectList, null, null, null, null, null, limitClause); :}
  | select_clause:selectList
    from_clause:fromClause
    where_clause:wherePredicate
    group_by_clause:groupByClause
    having_clause:havingPredicate
    order_by_clause:orderByClause
    limit_clause:limitClause
  {:
    RESULT = new SelectStmt(selectList, fromClause, wherePredicate,
                            groupByClause, havingPredicate, orderByClause,
                            limitClause);
  :}
  | value_clause:valueClause order_by_clause:orderByClause limit_clause:limitClause
  {:
      RESULT = new SelectStmt(valueClause, orderByClause, limitClause);
  :}
  ;

value_clause ::=
    KW_VALUES row_value:value
    {:
        RESULT = new ValueList(value);
    :}
    | value_clause:valueClause COMMA row_value:value
    {:
        valueClause.addRow(value);
        RESULT = valueClause;
    :}
    ;

row_value ::=
    LPAREN opt_values:values RPAREN
    {:
        RESULT = values;
    :}
    ;

opt_values ::=
    values:valueList
    {:
        RESULT = valueList;
    :}
    |
    {:
        RESULT = Lists.newArrayList();
    :}
    ;

values ::=
    expr_or_default:value
    {:
        RESULT = Lists.newArrayList(value);
    :}
    | values:valueList COMMA expr_or_default:value
    {:
        valueList.add(value);
        RESULT = valueList;
    :}
    ;

expr_or_default ::=
    expr:expr
    {:
        RESULT = expr;
    :}
    | KW_DEFAULT
    {:
        RESULT = new DefaultValueExpr();
    :}
    ;

select_clause ::=
    KW_SELECT opt_select_hints:hints select_list:l
    {:
        l.setOptHints(hints);
        RESULT = l;
    :}
    | KW_SELECT opt_select_hints:hints KW_ALL select_list:l
    {:
        l.setOptHints(hints);
        RESULT = l;
    :}
    | KW_SELECT opt_select_hints:hints KW_DISTINCT select_list:l
    {:
        l.setOptHints(hints);
        l.setIsDistinct(true);
        RESULT = l;
    :}
    ;

query_hint_parameter_key ::=
    literal:k
    {:
        RESULT = k.getStringValue();
    :}
    | variable_name:k
    {:
        RESULT = k;
    :}
    ;

query_hint_parameter ::=
    query_hint_parameter_key:k
    {:
        RESULT = new AbstractMap.SimpleEntry<String, String>(k, null);
    :}
    | query_hint_parameter_key:k equal literal_or_ident:v
    {:
        RESULT = new AbstractMap.SimpleEntry<String, String>(k, v);
    :}
    ;


query_hint_parameters ::=
    query_hint_parameters:map COMMA query_hint_parameter:kv
    {:
        map.put(kv.getKey(), kv.getValue());
        RESULT = map;
    :}
    |  query_hint_parameter:kv
    {:
        Map<String, String> map = new HashMap<>();
        map.put(kv.getKey(), kv.getValue());
        RESULT = map;
    :}
    |
    {:
        RESULT = new HashMap<String, String>();
    :}
    ;

query_hint ::=
    ident:k LPAREN query_hint_parameters:v RPAREN
    {:
        RESULT = new AbstractMap.SimpleEntry<String, Map<String, String>>(k.toLowerCase(Locale.ROOT), v);
    :}
    ;

query_hints ::=
    query_hints:map query_hint:kv
    {:
        map.computeIfAbsent(kv.getKey(), k -> new HashMap<>());
        map.get(kv.getKey()).putAll(kv.getValue());
        RESULT = map;
    :}
    | query_hint:kv
    {:
        Map<String, Map<String, String>> map = new HashMap<>();
        map.put(kv.getKey(), kv.getValue());
        RESULT = map;
    :}
    ;

literal_or_ident ::=
    literal:l
    {:
        RESULT = l.getStringValue();
    :}
    | ident:i
    {:
        RESULT = i;
    :}
    ;

opt_select_hints ::=
    COMMENTED_PLAN_HINT_START query_hints:map COMMENTED_PLAN_HINT_END
    {:
        RESULT = map;
    :}
    | /* empty */
    {:
        RESULT = null;
    :}
    ;

select_list ::=
    select_sublist:list
    {:
        RESULT = list;
    :}
    | STAR
    {:
        SelectList list = new SelectList();
        list.addItem(SelectListItem.createStarItem(null));
        RESULT = list;
    :}
    | STAR KW_EXCEPT LPAREN select_sublist: list RPAREN
    {:
        SelectList res = new SelectList(list);
        list.setIsExcept(true);
        RESULT = list;
    :}
    ;

select_sublist ::=
    select_sublist:list COMMA select_list_item:item
    {:
        list.addItem(item);
        RESULT = list;
    :}
    | select_sublist:list COMMA STAR
    {:
        list.addItem(SelectListItem.createStarItem(null));
        RESULT = list;
    :}
    // why not use "STAR COMMA select_sublist",for we analyze from left to right
    | STAR COMMA select_list_item:item
    {:
        SelectList list = new SelectList();
        list.addItem(SelectListItem.createStarItem(null));
        list.addItem(item);
        RESULT = list;
    :}
    | select_list_item:item
    {:
        SelectList list = new SelectList();
        list.addItem(item);
        RESULT = list;
    :}
    ;

select_list_item ::=
    expr:expr select_alias:alias
    {:
        RESULT = new SelectListItem(expr, alias);
    :}
    | star_expr:expr
    {:
        RESULT = expr;
    :}
    ;

select_alias ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | KW_AS ident:ident
    {:
        RESULT = ident;
    :}
    | ident:ident
    {:
        RESULT = ident;
    :}
    | KW_AS STRING_LITERAL:l
    {:
        RESULT = l;
    :}
    | STRING_LITERAL:l
    {:
        RESULT = l;
    :}
    ;

star_expr ::=
    // table_name DOT STAR doesn't work because of a reduce-reduce conflict
    // on IDENT [DOT]
    ident:tbl DOT STAR
    {:
        RESULT = SelectListItem.createStarItem(new TableName(null, null, tbl));
    :}
    | ident:db DOT ident:tbl DOT STAR
    {:
        RESULT = SelectListItem.createStarItem(new TableName(null, db, tbl));
    :}
    | ident:ctl DOT ident:db DOT ident:tbl DOT STAR
    {:
        RESULT = SelectListItem.createStarItem(new TableName(ctl, db, tbl));
    :}
    ;

opt_table_name ::=
    {:
        RESULT = null;
    :}
    | table_name:tbl
    {:
        RESULT = tbl;
    :}
    ;

table_name ::=
    ident:tbl
    {: RESULT = new TableName(null, null, tbl); :}
    | ident:db DOT ident:tbl
    {: RESULT = new TableName(null, db, tbl); :}
    | ident:ctl DOT ident:db DOT ident:tbl
    {: RESULT = new TableName(ctl, db, tbl); :}
    ;

encryptkey_name ::=
    ident:name
    {:
        RESULT = new EncryptKeyName(name);
    :}
    | ident:db DOT ident:name
    {:
        RESULT = new EncryptKeyName(db, name);
    :}
    ;

function_name ::=
    type_function_name:fn
    {: RESULT = new FunctionName(null, fn); :}
    | ident:db DOT type_function_name:fn
    {: RESULT = new FunctionName(db, fn); :}
    ;

type_function_name ::=
    ident:id
    {: RESULT = id; :}
    | type_func_name_keyword:id
    {: RESULT = id; :}
    ;

from_clause ::=
    KW_FROM table_ref_list:l
    {: RESULT = new FromClause(l); :}
    ;

table_ref_list ::=
  table_ref:t opt_sort_hints:h
  {:
    ArrayList<TableRef> list = new ArrayList<TableRef>();
    t.setSortHints(h);
    list.add(t);
    RESULT = list;
  :}
  | table_ref_list:list COMMA table_ref:table opt_sort_hints:h
  {:
    table.setSortHints(h);
    list.add(table);
    RESULT = list;
  :}
  | table_ref_list:list join_operator:op opt_plan_hints:hints table_ref:table opt_sort_hints:h
  {:
    table.setJoinOp((JoinOperator) op);
    table.setJoinHints(hints);
    table.setSortHints(h);
    list.add(table);
    RESULT = list;
  :}
  | table_ref_list:list join_operator:op opt_plan_hints:hints table_ref:table opt_sort_hints:h
    KW_ON expr:e
  {:
    table.setJoinOp((JoinOperator) op);
    table.setJoinHints(hints);
    table.setOnClause(e);
    table.setSortHints(h);
    list.add(table);
    RESULT = list;
  :}
  | table_ref_list:list join_operator:op opt_plan_hints:hints table_ref:table opt_sort_hints:h
    KW_USING LPAREN ident_list:colNames RPAREN
  {:
    table.setJoinOp((JoinOperator) op);
    table.setJoinHints(hints);
    table.setUsingClause(colNames);
    table.setSortHints(h);
    list.add(table);
    RESULT = list;
  :}
  ;

table_ref ::=
  base_table_ref:b opt_lateral_view_ref_list:lateralViewRefList
  {:
    b.setLateralViewRefs(lateralViewRefList);
    RESULT = b;
  :}
  | inline_view_ref:s opt_lateral_view_ref_list:lateralViewRefList
  {:
    s.setLateralViewRefs(lateralViewRefList);
    RESULT = s;
  :}
  | table_valued_function_ref:f
  {:
  	RESULT = f;
  :}
  ;

table_valued_function_ref ::=
  ident:func_name LPAREN key_value_map:properties RPAREN opt_table_alias:alias
  {:
    RESULT = new TableValuedFunctionRef(func_name, alias, properties);
  :}
  ;

inline_view_ref ::=
    LPAREN query_stmt:query RPAREN opt_table_alias:alias
    {:
        RESULT = new InlineViewRef(alias, query);
    :}
    ;

base_table_ref_list ::=
  base_table_ref:tbl
  {:
    ArrayList<TableRef> list = new ArrayList<TableRef>();
    list.add(tbl);
    RESULT = list;
  :}
  | base_table_ref_list:list COMMA base_table_ref:tbl
  {:
    list.add(tbl);
    RESULT = list;
  :}
  ;

base_table_ref ::=
    table_name:name opt_partition_names:partitionNames opt_tablet_list:tabletIds opt_table_alias:alias opt_table_sample:tableSample opt_common_hints:commonHints
    {:
        RESULT = new TableRef(name, alias, partitionNames, tabletIds, tableSample, commonHints);
    :}
    ;

opt_common_hints ::=
    COMMENTED_PLAN_HINT_START ident_list:l COMMENTED_PLAN_HINT_END
    {:
        RESULT = l;
    :}
    | LBRACKET ident_list:l RBRACKET
    {:
        RESULT = l;
    :}
    |
    {:
        RESULT = null;
    :}
    ;

opt_alias ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | KW_AS ident:alias
    {:
        RESULT = alias;
    :}
    ;

opt_table_alias ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | ident:alias
    {:
        RESULT = alias;
    :}
    | KW_AS ident:alias
    {:
        RESULT = alias;
    :}
    | EQUAL ident:alias
    {:
        RESULT = alias;
    :}
    ;

opt_partition_names ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | partition_names:partitionNames
    {:
        RESULT = partitionNames;
    :}
    ;

opt_tablet_list ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | tablet_list:tabletList
    {:
        RESULT = tabletList;
    :}
    ;

tablet_list ::=
    KW_TABLET LPAREN integer_list:tabletIds RPAREN
    {:
        RESULT = Lists.newArrayList(tabletIds);
    :}
    ;

partition_names ::=
    KW_PARTITION LPAREN ident_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(false, partitions);  
    :}
    | KW_TEMPORARY KW_PARTITION LPAREN ident_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(true, partitions);  
    :}
    | KW_PARTITIONS LPAREN ident_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(false, partitions);  
    :}
    | KW_TEMPORARY KW_PARTITIONS LPAREN ident_list:partitions RPAREN
    {:
        RESULT = new PartitionNames(true, partitions);  
    :}
    | KW_PARTITION ident:partName
    {:
        RESULT = new PartitionNames(false, Lists.newArrayList(partName));
    :}
    | KW_TEMPORARY KW_PARTITION ident:partName
    {:
        RESULT = new PartitionNames(true, Lists.newArrayList(partName));
    :}
    ;

opt_table_sample ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | table_sample:tableSample
    {:
        RESULT = tableSample;
    :}
    ;

table_sample ::=
    KW_TABLESAMPLE LPAREN INTEGER_LITERAL:sampleValue KW_PERCENT RPAREN
    {:
        RESULT = new TableSample(true, sampleValue);
    :}
    | KW_TABLESAMPLE LPAREN INTEGER_LITERAL:sampleValue KW_ROWS RPAREN
    {:
        RESULT = new TableSample(false, sampleValue);
    :}
    | KW_TABLESAMPLE LPAREN INTEGER_LITERAL:sampleValue KW_PERCENT RPAREN KW_REPEATABLE INTEGER_LITERAL:seek
    {:
        RESULT = new TableSample(true, sampleValue, seek);
    :}
    | KW_TABLESAMPLE LPAREN INTEGER_LITERAL:sampleValue KW_ROWS RPAREN KW_REPEATABLE INTEGER_LITERAL:seek
    {:
        RESULT = new TableSample(false, sampleValue, seek);
    :}
    ;

opt_lateral_view_ref_list ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | lateral_view_ref_list:lateralViewRefList
    {:
        RESULT = lateralViewRefList;
    :}
    ;

lateral_view_ref_list ::=
    lateral_view_ref:lateralViewRef
    {:
        ArrayList<LateralViewRef> list = new ArrayList<LateralViewRef>();
        list.add(lateralViewRef);
        RESULT = list;
    :}
    |  lateral_view_ref:lateralViewRef lateral_view_ref_list:lateralViewRefList
    {:
        lateralViewRefList.add(lateralViewRef);
        RESULT = lateralViewRefList;
    :}
    ;

lateral_view_ref ::=
    KW_LATERAL KW_VIEW function_call_expr:fnExpr ident:viewName KW_AS ident:columnName
    {:
        RESULT = new LateralViewRef(fnExpr, viewName, columnName);
    :}
    ;

join_operator ::=
  opt_inner KW_JOIN
  {: RESULT = JoinOperator.INNER_JOIN; :}
  | KW_LEFT opt_outer KW_JOIN
  {: RESULT = JoinOperator.LEFT_OUTER_JOIN; :}
  | KW_RIGHT opt_outer KW_JOIN
  {: RESULT = JoinOperator.RIGHT_OUTER_JOIN; :}
  | KW_FULL opt_outer KW_JOIN
  {: RESULT = JoinOperator.FULL_OUTER_JOIN; :}
  | KW_LEFT KW_SEMI KW_JOIN
  {: RESULT = JoinOperator.LEFT_SEMI_JOIN; :}
  | KW_RIGHT KW_SEMI KW_JOIN
  {: RESULT = JoinOperator.RIGHT_SEMI_JOIN; :}
  | KW_LEFT KW_ANTI KW_JOIN
  {: RESULT = JoinOperator.LEFT_ANTI_JOIN; :}
  | KW_RIGHT KW_ANTI KW_JOIN
  {: RESULT = JoinOperator.RIGHT_ANTI_JOIN; :}
  | KW_CROSS KW_JOIN
  {: RESULT = JoinOperator.CROSS_JOIN; :}
  | KW_NATURAL KW_JOIN
  {:
      if (RESULT == null) {
          throw new AnalysisException("natural join is not supported, please use inner join instead.");
      }
  :}
  ;

opt_inner ::=
  KW_INNER
  |
  ;

opt_outer ::=
  KW_OUTER
  |
  ;

opt_plan_hints ::=
    COMMENTED_PLAN_HINTS:l
    {:
        ArrayList<String> hints = Lists.newArrayList();
        String[] tokens = l.split(",");
        for (String token: tokens) {
            String trimmedToken = token.trim();
            if (trimmedToken.length() > 0) {
                hints.add(trimmedToken);
            }
        }
        RESULT = hints;
    :}
    | COMMENTED_PLAN_HINT_START ident_list:l COMMENTED_PLAN_HINT_END
    {:
        RESULT = l;
    :}
    | LBRACKET ident_list:l RBRACKET
    {:
        RESULT = l;
    :}
    | /* empty */
    {:
        RESULT = null;
    :}
    ;

opt_sort_hints ::=
  LBRACKET ident_list:l RBRACKET
  {: RESULT = l; :}
  |
  {: RESULT = null; :}
  ;

ident_list ::=
    ident:ident
    {:
      ArrayList<String> list = new ArrayList<String>();
      list.add(ident);
      RESULT = list;
    :}
    | ident_list:list COMMA ident:ident
    {:
      list.add(ident);
      RESULT = list;
    :}
    ;

expr_list ::=
  expr:e
  {:
    ArrayList<Expr> list = new ArrayList<Expr>();
    list.add(e);
    RESULT = list;
  :}
  | expr_list:list COMMA expr:e
  {:
    list.add(e);
    RESULT = list;
  :}
  ;

where_clause ::=
   /* empty */
  {: RESULT = null; :}
  | KW_WHERE expr:e
  {: RESULT = e; :}
  ;

delete_on_clause ::=
   /* empty */
  {: RESULT = null; :}
  | KW_DELETE KW_ON expr:e
  {: RESULT = e; :}
  ;

sequence_col_clause ::=
  /* empty */
  {: RESULT = null; :}
  | KW_ORDER KW_BY ident:s
  {: RESULT = s; :}
  ;

pre_filter_clause ::=
  /* empty */
  {: RESULT = null; :}
  | KW_PRECEDING KW_FILTER expr:e
  {: RESULT = e; :}
  ;

grouping_set ::=
  LPAREN RPAREN
  {:
    ArrayList<Expr> list = Lists.newArrayList();
    RESULT = list;
  :}
  | LPAREN expr_list:l RPAREN
  {: RESULT = l; :}
  ;

grouping_set_list ::=
  grouping_set:l
  {:
    List<ArrayList<Expr>> list = Lists.newArrayList();
    list.add(l);
    RESULT = list;
  :}
  | grouping_set_list:list COMMA grouping_set:l
  {:
    list.add(l);
    RESULT = list;
  :}
  ;

grouping_elements ::=
  expr_list:l
  {:
    RESULT = new GroupByClause(l, GroupByClause.GroupingType.GROUP_BY);
  :}
  | KW_GROUPING KW_SETS LPAREN grouping_set_list:ls RPAREN
  {:
    RESULT = new GroupByClause(ls, GroupByClause.GroupingType.GROUPING_SETS);
  :}
  | KW_CUBE LPAREN expr_list:l RPAREN
  {:
    RESULT = new GroupByClause(l, GroupByClause.GroupingType.CUBE);
  :}
  | KW_ROLLUP LPAREN expr_list:l RPAREN
  {:
    RESULT = new GroupByClause(l, GroupByClause.GroupingType.ROLLUP);
  :}
  ;

group_by_clause ::=
  KW_GROUP KW_BY grouping_elements:e
  {: RESULT = e; :}
  | /* empty */
  {: RESULT = null; :}
  ;

having_clause ::=
  KW_HAVING expr:e
  {: RESULT = e; :}
  | /* empty */
  {: RESULT = null; :}
  ;

order_by_clause ::=
  KW_ORDER KW_BY order_by_elements:l
  {: RESULT = l; :}
  | /* empty */
  {: RESULT = null; :}
  ;

order_by_elements ::=
  order_by_element:e
  {:
    ArrayList<OrderByElement> list = new ArrayList<OrderByElement>();
    if (!(e.getExpr() instanceof NullLiteral)) {
        list.add(e);
    }
    RESULT = list;
  :}
  | order_by_elements:list COMMA order_by_element:e
  {:
    if (!(e.getExpr() instanceof NullLiteral)) {
        list.add(e);
    }
    RESULT = list;
  :}
  ;

order_by_element ::=
  expr:e opt_order_param:o opt_nulls_order_param:n
  {:
    if (n == null) {
      RESULT = new OrderByElement(e, o, o);
    } else {
      RESULT = new OrderByElement(e, o, n);
    }
  :}
  ;

opt_order_param ::=
  KW_ASC
  {: RESULT = true; :}
  | KW_DESC
  {: RESULT = false; :}
  | /* empty */
  {: RESULT = true; :}
  ;

opt_nulls_order_param ::=
  KW_NULLS KW_FIRST
  {: RESULT = true; :}
  | KW_NULLS KW_LAST
  {: RESULT = false; :}
  | /* empty */
  {: RESULT = null; :}
  ;

limit_clause ::=
  KW_LIMIT INTEGER_LITERAL:limit
  {: RESULT = new LimitElement(limit.longValue()); :}
  | /* empty */
  {: RESULT = LimitElement.NO_LIMIT; :}
  | KW_LIMIT INTEGER_LITERAL:offset COMMA INTEGER_LITERAL:limit
  {: RESULT = new LimitElement(offset.longValue(), limit.longValue()); :}
  | KW_LIMIT INTEGER_LITERAL:limit KW_OFFSET INTEGER_LITERAL:offset
  {: RESULT = new LimitElement(offset.longValue(), limit.longValue()); :}
  ;

type ::=
  KW_TINYINT opt_field_length
  {: RESULT = Type.TINYINT; :}
  | KW_SMALLINT opt_field_length
  {: RESULT = Type.SMALLINT; :}
  | opt_signed_unsigned KW_INT opt_field_length
  {: RESULT = Type.INT; :}
  | KW_BIGINT opt_field_length
  {: RESULT = Type.BIGINT; :}
  | KW_LARGEINT opt_field_length
  {: RESULT = Type.LARGEINT; :}
  | KW_BOOLEAN
  {: RESULT = Type.BOOLEAN; :}
  | KW_FLOAT
  {: RESULT = Type.FLOAT; :}
  | KW_DOUBLE
  {: RESULT = Type.DOUBLE; :}
  | KW_DATE
  {: RESULT = ScalarType.createDateType(); :}
  | KW_DATETIME LPAREN INTEGER_LITERAL:precision RPAREN
  {: RESULT = ScalarType.createDatetimeV2Type(precision.intValue()); :}
  | KW_DATETIME
  {: RESULT = ScalarType.createDatetimeType(); :}
  | KW_TIME LPAREN INTEGER_LITERAL:precision RPAREN
  {: RESULT = ScalarType.createTimeV2Type(precision.intValue()); :}
  | KW_TIME
  {: RESULT = ScalarType.createTimeType(); :}
  | KW_DATEV2
  {: RESULT = ScalarType.createDateV2Type(); :}
  | KW_DATETIMEV2 LPAREN INTEGER_LITERAL:precision RPAREN
  {: RESULT = ScalarType.createDatetimeV2Type(precision.intValue()); :}
  | KW_DATETIMEV2
  {: RESULT = ScalarType.createDatetimeV2Type(0); :}
  | KW_BITMAP
  {: RESULT = Type.BITMAP; :}
  | KW_QUANTILE_STATE
  {: RESULT = Type.QUANTILE_STATE; :}
  | KW_STRING
  {: RESULT = ScalarType.createStringType(); :}
  | KW_JSONB
  {: RESULT = ScalarType.createJsonbType(); :}
  | KW_TEXT
  {: RESULT = ScalarType.createStringType(); :}
  | KW_VARCHAR LPAREN INTEGER_LITERAL:len RPAREN
  {: ScalarType type = ScalarType.createVarcharType(len.intValue());
     RESULT = type;
  :}
  | KW_VARCHAR LPAREN ident_or_text:lenStr RPAREN
  {: ScalarType type = ScalarType.createVarcharType(lenStr);
     RESULT = type;
  :}
  | KW_VARCHAR
  {: RESULT = ScalarType.createVarcharType(-1); :}
  | KW_ARRAY LESSTHAN type:value_type GREATERTHAN
  {: RESULT = new ArrayType(value_type); :}
  | KW_MAP LESSTHAN type:key_type COMMA type:value_type GREATERTHAN
  {: RESULT = new MapType(key_type,value_type); :}
  | KW_STRUCT LESSTHAN struct_field_list:fields GREATERTHAN
  {: RESULT = new StructType(fields); :}
  | KW_CHAR LPAREN INTEGER_LITERAL:len RPAREN
  {: ScalarType type = ScalarType.createCharType(len.intValue());
     RESULT = type;
  :}
  | KW_CHAR LPAREN ident_or_text:lenStr RPAREN
  {: ScalarType type = ScalarType.createCharType(lenStr);
     RESULT = type;
  :}
  | KW_CHAR
  {: RESULT = ScalarType.createCharType(-1); :}
  | KW_DECIMAL LPAREN INTEGER_LITERAL:precision RPAREN
  {: RESULT = ScalarType.createDecimalType(precision.intValue()); :}
  | KW_DECIMAL LPAREN INTEGER_LITERAL:precision COMMA INTEGER_LITERAL:scale RPAREN
  {: RESULT = ScalarType.createDecimalType(precision.intValue(), scale.intValue()); :}
  | KW_DECIMAL
  {: RESULT = ScalarType.createDecimalType(); :}
  | KW_DECIMAL LPAREN ident_or_text:precision RPAREN
  {: RESULT = ScalarType.createDecimalType(precision); :}
  | KW_DECIMAL LPAREN ident_or_text:precision COMMA ident_or_text:scale RPAREN
  {: RESULT = ScalarType.createDecimalType(precision, scale); :}
  | KW_DECIMALV3 LPAREN INTEGER_LITERAL:precision RPAREN
  {: RESULT = ScalarType.createDecimalV3Type(precision.intValue()); :}
  | KW_DECIMALV3 LPAREN INTEGER_LITERAL:precision COMMA INTEGER_LITERAL:scale RPAREN
  {: RESULT = ScalarType.createDecimalV3Type(precision.intValue(), scale.intValue()); :}
  | KW_DECIMALV3
  {: RESULT = ScalarType.createDecimalV3Type(); :}
  | KW_DECIMALV3 LPAREN ident_or_text:precision RPAREN
  {: RESULT = ScalarType.createDecimalV3Type(precision); :}
  | KW_DECIMALV3 LPAREN ident_or_text:precision COMMA ident_or_text:scale RPAREN
  {: RESULT = ScalarType.createDecimalV3Type(precision, scale); :}
  | KW_HLL
  {: ScalarType type = ScalarType.createHllType();
     RESULT = type;
  :}
  | KW_ALL
  {: RESULT = Type.ALL; :}
  ;

opt_field_length ::=
  LPAREN INTEGER_LITERAL:length RPAREN
  {: RESULT = length; :}
  |
  {: RESULT = null; :}
  ;

// signed and unsigned is meaningless for Doris.
// This is just for MySQL compatibility now.
opt_signed_unsigned ::=
  /* empty */
  {: RESULT = true; :}
  | KW_SIGNED
  {: RESULT = true; :}
  | KW_UNSIGNED
  {: RESULT = false; :}
  ;

type_def ::=
  type:t
  {: RESULT = new TypeDef(t); :}
  ;

type_def_list ::=
  type_def:typeDef
  {:
    RESULT = Lists.newArrayList(typeDef);
  :}
  | type_def_list:types COMMA type_def:typeDef
  {:
    types.add(typeDef);
    RESULT = types;
  :}
  ;

func_args_def ::=
  type_def_list:argTypes
  {:
    RESULT = new FunctionArgsDef(argTypes, false);
  :}
  | DOTDOTDOT
  {:
    RESULT = new FunctionArgsDef(Lists.newArrayList(), true);
  :}
  | type_def_list:argTypes COMMA DOTDOTDOT
  {:
    RESULT = new FunctionArgsDef(argTypes, true);
  :}
  ;

cast_expr ::=
  KW_CAST LPAREN expr:e KW_AS type_def:targetType RPAREN
  {: 
    CastExpr castExpr = new CastExpr(targetType, e); 
    if (targetType.getType().getLength() != -1
        && (targetType.getType().getPrimitiveType() == PrimitiveType.VARCHAR 
        || targetType.getType().getPrimitiveType() == PrimitiveType.CHAR)) {
        // transfer cast(xx as char(N)/varchar(N)) to substr(cast(xx as char), 1, N)
        // this is just a workaround to make the result correct
        ArrayList<Expr> exprs = new ArrayList<>();
        exprs.add(castExpr);
        exprs.add(new IntLiteral(1));
        exprs.add(new IntLiteral(targetType.getType().getLength()));
        RESULT = new FunctionCallExpr("substr", new FunctionParams(exprs));
    }
    else {
        RESULT = castExpr;
    }
  :}
  ;

case_expr ::=
  KW_CASE expr:caseExpr
    case_when_clause_list:whenClauseList
    case_else_clause:elseExpr
    KW_END
  {: RESULT = new CaseExpr(caseExpr, whenClauseList, elseExpr); :}
  | KW_CASE
    case_when_clause_list:whenClauseList
    case_else_clause:elseExpr
    KW_END
  {: RESULT = new CaseExpr(null, whenClauseList, elseExpr); :}
  ;

case_when_clause_list ::=
  KW_WHEN expr:whenExpr KW_THEN expr:thenExpr
  {:
    ArrayList<CaseWhenClause> list = new ArrayList<CaseWhenClause>();
    list.add(new CaseWhenClause(whenExpr, thenExpr));
    RESULT = list;
  :}
  | case_when_clause_list:list KW_WHEN expr:whenExpr
    KW_THEN expr:thenExpr
  {:
    list.add(new CaseWhenClause(whenExpr, thenExpr));
    RESULT = list;
  :}
  ;

case_else_clause ::=
  KW_ELSE expr:e
  {: RESULT = e; :}
  | /* emtpy */
  {: RESULT = null; :}
  ;

sign_chain_expr ::=
  SUBTRACT expr:e
  {:
    // integrate signs into literals
    if (e.isLiteral() && e.getType().isNumericType()) {
      ((LiteralExpr)e).swapSign();
      RESULT = e;
    } else {
      RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.MULTIPLY, new IntLiteral((long)-1), e);
    }
  :}
  | ADD expr:e
  {: RESULT = e; :}
  ;

expr ::=
  non_pred_expr:e opt_collate:collate
  {: RESULT = e; :}
  | predicate:p
  {: RESULT = p; :}
  ;

function_call_expr ::=
  function_name:fn_name LPAREN RPAREN
  {: RESULT = new FunctionCallExpr(fn_name, new ArrayList<Expr>()); :}
  | KW_ADD LPAREN function_params:params RPAREN
  {: RESULT = new FunctionCallExpr("add", params); :}
  | function_name:fn_name LPAREN function_params:params RPAREN
  {:
    if ("grouping".equalsIgnoreCase(fn_name.getFunction())) {
      if (params.exprs().size() > 1) {
        throw new AnalysisException("GROUPING requires exactly one column parameter.");
      }
      RESULT = new GroupingFunctionCallExpr(fn_name, params);
    } else if ("grouping_id".equalsIgnoreCase(fn_name.getFunction())) {
      RESULT = new GroupingFunctionCallExpr(fn_name, params);
    } else {
      RESULT = new FunctionCallExpr(fn_name, params);
    }
  :}
  ;

array_literal ::=
  LBRACKET RBRACKET
  {:
    RESULT = new ArrayLiteral();
  :}
  | LBRACKET expr_list:list RBRACKET
  {:
    RESULT = new ArrayLiteral(list.toArray(new LiteralExpr[0]));
  :}
  ;

array_expr ::=
  KW_ARRAY LPAREN function_params:params RPAREN
  {:
    RESULT = new FunctionCallExpr("array", params);
  :}
  | KW_ARRAY LPAREN RPAREN
  {:
    RESULT = new ArrayLiteral();
  :}
  ;

struct_field ::=
  ident:name COLON type:type
  {: RESULT = new StructField(name, type); :}
  ;

struct_field_list ::=
    struct_field:field
    {:
      RESULT = Lists.newArrayList(field);
    :}
    | struct_field_list:fields COMMA struct_field:field
    {:
       fields.add(field);
       RESULT = fields;
    :}
    ;

exists_predicate ::=
  KW_EXISTS subquery:s
  {: RESULT = new ExistsPredicate(s, false); :}
  ;

non_pred_expr ::=
  sign_chain_expr:e
  {: RESULT = e; :}
  | AT AT ident:l
  {:
    RESULT = new SysVariableDesc(l);
  :}
  | AT AT var_ident_type:type ident:l
  {:
    RESULT = new SysVariableDesc(l, type);
  :}
  | literal:l
  {: RESULT = l; :}
  | array_expr:a
  {: RESULT = a; :}
  | array_literal:a
  {: RESULT = a; :}
  | function_call_expr:e
  {: RESULT = e; :}
  | KW_DATE STRING_LITERAL:l
  {: RESULT = new StringLiteral(l); :}
  | KW_DATEV2 STRING_LITERAL:l
  {: RESULT = new StringLiteral(l); :}
  | KW_TIMESTAMP STRING_LITERAL:l
  {: RESULT = new StringLiteral(l); :}
  | KW_EXTRACT LPAREN function_name:fn_name KW_FROM func_arg_list:exprs RPAREN
  {: RESULT = new FunctionCallExpr(fn_name, exprs); :}
  //| function_name:fn_name LPAREN RPAREN
  //{: RESULT = new FunctionCallExpr(fn_name, new ArrayList<Expr>()); :}
  | function_name:fn_name LPAREN function_params:params order_by_clause:o RPAREN
  {: RESULT = new FunctionCallExpr(fn_name, params, o); :}
  | analytic_expr:e
  {: RESULT = e; :}
  /* Since "IF" is a keyword, need to special case this function */
  | KW_IF LPAREN expr_list:exprs RPAREN
  {: RESULT = new FunctionCallExpr("if", exprs); :}
  /* For the case like e1 || e2 || e3 ... */
  | expr_pipe_list:exprs
  {:
    RESULT = new FunctionCallExpr("concat", exprs);
  :}
  | cast_expr:c
  {: RESULT = c; :}
  | case_expr:c
  {: RESULT = c; :}
  | column_ref:c
  {: RESULT = c; :}
  | column_subscript:c
  {: RESULT = c; :}
  | column_slice:c
  {: RESULT = c; :}
  | timestamp_arithmetic_expr:e
  {: RESULT = e; :}
  | arithmetic_expr:e
  {: RESULT = e; :}
  | LPAREN non_pred_expr:e RPAREN
  {:
    e.setPrintSqlInParens(true);
    RESULT = e;
  :}
  /* TODO(zc): add other trim function */
  | KW_TRIM:id LPAREN function_params:params RPAREN
  {: RESULT = new FunctionCallExpr(new FunctionName(null, id), params); :}
  | KW_DATABASE LPAREN RPAREN
  {: RESULT = new InformationFunction("DATABASE"); :}
  | KW_SCHEMA LPAREN RPAREN
  {: RESULT = new InformationFunction("SCHEMA"); :}
  | KW_USER LPAREN RPAREN
  {: RESULT = new InformationFunction("USER"); :}
  | KW_CURRENT_USER LPAREN RPAREN
  {: RESULT = new InformationFunction("CURRENT_USER"); :}
  | KW_CONNECTION_ID LPAREN RPAREN
  {: RESULT = new InformationFunction("CONNECTION_ID"); :}
  | KW_PASSWORD LPAREN STRING_LITERAL:text RPAREN
  {:
    RESULT = new StringLiteral(new String(MysqlPassword.makeScrambledPassword(text)));
  :}
  | subquery:s
  {: RESULT = s; :}
  |  KW_NULL KW_IS KW_NULL
  {: RESULT = new BoolLiteral(true); :}
  | KW_NULL KW_IS KW_NOT KW_NULL
  {: RESULT = new BoolLiteral(false); :}
  | KW_CONVERT LPAREN expr:e COMMA type_def:targetType RPAREN
  {: RESULT = new CastExpr(targetType, e); :}
  | KW_KEY encryptkey_name:name
  {: RESULT = new EncryptKeyRef(name); :}
  | KW_CONVERT LPAREN expr:e KW_USING ident:character RPAREN
  {: 
    ArrayList<Expr> exprs = new ArrayList<>();
    exprs.add(e);
    exprs.add(new StringLiteral(character));
    RESULT = new FunctionCallExpr("convert_to", new FunctionParams(exprs)); 
  :}
  ;

expr_pipe_list ::=
  expr:e1 KW_PIPE expr:e2
  {:
    ArrayList<Expr> list = new ArrayList<Expr>();
    list.add(e1);
    list.add(e2);
    RESULT = list;
  :}
  | expr_pipe_list:list KW_PIPE expr:e
  {:
    list.add(e);
    RESULT = list;
  :}
  ;

func_arg_list ::=
  expr:item
  {:
    ArrayList<Expr> list = new ArrayList<Expr>();
    list.add(item);
    RESULT = list;
  :}
  | func_arg_list:list COMMA expr:item
  {:
    list.add(item);
    RESULT = list;
  :}
  ;

analytic_expr ::=
  function_call_expr:e KW_OVER LPAREN opt_partition_by_clause:p order_by_clause:o opt_window_clause:w RPAREN
  {:
    // Handle cases where function_call_expr resulted in a plain Expr
    if (!(e instanceof FunctionCallExpr)) {
      parser.parseError("over", SqlParserSymbols.KW_OVER);
    }
    FunctionCallExpr f = (FunctionCallExpr)e;
    f.setIsAnalyticFnCall(true);
    RESULT = new AnalyticExpr(f, p, o, w);
  :}
  %prec KW_OVER
  ;

opt_partition_by_clause ::=
  KW_PARTITION KW_BY expr_list:l
  {: RESULT = l; :}
  | /* empty */
  {: RESULT = null; :}
  ;

opt_window_clause ::=
  window_type:t window_boundary:b
  {: RESULT = new AnalyticWindow(t, b); :}
  | window_type:t KW_BETWEEN window_boundary:l KW_AND window_boundary:r
  {: RESULT = new AnalyticWindow(t, l, r); :}
  | /* empty */
  {: RESULT = null; :}
  ;

window_type ::=
  KW_ROWS
  {: RESULT = AnalyticWindow.Type.ROWS; :}
  | KW_RANGE
  {: RESULT = AnalyticWindow.Type.RANGE; :}
  ;

window_boundary ::=
  KW_UNBOUNDED KW_PRECEDING
  {:
    RESULT = new AnalyticWindow.Boundary(
        AnalyticWindow.BoundaryType.UNBOUNDED_PRECEDING, null);
  :}
  | KW_UNBOUNDED KW_FOLLOWING
  {:
    RESULT = new AnalyticWindow.Boundary(
        AnalyticWindow.BoundaryType.UNBOUNDED_FOLLOWING, null);
  :}
  | KW_CURRENT KW_ROW
  {:
    RESULT = new AnalyticWindow.Boundary(AnalyticWindow.BoundaryType.CURRENT_ROW, null);
  :}
  | expr:e KW_PRECEDING
  {: RESULT = new AnalyticWindow.Boundary(AnalyticWindow.BoundaryType.PRECEDING, e); :}
  | expr:e KW_FOLLOWING
  {: RESULT = new AnalyticWindow.Boundary(AnalyticWindow.BoundaryType.FOLLOWING, e); :}
  ;

arithmetic_expr ::=
  expr:e1 STAR expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.MULTIPLY, e1, e2); :}
  | expr:e1 DIVIDE expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.DIVIDE, e1, e2); :}
  | expr:e1 MOD expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.MOD, e1, e2); :}
  | expr:e1 KW_DIV expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.INT_DIVIDE, e1, e2); :}
  | expr:e1 ADD expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.ADD, e1, e2); :}
  | expr:e1 SUBTRACT expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.SUBTRACT, e1, e2); :}
  | expr:e1 BITAND expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.BITAND, e1, e2); :}
  | expr:e1 BITOR expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.BITOR, e1, e2); :}
  | expr:e1 BITXOR expr:e2
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.BITXOR, e1, e2); :}
  | BITNOT expr:e
  {: RESULT = new ArithmeticExpr(ArithmeticExpr.Operator.BITNOT, e, null); :}
  ;

// We use IDENT for the temporal unit to avoid making DAY, YEAR, etc. keywords.
// This way we do not need to change existing uses of IDENT.
// We chose not to make DATE_ADD and DATE_SUB keywords for the same reason.
timestamp_arithmetic_expr ::=
  KW_INTERVAL expr:v ident:u ADD expr:t
  {: RESULT = new TimestampArithmeticExpr(ArithmeticExpr.Operator.ADD, t, v, u, true); :}
  | expr:t ADD KW_INTERVAL expr:v ident:u
  {:
    RESULT = new TimestampArithmeticExpr(ArithmeticExpr.Operator.ADD, t, v, u, false);
  :}
  // Set precedence to KW_INTERVAL (which is higher than ADD) for chaining.
  %prec KW_INTERVAL
  | expr:t SUBTRACT KW_INTERVAL expr:v ident:u
  {:
    RESULT =
        new TimestampArithmeticExpr(ArithmeticExpr.Operator.SUBTRACT, t, v, u, false);
  :}
  // Set precedence to KW_INTERVAL (which is higher than ADD) for chaining.
  %prec KW_INTERVAL
  // Timestamp arithmetic expr that looks like a function call.
  // We use func_arg_list instead of expr to avoid a shift/reduce conflict with
  // func_arg_list on COMMA, and report an error if the list contains more than one expr.
  // Although we don't want to accept function names as the expr, we can't parse it
  // it as just an IDENT due to the precedence conflict with function_name.
  | function_name:functionName LPAREN expr_list:l COMMA
    KW_INTERVAL expr:v ident:u RPAREN
  {:
    if (l.size() > 1) {
      // Report parsing failure on keyword interval.
      parser.parseError("interval", SqlParserSymbols.KW_INTERVAL);
    }
    if (functionName.getDb() != null) {
      // This function should not fully qualified
      throw new Exception("interval should not be qualified by database name");
    }

    RESULT = new TimestampArithmeticExpr(functionName.getFunction(), l.get(0), v, u);
  :}
  | function_name:functionName LPAREN time_unit:u COMMA expr:e1 COMMA expr:e2 RPAREN
  {:
    RESULT = new TimestampArithmeticExpr(functionName.getFunction(), e2, e1, u);
  :}
  ;

literal ::=
  INTEGER_LITERAL:l
  {: RESULT = new IntLiteral(l); :}
  | LARGE_INTEGER_LITERAL:l
  {: RESULT = new LargeIntLiteral(l); :}
  | FLOATINGPOINT_LITERAL:l
  {: RESULT = new FloatLiteral(l); :}
  | DECIMAL_LITERAL:l
  {: RESULT = new DecimalLiteral(l); :}
  | STRING_LITERAL:l
  {: RESULT = new StringLiteral(l); :}
  | KW_TRUE
  {: RESULT = new BoolLiteral(true); :}
  | KW_FALSE
  {: RESULT = new BoolLiteral(false); :}
  | KW_NULL
  {: RESULT = new NullLiteral(); :}
  | UNMATCHED_STRING_LITERAL:l expr:e
  {:
    // we have an unmatched string literal.
    // to correctly report the root cause of this syntax error
    // we must force parsing to fail at this point,
    // and generate an unmatched string literal symbol
    // to be passed as the last seen token in the
    // error handling routine (otherwise some other token could be reported)
    parser.parseError("literal", SqlParserSymbols.UNMATCHED_STRING_LITERAL);
  :}
  | NUMERIC_OVERFLOW:l
  {:
    // similar to the unmatched string literal case
    // we must terminate parsing at this point
    // and generate a corresponding symbol to be reported
    parser.parseError("literal", SqlParserSymbols.NUMERIC_OVERFLOW);
  :}
  ;

function_params ::=
  STAR
  {: RESULT = FunctionParams.createStarParam(); :}
  | KW_ALL STAR
  {: RESULT = FunctionParams.createStarParam(); :}
  | expr_list:exprs
  {: RESULT = new FunctionParams(false, exprs); :}
  | KW_ALL expr_list:exprs
  {: RESULT = new FunctionParams(false, exprs); :}
  | KW_DISTINCT:distinct expr_list:exprs
  {: RESULT = new FunctionParams(true, exprs); :}
  ;

predicate ::=
  expr:e KW_IS KW_NULL
  {: RESULT = new IsNullPredicate(e, false); :}
  | KW_ISNULL LPAREN expr:e RPAREN
  {: RESULT = new IsNullPredicate(e, false); :}
  | expr:e KW_IS KW_NOT KW_NULL
  {: RESULT = new IsNullPredicate(e, true); :}
  | between_predicate:p
  {: RESULT = p; :}
  | comparison_predicate:p
  {: RESULT = p; :}
  | compound_predicate:p
  {: RESULT = p; :}
  | in_predicate:p
  {: RESULT = p; :}
  | exists_predicate:p
  {: RESULT = p; :}
  | like_predicate:p
  {: RESULT = p; :}
  | LPAREN predicate:p RPAREN
  {:
    p.setPrintSqlInParens(true);
    RESULT = p;
  :}
  ;

comparison_predicate ::=
  expr:e1 EQUAL:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.EQ, e1, e2); :}
  | expr:e1 NOT EQUAL:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.NE, e1, e2); :}
  | expr:e1 LESSTHAN GREATERTHAN:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.NE, e1, e2); :}
  | expr:e1 LESSTHAN EQUAL:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.LE, e1, e2); :}
  | expr:e1 GREATERTHAN EQUAL:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.GE, e1, e2); :}
  | expr:e1 LESSTHAN:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.LT, e1, e2); :}
  | expr:e1 GREATERTHAN:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.GT, e1, e2); :}
  | expr:e1 LESSTHAN EQUAL GREATERTHAN:op expr:e2
  {: RESULT = new BinaryPredicate(BinaryPredicate.Operator.EQ_FOR_NULL, e1, e2); :}
  ;

like_predicate ::=
  expr:e1 KW_LIKE expr:e2
  {: RESULT = new LikePredicate(LikePredicate.Operator.LIKE, e1, e2); :}
  | expr:e1 KW_REGEXP expr:e2
  {: RESULT = new LikePredicate(LikePredicate.Operator.REGEXP, e1, e2); :}
  | expr:e1 KW_NOT KW_LIKE expr:e2
  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.NOT,
    new LikePredicate(LikePredicate.Operator.LIKE, e1, e2), null); :}
  | expr:e1 KW_NOT KW_REGEXP expr:e2
  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.NOT,
    new LikePredicate(LikePredicate.Operator.REGEXP, e1, e2), null); :}
  ;

// Avoid a reduce/reduce conflict with compound_predicate by explicitly
// using non_pred_expr and predicate separately instead of expr.
between_predicate ::=
  expr:e1 KW_BETWEEN non_pred_expr:e2 KW_AND expr:e3
  {: RESULT = new BetweenPredicate(e1, e2, e3, false); :}
  | expr:e1 KW_BETWEEN predicate:e2 KW_AND expr:e3
  {: RESULT = new BetweenPredicate(e1, e2, e3, false); :}
  | expr:e1 KW_NOT KW_BETWEEN non_pred_expr:e2 KW_AND expr:e3
  {: RESULT = new BetweenPredicate(e1, e2, e3, true); :}
  | expr:e1 KW_NOT KW_BETWEEN predicate:e2 KW_AND expr:e3
  {: RESULT = new BetweenPredicate(e1, e2, e3, true); :}
  ;

in_predicate ::=
  expr:e KW_IN LPAREN expr_list:l RPAREN
  {: RESULT = new InPredicate(e, l, false); :}
  | expr:e KW_NOT KW_IN LPAREN expr_list:l RPAREN
  {: RESULT = new InPredicate(e, l, true); :}
  | expr:e KW_IN subquery:s
  {: RESULT = new InPredicate(e, s, false); :}
  | expr:e KW_NOT KW_IN subquery:s
  {: RESULT = new InPredicate(e, s, true); :}
  ;

subquery ::=
  LPAREN subquery:query RPAREN
  {: RESULT = query; :}
  | LPAREN query_stmt:query RPAREN
  {: RESULT = new Subquery(query); :}
  ;

compound_predicate ::=
  expr:e1 KW_AND expr:e2
  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.AND, e1, e2); :}
  | expr:e1 KW_OR expr:e2
  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.OR, e1, e2); :}
  | KW_NOT expr:e
  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.NOT, e, null); :}
  | NOT expr:e
  {: RESULT = new CompoundPredicate(CompoundPredicate.Operator.NOT, e, null); :}
  ;

column_ref ::=
  ident:col
  {: RESULT = new SlotRef(null, col); :}
  // table_name:tblName DOT IDENT:col causes reduce/reduce conflicts
  | ident:tbl DOT ident:col
  {: RESULT = new SlotRef(new TableName(null, null, tbl), col); :}
  | ident:db DOT ident:tbl DOT ident:col
  {: RESULT = new SlotRef(new TableName(null, db, tbl), col); :}
  | ident:ctl DOT ident:db DOT ident:tbl DOT ident:col
  {: RESULT = new SlotRef(new TableName(ctl, db, tbl), col); :}
  ;

column_ref_list ::=
  column_ref:ref
  {:
    ArrayList<SlotRef> refs = new ArrayList<SlotRef>();
    refs.add(ref);
    RESULT = refs;
  :}
  | column_ref_list:list COMMA column_ref:ref
  {:
    list.add(ref);
    RESULT = list;
  :}
  ;

column_subscript ::=
  expr:e LBRACKET expr:index RBRACKET
  {: ArrayList<Expr> list = new ArrayList<Expr>();
     list.add(e);
     list.add(index);
     RESULT = new FunctionCallExpr("%element_extract%", list);
  :}
  ;

column_slice ::=
  expr:e LBRACKET expr:offset COLON RBRACKET
  {: ArrayList<Expr> list = new ArrayList<Expr>();
       list.add(e);
       list.add(offset);
       RESULT = new FunctionCallExpr("%element_slice%", list);
  :}
  | expr:e LBRACKET expr:offset COLON expr:length RBRACKET
  {: ArrayList<Expr> list = new ArrayList<Expr>();
     list.add(e);
     list.add(offset);
     list.add(length);
     RESULT = new FunctionCallExpr("%element_slice%", list);
  :}
  ;

privilege_type ::=
    ident:name
    {:
        RESULT = AccessPrivilege.fromName(name);
        if (RESULT == null) {
            throw new AnalysisException("Unknown privilege type " + name);
        }
    :}
    | KW_ALL:id
    {:
        RESULT = AccessPrivilege.ALL;
    :}
    ;

privilege_list ::=
    privilege_list:l COMMA privilege_type:priv
    {:
        l.add(priv);
        RESULT = l;
    :}
    | privilege_type:priv
    {:
        RESULT = Lists.newArrayList(priv);
    :}
    ;

string_list ::=
    string_list:l COMMA STRING_LITERAL:item
    {:
        l.add(item);
        RESULT = l;
    :}
    | STRING_LITERAL:item
    {:
        RESULT = Lists.newArrayList(item);
    :}
    ;

integer_list ::=
    integer_list:l COMMA INTEGER_LITERAL:item
    {:
        l.add(item);
        RESULT = l;
    :}
    | INTEGER_LITERAL:item
    {:
        RESULT = Lists.newArrayList(item);
    :}
    ;

admin_stmt ::=
    KW_ADMIN KW_SHOW KW_REPLICA KW_STATUS KW_FROM base_table_ref:table_ref opt_wild_where
    {:
        RESULT = new AdminShowReplicaStatusStmt(table_ref, parser.where);
    :}
    | KW_ADMIN KW_SHOW KW_REPLICA KW_DISTRIBUTION KW_FROM base_table_ref:table_ref
    {:
        RESULT = new AdminShowReplicaDistributionStmt(table_ref);
    :}
    | KW_ADMIN KW_SET KW_REPLICA KW_STATUS KW_PROPERTIES LPAREN key_value_map:prop RPAREN
    {:
        RESULT = new AdminSetReplicaStatusStmt(prop);
    :}
    | KW_ADMIN KW_REPAIR KW_TABLE base_table_ref:table_ref
    {:
        RESULT = new AdminRepairTableStmt(table_ref);
    :}
    | KW_ADMIN KW_CANCEL KW_REPAIR KW_TABLE base_table_ref:table_ref
    {:
        RESULT = new AdminCancelRepairTableStmt(table_ref);
    :}
    | KW_ADMIN KW_COMPACT KW_TABLE base_table_ref:table_ref opt_wild_where
    {:
        RESULT = new AdminCompactTableStmt(table_ref, parser.where);
    :}
    | KW_ADMIN KW_SET KW_FRONTEND KW_CONFIG opt_key_value_map:configs
    {:
        RESULT = new AdminSetConfigStmt(AdminSetConfigStmt.ConfigType.FRONTEND, configs);
    :}
    | KW_ADMIN KW_SHOW KW_FRONTEND KW_CONFIG opt_wild_where
    {:
        RESULT = new AdminShowConfigStmt(AdminSetConfigStmt.ConfigType.FRONTEND, parser.wild);
    :}
    | KW_ADMIN KW_CHECK KW_TABLET LPAREN integer_list:tabletIds RPAREN opt_properties:properties
    {:
        RESULT = new AdminCheckTabletsStmt(tabletIds, properties);
    :}
    | KW_ADMIN KW_REBALANCE KW_DISK KW_ON LPAREN string_list:backends RPAREN
    {:
        RESULT = new AdminRebalanceDiskStmt(backends);
    :}
    | KW_ADMIN KW_REBALANCE KW_DISK
    {:
        RESULT = new AdminRebalanceDiskStmt(null);
    :}
    | KW_ADMIN KW_CANCEL KW_REBALANCE KW_DISK KW_ON LPAREN string_list:backends RPAREN
    {:
        RESULT = new AdminCancelRebalanceDiskStmt(backends);
    :}
    | KW_ADMIN KW_CANCEL KW_REBALANCE KW_DISK
    {:
        RESULT = new AdminCancelRebalanceDiskStmt(null);
    :}
    | KW_ADMIN KW_CLEAN KW_TRASH KW_ON LPAREN string_list:backends RPAREN
    {:
        RESULT = new AdminCleanTrashStmt(backends);
    :}
    | KW_ADMIN KW_CLEAN KW_TRASH
    {:
        RESULT = new AdminCleanTrashStmt(null);
    :}
    | KW_ADMIN KW_DIAGNOSE KW_TABLET INTEGER_LITERAL:tabletId
    {:
        RESULT = new AdminDiagnoseTabletStmt(tabletId);
    :}
    | KW_ADMIN KW_SHOW KW_TABLET KW_STORAGE KW_FORMAT
    {:
        RESULT = new AdminShowTabletStorageFormatStmt(false);
    :}
    | KW_ADMIN KW_SHOW KW_TABLET KW_STORAGE KW_FORMAT KW_VERBOSE
    {:
        RESULT = new AdminShowTabletStorageFormatStmt(true);
    :}
    | KW_ADMIN KW_COPY KW_TABLET INTEGER_LITERAL:tabletId opt_properties:properties
    {:
        RESULT = new AdminCopyTabletStmt(tabletId, properties);
    :}
    ;

truncate_stmt ::=
    KW_TRUNCATE KW_TABLE base_table_ref:tblRef
    {:
        RESULT = new TruncateTableStmt(tblRef);
    :}
    ;

transaction_stmt ::=
    KW_BEGIN
    {:
        RESULT = new TransactionBeginStmt();
    :}
    | KW_BEGIN KW_WITH KW_LABEL transaction_label:label
    {:
        RESULT = new TransactionBeginStmt(label);
    :}
    | KW_COMMIT opt_work opt_chain opt_release
    {:
        RESULT = new TransactionCommitStmt();
    :}
    | KW_ROLLBACK opt_work opt_chain opt_release
    {:
        RESULT = new TransactionRollbackStmt();
    :}
    ;

transaction_label ::=
    /* empty */
    {:
        RESULT = null;
    :}
    | ident:label
    {:
        RESULT = label;
    :}
    ;

unsupported_stmt ::=
    KW_START KW_TRANSACTION opt_with_consistent_snapshot:v
    {:
        RESULT = new UnsupportedStmt();
    :}
    ;

opt_with_consistent_snapshot ::=
    {:
        RESULT = null;
    :}
    | KW_WITH KW_CONSISTENT KW_SNAPSHOT
    {:
        RESULT = null;
    :}
    ;

opt_work ::=
    {:
        RESULT = null;
    :}
    | KW_WORK
    {:
        RESULT = null;
    :}
    ;

opt_chain ::=
    {:
        RESULT = null;
    :}
    | KW_AND KW_NO KW_CHAIN
    {:
        RESULT = null;
    :}
    | KW_AND KW_CHAIN
    {:
        RESULT = null;
    :}
    ;

opt_release ::=
    {:
        RESULT = null;
    :}
    | KW_RELEASE
    {:
        RESULT = null;
    :}
    | KW_NO KW_RELEASE
    {:
        RESULT = null;
    :}
    ;

type_func_name_keyword ::=
    KW_LEFT:id
    {: RESULT = id; :}
    | KW_RIGHT:id
    {: RESULT = id; :}
    ;

// Keyword that we allow for identifiers
keyword ::=
    KW_AFTER:id
    {: RESULT = id; :}
    | KW_AGGREGATE:id
    {: RESULT = id; :}
    | KW_ALIAS:id
    {: RESULT = id; :}
    | KW_AUTHORS:id
    {: RESULT = id; :}
    | KW_ARRAY:id
    {: RESULT = id; :}
    | KW_BACKUP:id
    {: RESULT = id; :}
    | KW_BEGIN:id
    {: RESULT = id; :}
    | KW_BIN:id
    {: RESULT = id; :}
    | KW_BITMAP:id
    {: RESULT = id; :}
    | KW_QUANTILE_STATE:id
    {: RESULT = id; :}
    | KW_BITMAP_UNION:id
    {: RESULT = id; :}
    | KW_QUANTILE_UNION:id
    {: RESULT = id; :}
    | KW_BLOB:id
    {: RESULT = id; :}
    | KW_BOOLEAN:id
    {: RESULT = id; :}
    | KW_BROKER:id
    {: RESULT = id; :}
    | KW_S3:id
    {: RESULT = id; :}
    | KW_HDFS:id
    {: RESULT = id; :}
    | KW_BACKENDS:id
    {: RESULT = id; :}
    | KW_BUILTIN:id
    {: RESULT = id; :}
    | KW_BUILD:id
    {: RESULT = id; :}
    | KW_CHAIN:id
    {: RESULT = id; :}
    | KW_CHAR:id
    {: RESULT = id; :}
    | KW_CHARSET:id
    {: RESULT = id; :}
    | KW_CHECK:id
    {: RESULT = id; :}
    | KW_COLUMNS:id
    {: RESULT = id; :}
    | KW_COMMENT:id
    {: RESULT = id; :}
    | KW_COMMITTED:id
    {: RESULT = id; :}
    | KW_COMPLETE:id
    {: RESULT = id; :}
    | KW_CONSISTENT:id
    {: RESULT = id; :}
    | KW_COLLATION:id
    {: RESULT = id; :}
    | KW_COMMIT:id
    {: RESULT = id; :}
    | KW_COMPACT:id
    {: RESULT = id; :}
    | KW_CONFIG:id
    {: RESULT = id; :}
    | KW_CONNECTION:id
    {: RESULT = id; :}
    | KW_CONNECTION_ID:id
    {: RESULT = id; :}
    | KW_CONVERT:id
    {: RESULT = id; :}
    | KW_COPY:id
    {: RESULT = id; :}
    | KW_CREATION:id
    {: RESULT = id; :}
    | KW_DATA:id
    {: RESULT = id; :}
    | KW_DATE:id
    {: RESULT = id; :}
    | KW_DATETIME:id
    {: RESULT = id; :}
    | KW_DATEV2:id
    {: RESULT = id; :}
    | KW_DATETIMEV2:id
    {: RESULT = id; :}
    | KW_DECIMAL:id
    {: RESULT = id; :}
    | KW_DEFERRED:id
    {: RESULT = id; :}
    | KW_DEMAND:id
    {: RESULT = id; :}
    | KW_DECIMALV3:id
    {: RESULT = id; :}
    | KW_DIAGNOSE:id
    {: RESULT = id; :}
    | KW_DISTINCTPC:id
    {: RESULT = id; :}
    | KW_DISTINCTPCSA:id
    {: RESULT = id; :}
    | KW_BUCKETS:id
    {: RESULT = id; :}
    | KW_FAST:id
    {: RESULT = id; :}
    | KW_FAILED_LOGIN_ATTEMPTS:id
    {: RESULT = id; :}
    | KW_FILE:id
    {: RESULT = id; :}
    | KW_FIELDS:id
    {: RESULT = id; :}
    | KW_FILTER:id
    {: RESULT = id; :}
    | KW_FIRST:id
    {: RESULT = id; :}
    | KW_FORMAT:id
    {: RESULT = id; :}
    | KW_HLL_UNION:id
    {: RESULT = id; :}
    | KW_IMMEDIATE:id
    {: RESULT = id; :}
    | KW_PATH:id
    {: RESULT = id; :}
    | KW_PROFILE:id
    {: RESULT = id; :}
    | KW_FUNCTION:id
    {: RESULT = id; :}
    | KW_END:id
    {: RESULT = id; :}
    | KW_ENGINE:id
    {: RESULT = id; :}
    | KW_ENGINES:id
    {: RESULT = id; :}
    | KW_ERRORS:id
    {: RESULT = id; :}
    | KW_EXCLUDE:id
    {: RESULT = id; :}
    | KW_EVENTS:id
    {: RESULT = id; :}
    | KW_EXTERNAL:id
    {: RESULT = id; :}
    | KW_GLOBAL:id
    {: RESULT = id; :}
    | KW_GRAPH:id
    {: RESULT = id; :}
    | KW_HASH:id
    {: RESULT = id; :}
    | KW_HELP:id
    {: RESULT = id; :}
    | KW_HUB:id
    {: RESULT = id; :}
    | KW_IDENTIFIED:id
    {: RESULT = id; :}
    | KW_INDEXES:id
    {: RESULT = id; :}
    | KW_INVERTED:id
    {: RESULT = id; :}
    | KW_ISNULL:id
    {: RESULT = id; :}
    | KW_ISOLATION:id
    {: RESULT = id; :}
    | KW_JOB:id
    {: RESULT = id; :}
    | KW_JSONB:id
    {: RESULT = id; :}
    | KW_ENCRYPTKEY:id
    {: RESULT = id; :}
    | KW_ENCRYPTKEYS:id
    {: RESULT = id; :}
    | KW_LABEL:id
    {: RESULT = id; :}
    | KW_LAST:id
    {: RESULT = id; :}
    | KW_LESS:id
    {: RESULT = id; :}
    | KW_LEVEL:id
    {: RESULT = id; :}
    | KW_LOCAL:id
    {: RESULT = id; :}
    | KW_LOCATION:id
    {: RESULT = id; :}
    | KW_LOCK:id
    {: RESULT = id; :}
    | KW_UNLOCK:id
    {: RESULT = id; :}
    | KW_MATERIALIZED:id
    {: RESULT = id; :}
    | KW_MERGE:id
    {: RESULT = id; :}
    | KW_MODIFY:id
    {: RESULT = id; :}
    | KW_NAME:id
    {: RESULT = id; :}
    | KW_NAMES:id
    {: RESULT = id; :}
    | KW_NEGATIVE:id
    {: RESULT = id; :}
    | KW_NEVER:id
    {: RESULT = id; :}
    | KW_NEXT:id
    {: RESULT = id; :}
    | KW_NO:id
    {: RESULT = id; :}
    | KW_NULLS:id
    {: RESULT = id; :}
    | KW_OFFSET:id
    {: RESULT = id; :}
    | KW_ONLY:id
    {: RESULT = id; :}
    | KW_OPEN:id
    {: RESULT = id; :}
    | KW_PARAMETER:id
    {: RESULT = id; :}
    | KW_PARTITIONS:id
    {: RESULT = id; :}
    | KW_PASSWORD:id
    {: RESULT = id; :}
    | KW_PASSWORD_EXPIRE:id
    {: RESULT = id; :}
    | KW_PASSWORD_REUSE:id
    {: RESULT = id; :}
    | KW_PASSWORD_HISTORY:id
    {: RESULT = id; :}
    | KW_PASSWORD_LOCK_TIME:id
    {: RESULT = id; :}
    | KW_LDAP_ADMIN_PASSWORD:id
    {: RESULT = id; :}
    | KW_PLUGIN:id
    {: RESULT = id; :}
    | KW_PLUGINS:id
    {: RESULT = id; :}
    | KW_PROC:id
    {: RESULT = id; :}
    | KW_PROCESSLIST:id
    {: RESULT = id; :}
    | KW_PROPERTIES:id
    {: RESULT = id; :}
    | KW_PROPERTY:id
    {: RESULT = id; :}
    | KW_QUERY:id
    {: RESULT = id; :}
    | KW_QUOTA:id
    {: RESULT = id; :}
    | KW_RANDOM:id
    {: RESULT = id; :}
    | KW_RECOVER:id
    {: RESULT = id; :}
    | KW_REFRESH:id
    {: RESULT = id; :}
    | KW_REPEATABLE:id
    {: RESULT = id; :}
    | KW_REPLACE:id
    {: RESULT = id; :}
    | KW_REPLACE_IF_NOT_NULL:id
    {: RESULT = id; :}
    | KW_REPOSITORY:id
    {: RESULT = id; :}
    | KW_REPOSITORIES:id
    {: RESULT = id; :}
    | KW_RESOURCE:id
    {: RESULT = id; :}
    | KW_RESOURCES:id
    {: RESULT = id; :}
    | KW_RESTORE:id
    {: RESULT = id; :}
    | KW_RETURNS:id
    {: RESULT = id; :}
    | KW_ROLLBACK:id
    {: RESULT = id; :}
    | KW_ROLLUP:id
    {: RESULT = id; :}
    | KW_SCHEMA:id
    {: RESULT = id; :}
    | KW_SERIALIZABLE:id
    {: RESULT = id; :}
    | KW_SESSION:id
    {: RESULT = id; :}
    | KW_SKEW:id
    {: RESULT = id; :}
    | KW_SNAPSHOT:id
    {: RESULT = id; :}
    | KW_SONAME:id
    {: RESULT = id; :}
    | KW_SPLIT:id
    {: RESULT = id; :}
    | KW_START:id
    {: RESULT = id; :}
    | KW_STATUS:id
    {: RESULT = id; :}
    | KW_STATS:id
    {: RESULT = id; :}
    | KW_STORAGE:id
    {: RESULT = id; :}
    | KW_STREAM:id
    {: RESULT = id; :}
    | KW_STRUCT:id
    {: RESULT = id; :}
    | KW_STRING:id
    {: RESULT = id; :}
    | KW_TABLES:id
    {: RESULT = id; :}
    | KW_TEMPORARY:id
    {: RESULT = id; :}
    | KW_THAN:id
    {: RESULT = id; :}
    | KW_TIMESTAMP:id
    {: RESULT = id; :}
    | KW_TRANSACTION:id
    {: RESULT = id; :}
    | KW_TEXT:id
    {: RESULT = id; :}
    | KW_TRIGGERS:id
    {: RESULT = id; :}
    | KW_TRUNCATE:id
    {: RESULT = id; :}
    | KW_TYPE:id
    {: RESULT = id; :}
    | KW_TYPES:id
    {: RESULT = id; :}
    | KW_UNCOMMITTED:id
    {: RESULT = id; :}
    | KW_USER:id
    {: RESULT = id; :}
    | KW_VARIABLES:id
    {: RESULT = id; :}
    | KW_VALUE:id
    {: RESULT = id; :}
    | KW_VERBOSE:id
    {: RESULT = id; :}
    | KW_VIEW:id
    {: RESULT = id; :}
    | KW_WARNINGS:id
    {: RESULT = id; :}
    | KW_WORK:id
    {: RESULT = id; :}
    | KW_CLUSTER:id
    {: RESULT = id; :}
    | KW_CLUSTERS:id
    {: RESULT = id; :}
    | KW_LINK:id
    {: RESULT = id; :}
    | KW_MIGRATE:id
    {: RESULT = id; :}
    | KW_MIGRATIONS:id
    {: RESULT = id; :}
    | KW_COUNT:id
    {: RESULT = id; :}
    | KW_SUM:id
    {: RESULT = id; :}
    | KW_MIN:id
    {: RESULT = id; :}
    | KW_MAX:id
    {: RESULT = id; :}
    | KW_FREE:id
    {: RESULT = id; :}
    | KW_TASK:id
    {: RESULT = id; :}
    | KW_ROUTINE:id
    {: RESULT = id; :}
    | KW_PAUSE:id
    {: RESULT = id; :}
    | KW_RESUME:id
    {: RESULT = id; :}
    | KW_STOP:id
    {: RESULT = id; :}
    | KW_GROUPING:id
    {: RESULT = id; :}
    | KW_DYNAMIC:id
    {: RESULT = id; :}
    | time_unit:id
    {: RESULT = id; :}
    | KW_ENABLE:id
    {: RESULT = id; :}
    | KW_FEATURE:id
    {: RESULT = id; :}
    | KW_MAP:id
    {: RESULT = id; :}
    | KW_VARCHAR:id
    {: RESULT = id; :}
    | KW_POLICY:id
    {: RESULT = id; :}
    | KW_CURRENT_TIMESTAMP:id
    {: RESULT = id; :}
    | KW_CATALOG:id
    {: RESULT = id; :}
    | KW_CATALOGS:id
    {: RESULT = id; :}
    | KW_RECYCLE:id
    {: RESULT = id; :}
    | KW_MTMV:id
    {: RESULT = id; :}
    ;

// Identifier that contain keyword
ident ::=
    IDENT:id
    {:
        RESULT = id;
    :}
    | keyword:id
    {:
        RESULT = id;
    :}
    ;

// Identifier or text
ident_or_text ::=
    ident:id
    {:
        RESULT = id;
    :}
    | STRING_LITERAL:text
    {:
        RESULT = text;
    :}
    ;

time_unit ::=
    KW_YEAR:id
    {: RESULT = id; :}
    | KW_MONTH:id
    {: RESULT = id; :}
    | KW_WEEK:id
    {: RESULT = id; :}
    | KW_DAY:id
    {: RESULT = id; :}
    | KW_HOUR:id
    {: RESULT = id; :}
    | KW_MINUTE:id
    {: RESULT = id; :}
    | KW_SECOND:id
    {: RESULT = id; :}
    ;

// TODO(zhaochun): Select for SQL-2003 (http://savage.net.au/SQL/sql-2003-2.bnf.html)

// Specify a table derived from the result of a <table expression>.
// query_spec ::=
//     KW_SELECT opt_set_quantifier select_list table_expr
//
// opt_set_quantifier ::=
//     KW_DISTINCT
//     | KW_ALL
//     ;
//
// select_list ::=
//     STAR
//     | select_sublist
//     ;
//
// select_sublist ::=
//     derived_column
//     | qualified_star
//     ;
//
// table_expr ::=
//     from_clause where_clause group_by_clause having_clause order_by_clause limit_clause
//     ;
//
// // Specify a table derived from one or more tables.
// from_clause ::=
//     table_ref_list
//     ;
//
// table_ref_list ::=
//     table_ref
//     | table_ref_list COMMA table_ref
//     ;
//
// // Reference a table.
// table_ref ::=
//     table_primary
//     | joined_table
//     ;
//
// table_primary ::=
//     table_name
//     | subquery opt_as ident
//     | LPAREN joined_table RPAREN
//     ;
//
// opt_as ::=
//     /* Empty */
//     | KW_AS
//     ;
//
// // Specify a table.
// // TODO(zhaochun): Do not support EXCEPT INTERSECT and joined table
// query_expr_body ::=
//     query_term
//     | query_expr_body KW_UNION opt_set_quantifier query_term;
//     ;
//
// query_term ::=
//     query_spec
//     | LPAREN query_expr_body RPAREN
//     ;
//
// // Specify a scalar value, a row, or a table derived from a <query expression>.
// subquery ::=
//     LPAREN query_expr_body RPAREN;

// unused
//
// where_clause_without_null ::=
//   KW_WHERE expr:e
//   {: RESULT = e; :}
//   ;
//
// alter_cluster_clause ::=
//     KW_MODIFY opt_properties:properties
//     {:
//         RESULT = new AlterClusterClause(AlterClusterType.ALTER_CLUSTER_PROPERTIES, properties);
//     :}
//     ;
//
// col_list ::=
//     KW_COLUMNS LPAREN ident_list:colList RPAREN
//     {:
//         RESULT = colList;
//     :}
//     ;
//
// opt_charset_name ::=
//     /* empty */
//     | charset old_or_new_charset_name_or_default
//     ;
