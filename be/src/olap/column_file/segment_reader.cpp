// Copyright (c) 2017, Baidu.com, Inc. All Rights Reserved

// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

#include "olap/column_file/segment_reader.h"

#include <sys/mman.h>

#include <istream>

#include "olap/column_file/file_stream.h"
#include "olap/column_file/in_stream.h"
#include "olap/column_file/out_stream.h"

namespace palo {
namespace column_file {

static const uint32_t MIN_FILTER_BLOCK_NUM = 10;

SegmentReader::SegmentReader(
        const std::string file,
        OLAPTable* table,
        OLAPIndex* index,
        uint32_t segment_id,
        const std::vector<uint32_t>& return_columns,
        const std::set<uint32_t>& load_bf_columns,
        const Conditions* conditions,
        const DeleteHandler& delete_handler,
        const DelCondSatisfied delete_status,
        RuntimeState* runtime_state) :
        _file_name(file),
        _table(table),
        _olap_index(index),
        _segment_id(segment_id),
        _conditions(conditions),
        _delete_handler(delete_handler),
        _delete_status(delete_status),
        _eof(false),
        _is_init(false),
        _end_block(-1),
        // 确保第一次调用_move_to_next_row，会执行seek_to_block
        _current_block(-2),
        _block_count(0),
        _num_rows_in_block(0),
        _null_supported(false),
        _return_columns(return_columns),
        _load_bf_columns(load_bf_columns),
        _mmap_buffer(NULL),
        _include_blocks(NULL),
        _filted_rows(0),
        _is_using_mmap(false),
        _is_data_loaded(false),
        _buffer_size(0),
        _lru_cache(NULL),
        _cache_handle(NULL),
        _vectorized_info_inited(false),
        _runtime_state(runtime_state),
        _shared_buffer(NULL) {
    _lru_cache = OLAPEngine::get_instance()->index_stream_lru_cache();
}

SegmentReader::~SegmentReader() {
    SAFE_DELETE(_shared_buffer);
    SAFE_DELETE_ARRAY(_include_blocks);

    std::map<ColumnId, StreamIndexReader*>::iterator index_it = _indices.begin();
    for (; index_it != _indices.end(); ++index_it) {
        SAFE_DELETE((*index_it).second);
    }

    std::map<ColumnId, BloomFilterIndexReader*>::iterator bf_it = _bloom_filters.begin();
    for (; bf_it != _bloom_filters.end(); ++bf_it) {
        SAFE_DELETE(bf_it->second);
    }

    for (int32_t i = 0; i < _get_included_row_index_stream_num(); i++) {
        if (NULL != _cache_handle[i]) {
            _lru_cache->release(_cache_handle[i]);
        }
    }

    SAFE_DELETE_ARRAY(_cache_handle);
    _cache_handle = NULL;
    _lru_cache = NULL;
    _file_handler.close();

    if (_is_data_loaded && _runtime_state != NULL) {
        MemTracker::update_limits(_buffer_size * -1, _runtime_state->mem_trackers()); 
    }

    std::map<StreamName, ReadOnlyFileStream*>::iterator stream_it = _streams.begin();
    for (; stream_it != _streams.end(); ++stream_it) {
        delete(*stream_it).second;
    }

    std::vector<ColumnReader*>::iterator reader_it = _column_readers.begin();
    for (; reader_it != _column_readers.end(); ++reader_it) {
        delete(*reader_it);
    }

    if (_is_using_mmap) {
        SAFE_DELETE(_mmap_buffer);
    }
}

OLAPStatus SegmentReader::_check_file_version() {
    if (_header_message().magic_string().compare("COLUMN DATA") != 0) {
        OLAP_LOG_WARNING("not valid column data file, [magic_string = %s]",
                _header_message().magic_string().c_str());
        return OLAP_ERR_FILE_FORMAT_ERROR;
    }

    if (_header_message().version() > CURRENT_COLUMN_DATA_VERSION) {
        OLAP_LOG_WARNING("this file may generated by olapengine of higher version. "
                "reading it would cause some unexpected error, [found version = %d]",
                _header_message().version());
    }

    return OLAP_SUCCESS;
}

OLAPStatus SegmentReader::_load_segment_file() {
    OLAPStatus res = OLAP_SUCCESS;

    res = _file_handler.open_with_cache(_file_name, O_RDONLY);
    if (OLAP_SUCCESS != res) {
        OLAP_LOG_WARNING("fail to open segment file. [file='%s']", _file_name.c_str());
        return res;
    }

    //OLAP_LOG_DEBUG("seg file : %s", _file_name.c_str());
    // In file_header.unserialize(), it validates file length, signature, checksum of protobuf.
    _file_header = _olap_index->get_seg_pb(_segment_id);
    _null_supported = _olap_index->get_null_supported(_segment_id);
    _header_length = _file_header.size();

    res = _check_file_version();
    if (OLAP_SUCCESS != res) {
        OLAP_LOG_WARNING("file header corrupted or generated by higher version olapengine.");
        return res;
    }

    // 如果需要mmap，则进行映射
    if (_is_using_mmap) {
        _mmap_buffer = ByteBuffer::mmap(&_file_handler, 0, PROT_READ, MAP_PRIVATE);

        if (NULL == _mmap_buffer) {
            OLAP_LOG_WARNING("fail to call mmap, using default mode");
            return OLAP_ERR_MALLOC_ERROR;
        }
    }

    return OLAP_SUCCESS;
}

OLAPStatus SegmentReader::_set_decompressor() {
    switch (_header_message().compress_kind()) {
    case COMPRESS_NONE: {
        _decompressor = NULL;
        break;
    }

    case COMPRESS_LZO: {
        _decompressor = lzo_decompress;
        break;
    }

    case COMPRESS_LZ4: {
        _decompressor = lz4_decompress;
        break;
    }

    default: {
        OLAP_LOG_WARNING("unknown decompressor");
        return OLAP_ERR_PARSE_PROTOBUF_ERROR;
    }
    }

    return OLAP_SUCCESS;
}

OLAPStatus SegmentReader::_set_segment_info() {
    _num_rows_in_block = _header_message().num_rows_per_block();

    if (_num_rows_in_block == 0) {
        _num_rows_in_block = _table->num_rows_per_row_block();
    }

    _set_column_map();
    OLAPStatus res = _set_decompressor();

    if (OLAP_SUCCESS != res) {
        OLAP_LOG_WARNING("fail to get decompressor.");
        return res;
    }

    return OLAP_SUCCESS;
}

void SegmentReader::_init_vectorized_info(std::vector<uint32_t>& return_columns) {
    if (_vectorized_info_inited) {
        return;
    }

    uint32_t offset = 0;
    uint32_t width = 0;

    for (size_t i = 0; i < return_columns.size(); ++i) {
        if (_table->tablet_schema()[return_columns[i]].type == OLAP_FIELD_TYPE_VARCHAR
                || _table->tablet_schema()[return_columns[i]].type == OLAP_FIELD_TYPE_HLL) {
            width = sizeof(VarCharField::OffsetValueType);
        } else {
            width = _table->tablet_schema()[return_columns[i]].length;
        }

        VectorizedPositionInfo pos;
        pos.column_id = return_columns[i];
        pos.column_position = offset;
        _vectorized_position.push_back(pos);
        offset += width * _num_rows_in_block;
    }

    for (size_t i = 0; i < _vectorized_position.size(); i++) {
        if (_table->tablet_schema()[_vectorized_position[i].column_id].type ==
            OLAP_FIELD_TYPE_VARCHAR 
            || _table->tablet_schema()[_vectorized_position[i].column_id].type ==
            OLAP_FIELD_TYPE_HLL) {
            _vectorized_position[i].offset_position = offset;
            offset += _num_rows_in_block *
                      _table->tablet_schema()[_vectorized_position[i].column_id].length;
        }
    }

    _vectorized_info_inited = true;
}

OLAPStatus SegmentReader::init(bool is_using_cache) {
    if (_is_init) {
        return OLAP_SUCCESS;
    }

    OlapStopWatch timer;

    OLAPStatus res = OLAP_SUCCESS;
    res = _load_segment_file();
    if (OLAP_SUCCESS != res) {
        OLAP_LOG_WARNING("fail to load sgment file. ");
        return res;
    }

    uint64_t load_segment_time_us = timer.get_elapse_time_us();
    // 文件头
    res = _set_segment_info();
    if (OLAP_SUCCESS != res) {
        OLAP_LOG_WARNING("fail to set sgment info. ");
        return res;
    }

    res = _cursor.init(_table->tablet_schema());
    if (OLAP_SUCCESS != res) {
        OLAP_LOG_WARNING("fail to init row_cursor");
        return res;
    }

    _shared_buffer = ByteBuffer::create(
            _header_message().stream_buffer_size() + sizeof(StreamHead));
    if (_shared_buffer == NULL) {
        OLAP_LOG_WARNING("fail to create shared buffer. [size=%lu]", sizeof(ByteBuffer));
        return OLAP_ERR_MALLOC_ERROR;
    }

    res = _pick_columns();
    if (OLAP_SUCCESS != res) {
        OLAP_LOG_WARNING("fail to pick columns");
        return res;
    }

    timer.reset();
    res = _load_index(is_using_cache);
    if (OLAP_SUCCESS != res) {
        OLAP_LOG_WARNING("fail to load index stream");
        return res;
    }

    uint64_t load_index_stream_time_us = timer.get_elapse_time_us();
    // record segment init step time when more than 100ms
    if (load_segment_time_us > 100000 || load_index_stream_time_us > 100000) {
        OLAP_LOG_WARNING("segment init cost too much time. "
                         "[load_segment_time_us=%lu load_index_stream_time_us=%lu]",
                         load_segment_time_us, load_index_stream_time_us);
    }

    return OLAP_SUCCESS;
}

OLAPStatus SegmentReader::seek_to_block(
        uint32_t first_block, uint32_t last_block, bool without_filter) {
    OLAPStatus res = OLAP_SUCCESS;

    if (!_is_data_loaded) {

        _reset_readers();
        res = _read_all_data_streams(&_buffer_size);
        if (OLAP_SUCCESS != res) {
            OLAP_LOG_WARNING("fail to read data stream");
            return res;
        }
    
        OLAPStatus res = _create_reader(&_buffer_size);
        if (OLAP_SUCCESS != res) {
            OLAP_LOG_WARNING("fail to create reader");
            return res;
        }

        if (_runtime_state != NULL) {
            MemTracker::update_limits(_buffer_size, _runtime_state->mem_trackers());
            if (MemTracker::limit_exceeded(*_runtime_state->mem_trackers())) {
                return OLAP_ERR_FETCH_MEMORY_EXCEEDED;
            }
        }

        _is_data_loaded = true;
    } else {
        _eof = false;
    }

    _end_block = last_block >= _block_count ? _block_count - 1 : last_block;
    if (!without_filter) {
        _remain_block = last_block - first_block + 1;
        res = _pick_row_groups(first_block, last_block);
        if (OLAP_SUCCESS != res) {
            OLAP_LOG_WARNING("fail to pick row groups");
            return res;
        }
    }

    _current_row = first_block * _num_rows_in_block;
    OLAP_LOG_DEBUG("first %u end %u; tol %u",
        first_block, last_block,
        _block_count);
    res = _read_block(without_filter);

    if (OLAP_SUCCESS != res) {
        OLAP_LOG_WARNING("fail to read block");
        return res;
    }

    return OLAP_SUCCESS;
}

const RowCursor* SegmentReader::get_next_row(bool without_filter) {
    RowCursor* ret = NULL;
    while (true) {
        OLAPStatus res = _move_to_next_row(without_filter);
        if (OLAP_SUCCESS != res) {
            ret = NULL;
            break;
        }

        _cursor.reset_buf();
        res = _read_next_and_attach();
        if (OLAP_SUCCESS != res) {
            OLAP_LOG_WARNING("cur %lu to %lu",
                    _current_row, _header_message().number_of_rows());
            ret = NULL;
            break;
        }

        if (true == without_filter || NULL == _include_blocks
            || DEL_NOT_SATISFIED == _include_blocks[_current_block]) {
            ret = &_cursor;
            break;
        }

        bool row_del_filter = _delete_handler.is_filter_data(
                                    _olap_index->version().second, _cursor);
        if (false == row_del_filter) {
            ret = &_cursor;
            break;
        }

        ++_filted_rows;
    }
    return ret;
}

void SegmentReader::_set_column_map() {
    _encodings_map.clear();
    _table_id_to_unique_id_map.clear();
    _unique_id_to_table_id_map.clear();
    _unique_id_to_segment_id_map.clear();

    for (ColumnId table_column_id = 0; table_column_id < tablet_schema().size();
            ++table_column_id) {
        ColumnId unique_column_id = tablet_schema()[table_column_id].unique_id;
        _table_id_to_unique_id_map[table_column_id] = unique_column_id;
        _unique_id_to_table_id_map[unique_column_id] = table_column_id;
    }

    size_t segment_column_size = _header_message().column_size();
    for (ColumnId segment_column_id = 0; segment_column_id < segment_column_size;
            ++segment_column_id) {
        // 如果找得到，建立映射表
        ColumnId unique_column_id = _header_message().column(segment_column_id).unique_id();
        if (_unique_id_to_table_id_map.find(unique_column_id) != _unique_id_to_table_id_map.end()) {
            _unique_id_to_segment_id_map[unique_column_id] = segment_column_id;
            _segment_id_to_unique_id_map[segment_column_id] = unique_column_id;
            // encoding 应该和segment schema序一致。
            _encodings_map[unique_column_id] =
                _header_message().column_encoding(segment_column_id);
        }
    }
}

OLAPStatus SegmentReader::_pick_columns() {
    // _return_columns 使用table的schema序
    // 而return的时候则根据return columns顺序排列
    //
    // _include_columns    set，顺序无关, 使用uid
    // _indices            map，顺序无关，使用uid
    // _table_id_to_unique_id_map 是一个从table id转为uid的映射表

    // 如果发现没给出return columns，就用全集
    if (0 == _return_columns.size()) {
        for (size_t i = 0; i < _table->tablet_schema().size(); ++i) {
            _return_columns.push_back(i);
        }
    }

    _include_columns.clear();
    _include_bf_columns.clear();

    for (uint32_t i : _return_columns) {
        ColumnId unique_column_id = _table_id_to_unique_id_map[i];
        _include_columns.insert(unique_column_id);
    }

    for (uint32_t i : _load_bf_columns) {
        ColumnId unique_column_id = _table_id_to_unique_id_map[i];
        _include_bf_columns.insert(unique_column_id);
    }

    return OLAP_SUCCESS;
}

OLAPStatus SegmentReader::_pick_delete_row_groups(uint32_t first_block, uint32_t last_block) {
    OLAP_LOG_DEBUG("pick for %u to %u for delete_condition", first_block, last_block);

    if (true == _delete_handler.empty()) {
        return OLAP_SUCCESS;
    }

    if (DEL_NOT_SATISFIED == _delete_status) {
        OLAP_LOG_DEBUG("the segment not satisfy the delete_conditions");
        return OLAP_SUCCESS;
    }

    for (auto& delete_condition : _delete_handler.get_delete_conditions()) {
        if (delete_condition.filter_version <= _olap_index->version().first) {
            continue;
        }

        for (int64_t j = first_block; j <= last_block; ++j) {
            if (DEL_SATISFIED == _include_blocks[j]) {
                //if state is DEL_SATISFIED, continue
                continue;
            }

            bool del_partial_satisfied = false;
            bool del_not_satisfied = false;
            for (auto& i : delete_condition.del_cond->columns()) {
                ColumnId table_column_id = i.first;
                ColumnId unique_column_id = _table_id_to_unique_id_map[table_column_id];
                if (0 == _unique_id_to_segment_id_map.count(unique_column_id)) {
                    continue;
                }
                StreamIndexReader* index_reader = _indices[unique_column_id];
                int del_ret = i.second.del_eval(index_reader->entry(j).column_statistic());
                if (DEL_SATISFIED == del_ret) {
                    continue;
                } else if (DEL_PARTIAL_SATISFIED == del_ret) {
                    del_partial_satisfied = true;
                } else {
                    del_not_satisfied = true;
                    break;
                }
            }

            if (true == del_not_satisfied || 0 == delete_condition.del_cond->columns().size()) {
                //if state is DEL_PARTIAL_SATISFIED last_time, cannot be set as DEL_NOT_SATISFIED
                //it is special for for delete condition
                if (DEL_PARTIAL_SATISFIED == _include_blocks[j]) {
                    continue;
                } else {
                    _include_blocks[j] = DEL_NOT_SATISFIED;
                }
            } else if (true == del_partial_satisfied) {
                _include_blocks[j] = DEL_PARTIAL_SATISFIED;
                OLAP_LOG_DEBUG("filter block partially: %d", j);
            } else {
                _include_blocks[j] = DEL_SATISFIED;
                --_remain_block;
                OLAP_LOG_DEBUG("filter block: %d", j);
                if (j < _block_count - 1) {
                    _filted_rows += _num_rows_in_block; 
                } else {
                    _filted_rows += _header_message().number_of_rows() - j * _num_rows_in_block;
                }
            }

        }
    }

    return OLAP_SUCCESS;

}

OLAPStatus SegmentReader::_init_include_blocks(uint32_t first_block, uint32_t last_block) {
    if (NULL == _include_blocks) {
        _include_blocks= new(std::nothrow) uint8_t[_block_count];
        if (NULL == _include_blocks) {
            OLAP_LOG_WARNING("fail to malloc include block array");
            return OLAP_ERR_MALLOC_ERROR;
        }
    }

    memset(_include_blocks, 0, _block_count);
    memset(_include_blocks + first_block, 1, _remain_block);

    return OLAP_SUCCESS;
}

OLAPStatus SegmentReader::_pick_row_groups(uint32_t first_block, uint32_t last_block) {
    OLAP_LOG_DEBUG("pick from %u to %u", first_block, last_block);

    if (first_block > last_block) {
        OLAP_LOG_WARNING("invalid block offset. [first_block=%u last_block=%u]",
                         first_block, last_block);
        return OLAP_ERR_INPUT_PARAMETER_ERROR;
    }

    OLAPStatus res = _init_include_blocks(first_block, last_block);
    if (OLAP_SUCCESS != res) {
        return res;
    }

    _pick_delete_row_groups(first_block, last_block);

    if (NULL == _conditions || _conditions->columns().size() == 0) {
        return OLAP_SUCCESS;
    }

    OlapStopWatch timer;
    timer.reset();

    for (auto& i : _conditions->columns()) {
        FieldAggregationMethod aggregation = _table->get_aggregation_by_index(i.first);
        bool is_continue = (aggregation == OLAP_FIELD_AGGREGATION_NONE
                || (aggregation == OLAP_FIELD_AGGREGATION_REPLACE
                && _olap_index->version().first == 0));
        if (!is_continue) {
            continue;
        }

        ColumnId table_column_id = i.first;
        ColumnId unique_column_id = _table_id_to_unique_id_map[table_column_id];
        if (0 == _unique_id_to_segment_id_map.count(unique_column_id)) {
            continue;
        }
        StreamIndexReader* index_reader = _indices[unique_column_id];
        for (int64_t j = first_block; j <= last_block; ++j) {
            if (_include_blocks[j] == DEL_SATISFIED) {
                continue;
            }

            if (!i.second.eval(index_reader->entry(j).column_statistic())) {
                _include_blocks[j] = DEL_SATISFIED;
                --_remain_block;
            }
            if (j < _block_count - 1) {
                _filted_rows += _num_rows_in_block; 
            } else {
                _filted_rows += _header_message().number_of_rows() - j * _num_rows_in_block;
            }
        }
    }

    if (_remain_block < MIN_FILTER_BLOCK_NUM) {
        OLAP_LOG_DEBUG("bloom filter is ignored for too few block remained. "
                       "[remain_block=%u const_time=%lu]",
                       _remain_block, timer.get_elapse_time_us());
        return OLAP_SUCCESS;
    }

    for (uint32_t i : _load_bf_columns) {
        FieldAggregationMethod aggregation = _table->get_aggregation_by_index(i);
        bool is_continue = (aggregation == OLAP_FIELD_AGGREGATION_NONE
                || (aggregation == OLAP_FIELD_AGGREGATION_REPLACE
                && _olap_index->version().first == 0));
        if (!is_continue) {
            continue;
        }

        ColumnId table_column_id = i;
        ColumnId unique_column_id = _table_id_to_unique_id_map[table_column_id];
        if (0 == _unique_id_to_segment_id_map.count(unique_column_id)) {
            continue;
        }
        BloomFilterIndexReader* bf_reader = _bloom_filters[unique_column_id];
        for (int64_t j = first_block; j <= last_block; ++j) {
            if (_include_blocks[j] == DEL_SATISFIED) {
                continue;
            }

            if (!_conditions->columns().at(i).eval(bf_reader->entry(j))) {
                _include_blocks[j] = DEL_SATISFIED;
                --_remain_block;
                if (j < _block_count - 1) {
                    _filted_rows += _num_rows_in_block; 
                } else {
                    _filted_rows += _header_message().number_of_rows() - j * _num_rows_in_block;
                }
            }
        }
    }

    OLAP_LOG_DEBUG("pick row groups finished. [remain_block=%u const_time=%lu]",
                   _remain_block, timer.get_elapse_time_us());

    return OLAP_SUCCESS;
}

CacheKey SegmentReader::_construct_index_stream_key(
        char* buf,
        size_t len,
        const std::string& file_name,
        ColumnId unique_column_id,
        StreamInfoMessage::Kind kind) {
    char* current = buf;
    size_t remain_len = len;
    OLAP_CACHE_STRING_TO_BUF(current, file_name, remain_len);
    OLAP_CACHE_NUMERIC_TO_BUF(current, unique_column_id, remain_len);
    OLAP_CACHE_NUMERIC_TO_BUF(current, kind, remain_len);

    return CacheKey(buf, len - remain_len);
}

void SegmentReader::_delete_cached_index_stream(const CacheKey& key, void* value) {
    char* buffer = reinterpret_cast<char*>(value);
    SAFE_DELETE_ARRAY(buffer);
}

OLAPStatus SegmentReader::_load_index(bool is_using_cache) {
    OLAPStatus res = OLAP_SUCCESS;

    int32_t handle_num = _get_included_row_index_stream_num();
    _cache_handle = new(std::nothrow) Cache::Handle*[handle_num];
    if (NULL == _cache_handle) {
        OLAP_LOG_WARNING("fail to malloc index stream cache handle.");
        return OLAP_ERR_MALLOC_ERROR;
    }
    memset(reinterpret_cast<char*>(_cache_handle), 0, sizeof(Cache::Handle*) * handle_num);

    ReadOnlyFileStream stream(
            &_file_handler, &_shared_buffer, _decompressor,
            _header_message().stream_buffer_size());
    res = stream.init();
    if (OLAP_SUCCESS != res) {
        OLAP_LOG_WARNING("fail to init stream. [res=%d]", res);
        return res;
    }

    _indices.clear();
    _bloom_filters.clear();
    uint64_t stream_length = 0;
    int32_t cache_handle_index = 0;
    uint64_t stream_offset = _header_length;
    int64_t expected_blocks = static_cast<int64_t>(ceil(static_cast<double>(
            _header_message().number_of_rows()) /
            _header_message().num_rows_per_block()));
    for (int64_t stream_index = 0; stream_index < _header_message().stream_info_size();
            ++stream_index, stream_offset += stream_length) {
        // 查找需要的index, 虽然有的index不需要读
        // 取，但为了获取offset，还是要计算一遍
        // 否则无法拿到正确的streamoffset
        const StreamInfoMessage& message = _header_message().stream_info(stream_index);
        stream_length = message.length();
        ColumnId unique_column_id = message.column_unique_id();
        if (0 == _unique_id_to_segment_id_map.count(unique_column_id)) {
            continue;
        }

        if ((_is_column_included(unique_column_id)
                && message.kind() == StreamInfoMessage::ROW_INDEX)
                || (_is_bf_column_included(unique_column_id)
                && message.kind() == StreamInfoMessage::BLOOM_FILTER)) {
        } else {
            continue;
        }

        ColumnId table_column_id = _unique_id_to_table_id_map[unique_column_id];
        FieldType type = _table->get_field_type_by_index(table_column_id);

        char* stream_buffer = NULL;
        char key_buf[OLAP_LRU_CACHE_MAX_KEY_LENTH];
        CacheKey key = _construct_index_stream_key(key_buf,
                       sizeof(key_buf),
                       _file_handler.file_name(),
                       unique_column_id,
                       message.kind());
        _cache_handle[cache_handle_index] = _lru_cache->lookup(key);

        if (NULL != _cache_handle[cache_handle_index]) {
            // 1. 如果在lru中，取出buffer，并用来初始化index reader
            is_using_cache = true;
            stream_buffer = reinterpret_cast<char*>(
                    _lru_cache->value(_cache_handle[cache_handle_index]));
        } else {
            // 2. 如果不在lru中，需要创建index stream。
            stream_buffer = new(std::nothrow) char[stream_length];
            if (NULL == stream_buffer) {
                OLAP_LOG_WARNING("fail to malloc index stream. "
                        "[column_unique_id = %u, offset = %lu]",
                        unique_column_id, stream_offset);
                return OLAP_ERR_MALLOC_ERROR;
            }

            size_t read_length = stream_length;
            stream.reset(stream_offset, stream_length);
            res = stream.read_all(stream_buffer, &read_length);
            if (OLAP_SUCCESS != res) {
                OLAP_LOG_WARNING("read index fail");
                return OLAP_ERR_FILE_FORMAT_ERROR;
            }

            if (is_using_cache) {
                // 将读出的索引放入lru中。
                _cache_handle[cache_handle_index] = _lru_cache->insert(
                        key, stream_buffer, stream_length, &_delete_cached_index_stream);
                if (NULL == _cache_handle[cache_handle_index]) {
                    // 这里可能是cache insert中的malloc失败了, 先返回成功
                    OLAP_LOG_FATAL("fail to insert lru cache.");
                }
            }
        }
        cache_handle_index++;

        if (message.kind() == StreamInfoMessage::ROW_INDEX) {
            StreamIndexReader* index_message = new(std::nothrow) StreamIndexReader;
            if (index_message == NULL) {
                OLAP_LOG_WARNING("fail to malloc memory. [size=%lu]", sizeof(StreamIndexReader));
                return OLAP_ERR_MALLOC_ERROR;
            }
            
            res = index_message->init(stream_buffer, stream_length, type, is_using_cache, _null_supported);
            if (OLAP_SUCCESS != res) {
                OLAP_LOG_WARNING("init index from cahce fail");
                return res;
            }

            _indices[unique_column_id] = index_message;

            // 每个index的entry数量应该一致, 也就是block的数量
            _block_count = index_message->entry_count();
        } else {
            BloomFilterIndexReader* bf_message = new(std::nothrow) BloomFilterIndexReader;
            if (bf_message == NULL) {
                OLAP_LOG_WARNING("fail to malloc memory. [size=%lu]",
                                 sizeof(BloomFilterIndexReader));
                return OLAP_ERR_MALLOC_ERROR;
            }

            res = bf_message->init(stream_buffer, stream_length, is_using_cache,
                    _header_message().bf_hash_function_num(), _header_message().bf_bit_num());
            if (res != OLAP_SUCCESS) {
                OLAP_LOG_WARNING("fail to init bloom filter reader. [res=%d]", res);
                return res;
            }

            _bloom_filters[unique_column_id] = bf_message;

            // 每个index的entry数量应该一致, 也就是block的数量
            _block_count = bf_message->entry_count();
        }

        if (_block_count != expected_blocks) {
            OLAP_LOG_WARNING("something wrong while reading index, expected=%lu, actual=%lu",
                    expected_blocks, _block_count);
            return OLAP_ERR_FILE_FORMAT_ERROR;
        }
    }

    OLAP_LOG_DEBUG("found index entry count %u", _block_count);
    return OLAP_SUCCESS;
}

int32_t SegmentReader::_get_index_position(ColumnEncodingMessage::Kind encoding_kind,
        std::string type,
        StreamInfoMessage::Kind stream_kind,
        bool is_compressed,
        bool has_null) {
    if (stream_kind == StreamInfoMessage::PRESENT) {
        return 0;
    }

    int32_t compressionValue = 1;
    int32_t base = has_null ? (BITFIELD_POSITIONS + compressionValue) : 0;
    // TODO. 將column的type轉換爲int類型
    std::string type_copy = type;
    transform(type_copy.begin(), type_copy.end(), type_copy.begin(), toupper);

    if (type == "VARCHAR" || type == "HLL" ||  type == "CHAR") {
        if (encoding_kind == ColumnEncodingMessage::DIRECT &&
                stream_kind != StreamInfoMessage::DATA) {
            return base + BYTE_STREAM_POSITIONS + compressionValue;
        }
    }

    return base;
}

bool SegmentReader::_is_dictionary(StreamInfoMessage::Kind kind,
        ColumnEncodingMessage encoding) {
    return kind == StreamInfoMessage::DICTIONARY_DATA ||
           (kind == StreamInfoMessage::LENGTH &&
                   (encoding.kind() == ColumnEncodingMessage::DICTIONARY));
}

bool SegmentReader::_is_overlap(size_t left_a, size_t right_a,
        size_t left_b, size_t right_b) {
    if (left_a <= left_b) {
        return right_a >= left_b;
    }

    return  left_a <= right_b;
}

void SegmentReader::_fill_has_null(std::map<ColumnId, bool>* has_null) {
    for (int32_t stream_index = 0; stream_index < _header_message().stream_info_size();
            ++stream_index) {
        const StreamInfoMessage& message = _header_message().stream_info(stream_index);
        if (message.kind() == StreamInfoMessage::PRESENT) {
            ColumnId unique_column_id = message.column_unique_id();
            if (0 == _unique_id_to_segment_id_map.count(unique_column_id)) {
                continue;
            }

            (*has_null)[unique_column_id] = true;
        }
    }
}

OLAPStatus SegmentReader::_read_all_data_streams(size_t* buffer_size) {
    int64_t stream_offset = _header_length;
    uint64_t stream_length = 0;

    // 每条流就一块整的
    for (int64_t stream_index = 0; stream_index < _header_message().stream_info_size();
            ++stream_index, stream_offset += stream_length) {
        const StreamInfoMessage& message = _header_message().stream_info(stream_index);
        stream_length = message.length();
        ColumnId unique_column_id = message.column_unique_id();
        if (0 == _unique_id_to_segment_id_map.count(unique_column_id)) {
            continue;
        }

        if ((_is_column_included(unique_column_id)
                && message.kind() == StreamInfoMessage::ROW_INDEX)
                || (_is_bf_column_included(unique_column_id)
                && message.kind() == StreamInfoMessage::BLOOM_FILTER)) {
            continue;
        } else {
            StreamName name(unique_column_id, message.kind());
            ReadOnlyFileStream* stream = new(std::nothrow) ReadOnlyFileStream(
                    &_file_handler,
                    &_shared_buffer,
                    stream_offset,
                    stream_length,
                    _decompressor,
                    _header_message().stream_buffer_size());
            if (NULL == stream) {
                OLAP_LOG_WARNING("fail to create stream");
                return OLAP_ERR_MALLOC_ERROR;
            }

            OLAPStatus res = stream->init();
            if (OLAP_SUCCESS != res) {
                OLAP_LOG_WARNING("fail to init stream");
                return res;
            }

            _streams[name] = stream;
            *buffer_size += stream->get_buffer_size();
        }
    }

    return OLAP_SUCCESS;
}

OLAPStatus SegmentReader::_reader_skip(uint64_t skip_rows) {
    OLAPStatus res = OLAP_SUCCESS;

    for (size_t i = 0; i < _column_readers.size(); ++i) {
        res = _column_readers[i]->skip(skip_rows);

        if (OLAP_SUCCESS != res && OLAP_ERR_COLUMN_STREAM_EOF != res) {
            OLAP_LOG_WARNING("fail to skip reader");
            break;
        }
    }

    return res;
}

OLAPStatus SegmentReader::_create_reader(size_t* buffer_size) {
    OLAPStatus res = OLAP_SUCCESS;

    for (size_t i = 0; i < _return_columns.size(); ++i) {
        // 根据returncolumn顺序排列
        ColumnId table_column_id = _return_columns[i];
        ColumnId unique_column_id = _table_id_to_unique_id_map[table_column_id];
        // 当前是不会出现table和segment的schema不一致的情况的
        ColumnReader* reader = ColumnReader::create(table_column_id,
                               _table->tablet_schema(),
                               _unique_id_to_table_id_map,
                               _unique_id_to_segment_id_map,
                               _encodings_map);
        if (NULL == reader) {
            OLAP_LOG_WARNING("fail to create reader");
            return res;
        }

        std::map<StreamName, ReadOnlyFileStream*>::iterator it = _streams.begin();
        res = reader->init(&_streams);
        if (OLAP_SUCCESS != res) {
            OLAP_LOG_WARNING("fail to init reader");
            delete reader;
            return res;
        }

        // _column_indices 的顺序和reader一致
        _column_readers.push_back(reader);
        if (0 == _unique_id_to_segment_id_map.count(unique_column_id)) {
            _column_indices.push_back(NULL);
        } else {
            _column_indices.push_back(_indices[unique_column_id]);
        }
        *buffer_size += reader->get_buffer_size();
    }

    return OLAP_SUCCESS;
}

OLAPStatus SegmentReader::_move_to_next_row(bool without_filter) {
    if (_current_row >= _header_message().number_of_rows()) {
        _eof = true;
        return OLAP_ERR_DATA_EOF;
    }

    if (_current_row % _num_rows_in_block != 0) {
        ++_current_row;
        return OLAP_SUCCESS;
    }

    int64_t next_block = int64_t(_current_row / _num_rows_in_block);
    if (!without_filter && NULL != _include_blocks && DEL_SATISFIED == _include_blocks[next_block]) {
        while (next_block < _block_count && DEL_SATISFIED == _include_blocks[next_block]) {
            ++next_block;
        }

        if (next_block >= _block_count) {
            _eof = true;
            return OLAP_ERR_DATA_EOF;
        }

        _current_row = next_block * _num_rows_in_block;
    } else if (next_block > _end_block) {
        _eof = true;
        return OLAP_ERR_DATA_EOF;
    }

    if (OLAP_UNLIKELY(next_block != _current_block || 0 == _current_row)) {
        if (next_block > _current_block) {
            OLAPStatus res = _seek_to_row_entry(next_block);
            if (res == OLAP_SUCCESS) {
                // seek to next_block will be successful in most case
            } else if (res == OLAP_ERR_DATA_EOF) {
                _eof = true;
                return res;
            } else {
                OLAP_LOG_WARNING("fail to seek to next block. [res=%d]", res);
                return res;
            }
        }

        _current_block = next_block;
    }

    _current_row++;
    return OLAP_SUCCESS;
}

OLAPStatus SegmentReader::_seek_to_row_entry(int64_t block_id) {

    for (size_t i = 0; i < _column_readers.size(); ++i) {
        if (block_id >= _block_count) {
            return OLAP_ERR_DATA_EOF;
        }

        OLAPStatus res = OLAP_SUCCESS;
        
        ColumnId table_column_id = _return_columns[i];
        ColumnId unique_column_id = _table_id_to_unique_id_map[table_column_id];
        if (0 == _unique_id_to_segment_id_map.count(unique_column_id)) {
            continue;    
        }
        PositionProvider position(&_column_indices[i]->entry(block_id));
        if (OLAP_SUCCESS != (res = _column_readers[i]->seek(&position))) {
            if (OLAP_ERR_COLUMN_STREAM_EOF == res) {
                OLAP_LOG_DEBUG("Stream EOF. [tablet_id=%ld column_id=%u block_id=%lu]",
                        _table->tablet_id(), _column_readers[i]->column_unique_id(), block_id);
                return OLAP_ERR_DATA_EOF;
            } else {
                OLAP_LOG_WARNING("fail to seek to block. "
                        "[tablet_id=%ld column_id=%u block_id=%lu]",
                        _table->tablet_id(), _column_readers[i]->column_unique_id(), block_id);
                return OLAP_ERR_COLUMN_SEEK_ERROR;
            }
        }
    }

    return OLAP_SUCCESS;
}

OLAPStatus SegmentReader::_reset_readers() {
    OLAP_LOG_DEBUG("%lu stream in total.", _streams.size());

    for (std::map<StreamName, ReadOnlyFileStream*>::iterator it = _streams.begin();
            it != _streams.end(); ++it) {
        if (_runtime_state != NULL) {
            MemTracker::update_limits(
                    -1 * it->second->get_buffer_size(), _runtime_state->mem_trackers());
        }
        delete it->second;
    }

    _streams.clear();

    for (std::vector<ColumnReader*>::iterator it = _column_readers.begin();
            it != _column_readers.end(); ++it) {
        if (_runtime_state != NULL) {
            MemTracker::update_limits(
                    -1 * (*it)->get_buffer_size(), _runtime_state->mem_trackers());
        }
        delete(*it);
    }

    _column_readers.clear();
    _eof = false;
    return OLAP_SUCCESS;
}

OLAPStatus SegmentReader::_read_block(bool without_filter) {
    if (NULL != _include_blocks && !without_filter) {
        // 如果当前row小于总row, 并探测当前row所在的block是不是应该被过滤
        // 如果需要过滤就跳过，目的是找到第一个需要读取的block
        while (_current_row < _header_message().number_of_rows() &&
                DEL_SATISFIED == _include_blocks[(int)(_current_row / _num_rows_in_block)]) {
            _current_row = _current_row + _num_rows_in_block;
        }
    }

    OLAP_LOG_DEBUG("--> entry %d cur %lu tol %lu",
            (int)(_current_row / _num_rows_in_block),
            _current_row, _header_message().number_of_rows());

    if (_current_row < _header_message().number_of_rows()) {
        // seek到起始位置
        return _seek_to_row_entry((int)(_current_row / _num_rows_in_block));
    }

    return OLAP_SUCCESS;
}

OLAPStatus SegmentReader::get_row_batch(
        uint8_t* batch_buf,
        uint32_t batch_buf_len,
        uint32_t* start_row_index,
        uint32_t* batch_row_num,
        uint32_t* block_row_num,
        std::vector<uint32_t>& return_columns) {
    OLAPStatus res = OLAP_SUCCESS;

    _init_vectorized_info(return_columns);

    res = _seek_to_row_entry(_current_block);
    if (OLAP_SUCCESS != res) {
        OLAP_LOG_WARNING("fail to seek to row entry.[res=%d block_id=%d]", res, _current_block);
        return res;
    }

    uint64_t start_row_in_block = (_current_row - 1) % _num_rows_in_block;

    for (size_t i = 0; i < _column_readers.size(); ++i) {
        if (return_columns.end() == std::find(return_columns.begin(),
                return_columns.end(), _column_readers[i]->column_id())) {
            continue;
        }

        uint32_t batch_size = _num_rows_in_block - start_row_in_block;
        std::vector<uint32_t> offset;

        for (size_t j = 0; j < _vectorized_position.size(); ++j) {
            if (_vectorized_position[j].column_id == _column_readers[i]->column_id()) {
                offset.push_back(_vectorized_position[j].column_position);
                offset.push_back(_vectorized_position[j].offset_position);
                break;
            }
        }

        if (offset.begin() == offset.end()) {
            OLAP_LOG_WARNING("Fail to get offset![column_id=%d]",
                    _column_readers[i]->column_id());
            return OLAP_ERR_OTHER_ERROR;
        }

        res = _column_readers[i]->next_vector(
                batch_buf, batch_buf_len, start_row_in_block, batch_size, offset);

        if (OLAP_SUCCESS != res && OLAP_ERR_DATA_EOF != res) {
            OLAP_LOG_WARNING("Fail to next vector.[res=%d column_unique_id=%d]",
                    res, _column_readers[i]->column_unique_id());
            return res;
        }
    }

    *start_row_index = start_row_in_block;
    *batch_row_num = _num_rows_in_block - start_row_in_block;
    *block_row_num = _num_rows_in_block;

    return OLAP_SUCCESS;
}

}  // namespace column_file
}  // namespace palo
