diff a/be/src/vec/columns/column_object.cpp b/be/src/vec/columns/column_object.cpp	(rejected hunks)
@@ -29,6 +29,8 @@
 #include <map>
 #include <optional>
 
+#include "common/exception.h"
+#include "common/status.h"
 #include "vec/columns/column_array.h"
 #include "vec/columns/column_nullable.h"
 #include "vec/columns/columns_number.h"
@@ -158,7 +160,6 @@ private:
 /// Returns 0 for scalar fields.
 class FieldVisitorToNumberOfDimensions : public StaticVisitor<size_t> {
 public:
-    explicit FieldVisitorToNumberOfDimensions(Status* st) : _st(st) {}
     size_t operator()(const Array& x) const {
         const size_t size = x.size();
         std::optional<size_t> dimensions;
@@ -172,8 +173,8 @@ public:
             if (!dimensions) {
                 dimensions = current_dimensions;
             } else if (current_dimensions != *dimensions) {
-                *_st = Status::InvalidArgument(
-                        "Number of dimensions mismatched among array elements");
+                throw doris::Exception(doris::ErrorCode::INVALID_ARGUMENT,
+                                       "Number of dimensions mismatched among array elements");
                 return 0;
             }
         }
@@ -183,9 +184,6 @@ public:
     size_t operator()(const T&) const {
         return 0;
     }
-
-private:
-    mutable Status* _st;
 };
 
 /// Visitor that allows to get type of scalar field
@@ -217,9 +215,16 @@ public:
         return 0;
     }
     size_t operator()(const Int64& x) {
-        // Only Int64 at present
+        // // Only Int64 at present
+        // field_types.insert(FieldType::Int64);
+        // type_indexes.insert(TypeIndex::Int64);
+        // return 0;
         field_types.insert(FieldType::Int64);
-        type_indexes.insert(TypeIndex::Int64);
+        if (x <= std::numeric_limits<Int32>::max() && x >= std::numeric_limits<Int32>::min()) {
+            type_indexes.insert(TypeIndex::Int32);
+        } else {
+            type_indexes.insert(TypeIndex::Int64);
+        }
         return 0;
     }
     size_t operator()(const Null&) {
@@ -233,8 +238,8 @@ public:
         type_indexes.insert(TypeId<NearestFieldType<T>>::value);
         return 0;
     }
-    Status get_scalar_type(DataTypePtr* type) const {
-        return get_least_supertype(type_indexes, type, true /*compatible with string type*/);
+    void get_scalar_type(DataTypePtr* type) const {
+        get_least_supertype(type_indexes, type, true /*compatible with string type*/);
     }
     bool contain_nulls() const { return have_nulls; }
     bool need_convert_field() const { return field_types.size() > 1; }
@@ -246,21 +251,18 @@ private:
 };
 
 } // namespace
-Status get_field_info(const Field& field, FieldInfo* info) {
+void get_field_info(const Field& field, FieldInfo* info) {
     FieldVisitorToScalarType to_scalar_type_visitor;
     apply_visitor(to_scalar_type_visitor, field);
     DataTypePtr type = nullptr;
-    RETURN_IF_ERROR(to_scalar_type_visitor.get_scalar_type(&type));
+    to_scalar_type_visitor.get_scalar_type(&type);
     // array item's dimension may missmatch, eg. [1, 2, [1, 2, 3]]
-    Status num_to_dimensions_status;
     *info = {
             type,
             to_scalar_type_visitor.contain_nulls(),
             to_scalar_type_visitor.need_convert_field(),
-            apply_visitor(FieldVisitorToNumberOfDimensions(&num_to_dimensions_status), field),
+            apply_visitor(FieldVisitorToNumberOfDimensions(), field),
     };
-    RETURN_IF_ERROR(num_to_dimensions_status);
-    return Status::OK();
 }
 
 ColumnObject::Subcolumn::Subcolumn(MutableColumnPtr&& data_, bool is_nullable_)
@@ -297,10 +299,10 @@ size_t ColumnObject::Subcolumn::Subcolumn::allocatedBytes() const {
     return res;
 }
 
-Status ColumnObject::Subcolumn::insert(Field field) {
+void ColumnObject::Subcolumn::insert(Field field) {
     FieldInfo info;
-    RETURN_IF_ERROR(get_field_info(field, &info));
-    return insert(std::move(field), std::move(info));
+    get_field_info(field, &info);
+    insert(std::move(field), std::move(info));
 }
 
 void ColumnObject::Subcolumn::add_new_column_part(DataTypePtr type) {
@@ -308,11 +310,11 @@ void ColumnObject::Subcolumn::add_new_column_part(DataTypePtr type) {
     least_common_type = LeastCommonType {std::move(type)};
 }
 
-Status ColumnObject::Subcolumn::insert(Field field, FieldInfo info) {
+void ColumnObject::Subcolumn::insert(Field field, FieldInfo info) {
     auto base_type = std::move(info.scalar_type);
     if (is_nothing(base_type)) {
         insertDefault();
-        return Status::OK();
+        return;
     }
     auto column_dim = least_common_type.get_dimensions();
     auto value_dim = info.num_dimensions;
@@ -323,8 +325,10 @@ Status ColumnObject::Subcolumn::insert(Field field, FieldInfo info) {
         value_dim = column_dim;
     }
     if (value_dim != column_dim) {
-        return Status::InvalidArgument(
-                "Dimension of types mismatched between inserted value and column.");
+        throw doris::Exception(doris::ErrorCode::INVALID_ARGUMENT,
+                               "Dimension of types mismatched between inserted value and column, "
+                               "expected:{}, but meet:{} for type:{}",
+                               column_dim, value_dim, least_common_type.get()->get_name());
     }
     if (is_nullable && !is_nothing(base_type)) {
         base_type = make_nullable(base_type);
@@ -348,9 +352,8 @@ Status ColumnObject::Subcolumn::insert(Field field, FieldInfo info) {
     } else if (!least_common_base_type->equals(*base_type) && !is_nothing(base_type)) {
         if (!schema_util::is_conversion_required_between_integers(*base_type,
                                                                   *least_common_base_type)) {
-            RETURN_IF_ERROR(
-                    get_least_supertype(DataTypes {std::move(base_type), least_common_base_type},
-                                        &base_type, true /*compatible with string type*/));
+            get_least_supertype(DataTypes {std::move(base_type), least_common_base_type},
+                                &base_type, true /*compatible with string type*/);
             type_changed = true;
             if (!least_common_base_type->equals(*base_type)) {
                 add_new_column_part(create_array_of_type(std::move(base_type), value_dim));
@@ -360,15 +363,14 @@ Status ColumnObject::Subcolumn::insert(Field field, FieldInfo info) {
 
     if (type_changed || info.need_convert) {
         Field new_field;
-        RETURN_IF_ERROR(convert_field_to_type(field, *least_common_type.get(), &new_field));
+        convert_field_to_type(field, *least_common_type.get(), &new_field);
         field = new_field;
     }
 
     data.back()->insert(field);
-    return Status::OK();
 }
 
-Status ColumnObject::Subcolumn::insertRangeFrom(const Subcolumn& src, size_t start, size_t length) {
+void ColumnObject::Subcolumn::insertRangeFrom(const Subcolumn& src, size_t start, size_t length) {
     assert(src.is_finalized());
     const auto& src_column = src.data.back();
     const auto& src_type = src.least_common_type.get();
@@ -379,18 +381,20 @@ Status ColumnObject::Subcolumn::insertRangeFrom(const Subcolumn& src, size_t sta
         data.back()->insert_range_from(*src_column, start, length);
     } else {
         DataTypePtr new_least_common_type = nullptr;
-        RETURN_IF_ERROR(get_least_supertype(DataTypes {least_common_type.get(), src_type},
-                                            &new_least_common_type,
-                                            true /*compatible with string type*/));
+        get_least_supertype(DataTypes {least_common_type.get(), src_type}, &new_least_common_type,
+                            true /*compatible with string type*/);
         ColumnPtr casted_column;
-        RETURN_IF_ERROR(schema_util::cast_column({src_column, src_type, ""}, new_least_common_type,
-                                                 &casted_column));
+        Status st = schema_util::cast_column({src_column, src_type, ""}, new_least_common_type,
+                                             &casted_column);
+        if (!st.ok()) {
+            throw doris::Exception(ErrorCode::INVALID_ARGUMENT, st.to_string() + ", real_code:{}",
+                                   st.code());
+        }
         if (!least_common_type.get()->equals(*new_least_common_type)) {
             add_new_column_part(std::move(new_least_common_type));
         }
         data.back()->insert_range_from(*casted_column, start, length);
     }
-    return Status::OK();
 }
 
 bool ColumnObject::Subcolumn::is_finalized() const {
@@ -400,7 +404,9 @@ bool ColumnObject::Subcolumn::is_finalized() const {
 template <typename Func>
 ColumnPtr ColumnObject::apply_for_subcolumns(Func&& func, std::string_view func_name) const {
     if (!is_finalized()) {
-        LOG(FATAL) << "Cannot " << func_name << " non-finalized ColumnObject";
+        // LOG(FATAL) << "Cannot " << func_name << " non-finalized ColumnObject";
+        throw doris::Exception(doris::ErrorCode::INTERNAL_ERROR,
+                               "Cannot {} non-finalized ColumnObject", func_name);
     }
     auto res = ColumnObject::create(is_nullable);
     for (const auto& subcolumn : subcolumns) {
@@ -560,7 +566,11 @@ void ColumnObject::check_consistency() const {
     }
     for (const auto& leaf : subcolumns) {
         if (num_rows != leaf->data.size()) {
-            assert(false);
+            // LOG(FATAL) << "unmatched column:" << leaf->path.get_path()
+            //            << ", expeted rows:" << num_rows << ", but meet:" << leaf->data.size();
+            throw doris::Exception(doris::ErrorCode::INTERNAL_ERROR,
+                                   "unmatched column: {}, expeted rows: {}, but meet: {}",
+                                   leaf->path.get_path(), num_rows, leaf->data.size());
         }
     }
 }
@@ -575,7 +585,8 @@ size_t ColumnObject::size() const {
 MutableColumnPtr ColumnObject::clone_resized(size_t new_size) const {
     /// cloneResized with new_size == 0 is used for cloneEmpty().
     if (new_size != 0) {
-        LOG(FATAL) << "ColumnObject doesn't support resize to non-zero length";
+        throw doris::Exception(doris::ErrorCode::INTERNAL_ERROR,
+                               "ColumnObject doesn't support resize to non-zero length");
     }
     return ColumnObject::create(is_nullable);
 }
@@ -605,11 +616,11 @@ void ColumnObject::for_each_subcolumn(ColumnCallback callback) {
     }
 }
 
-Status ColumnObject::try_insert_from(const IColumn& src, size_t n) {
+void ColumnObject::try_insert_from(const IColumn& src, size_t n) {
     return try_insert(src[n]);
 }
 
-Status ColumnObject::try_insert(const Field& field) {
+void ColumnObject::try_insert(const Field& field) {
     const auto& object = field.get<const VariantMap&>();
     phmap::flat_hash_set<StringRef, StringRefHash> inserted;
     size_t old_size = size();
@@ -619,16 +630,16 @@ Status ColumnObject::try_insert(const Field& field) {
         if (!has_subcolumn(key)) {
             bool succ = add_sub_column(key, old_size);
             if (!succ) {
-                return Status::InvalidArgument(
-                        fmt::format("Failed to add sub column {}", key.get_path()));
+                throw doris::Exception(doris::ErrorCode::INVALID_ARGUMENT,
+                                       "Failed to add sub column {}", key.get_path());
             }
         }
         auto* subcolumn = get_subcolumn(key);
         if (!subcolumn) {
-            return Status::InvalidArgument(
-                    fmt::format("Failed to find sub column {}", key.get_path()));
+            doris::Exception(doris::ErrorCode::INVALID_ARGUMENT,
+                             fmt::format("Failed to find sub column {}", key.get_path()));
         }
-        RETURN_IF_ERROR(subcolumn->insert(value));
+        subcolumn->insert(value);
     }
     for (auto& entry : subcolumns) {
         if (!inserted.contains(entry->path.get_path())) {
@@ -636,7 +647,6 @@ Status ColumnObject::try_insert(const Field& field) {
         }
     }
     ++num_rows;
-    return Status::OK();
 }
 
 void ColumnObject::insert_default() {
@@ -674,26 +684,26 @@ Status ColumnObject::try_insert_indices_from(const IColumn& src, const int* indi
         if (*x == -1) {
             ColumnObject::insert_default();
         } else {
-            RETURN_IF_ERROR(ColumnObject::try_insert_from(src, *x));
+            ColumnObject::try_insert_from(src, *x);
         }
     }
     finalize();
     return Status::OK();
 }
 
-Status ColumnObject::try_insert_range_from(const IColumn& src, size_t start, size_t length) {
+void ColumnObject::try_insert_range_from(const IColumn& src, size_t start, size_t length) {
     const auto& src_object = assert_cast<const ColumnObject&>(src);
     if (UNLIKELY(src_object.empty())) {
-        return Status::OK();
+        return;
     }
     for (auto& entry : subcolumns) {
         if (src_object.has_subcolumn(entry->path)) {
             auto* subcolumn = src_object.get_subcolumn(entry->path);
             if (!subcolumn) {
-                return Status::InvalidArgument(
-                        fmt::format("Failed to find sub column {}", entry->path.get_path()));
+                throw doris::Exception(doris::ErrorCode::INVALID_ARGUMENT,
+                                       "Failed to find sub column {}", entry->path.get_path());
             }
-            RETURN_IF_ERROR(entry->data.insertRangeFrom(*subcolumn, start, length));
+            entry->data.insertRangeFrom(*subcolumn, start, length);
         } else {
             entry->data.insertManyDefaults(length);
         }
@@ -714,20 +724,19 @@ Status ColumnObject::try_insert_range_from(const IColumn& src, size_t start, siz
                 succ = add_sub_column(entry->path, num_rows);
             }
             if (!succ) {
-                return Status::InvalidArgument(
-                        fmt::format("Failed to add column {}", entry->path.get_path()));
+                throw doris::Exception(doris::ErrorCode::INVALID_ARGUMENT,
+                                       "Failed to add column {}", entry->path.get_path());
             }
             auto* subcolumn = get_subcolumn(entry->path);
             if (!subcolumn) {
-                return Status::InvalidArgument(
-                        fmt::format("Failed to find sub column {}", entry->path.get_path()));
+                throw doris::Exception(doris::ErrorCode::INVALID_ARGUMENT,
+                                       "Failed to find sub column {}", entry->path.get_path());
             }
-            RETURN_IF_ERROR(subcolumn->insertRangeFrom(entry->data, start, length));
+            subcolumn->insertRangeFrom(entry->data, start, length);
         }
     }
     num_rows += length;
     finalize();
-    return Status::OK();
 }
 
 void ColumnObject::pop_back(size_t length) {
