diff a/be/src/vec/data_types/get_least_supertype.cpp b/be/src/vec/data_types/get_least_supertype.cpp	(rejected hunks)
@@ -20,6 +20,7 @@
 
 #include "vec/data_types/get_least_supertype.h"
 
+#include <fmt/core.h>
 #include <fmt/format.h>
 #include <glog/logging.h>
 #include <stddef.h>
@@ -31,6 +32,7 @@
 #include <string>
 #include <vector>
 
+#include "common/status.h"
 #include "vec/common/typeid_cast.h"
 #include "vec/core/types.h"
 #include "vec/data_types/data_type.h"
@@ -45,23 +47,36 @@ namespace doris::vectorized {
 
 namespace {
 
+String type_to_string(const DataTypePtr& type) {
+    return type->get_name();
+}
+String type_to_string(const TypeIndex& type) {
+    return getTypeName(type);
+}
+
+template <typename DataTypes>
 String get_exception_message_prefix(const DataTypes& types) {
     std::stringstream res;
     res << "There is no supertype for types ";
-
     bool first = true;
     for (const auto& type : types) {
         if (!first) res << ", ";
         first = false;
-
-        res << type->get_name();
+        res << type_to_string(type);
     }
-
     return res.str();
 }
+
 } // namespace
 
-Status get_numeric_type(const TypeIndexSet& types, DataTypePtr* type) {
+void get_numeric_type(const TypeIndexSet& types, DataTypePtr* type, bool compatible_with_string) {
+    auto throw_or_return = [&](std::string_view message, int error_code) {
+        if (compatible_with_string) {
+            *type = std::make_shared<DataTypeString>();
+            return;
+        }
+        throw doris::Exception(error_code, message);
+    };
     bool all_numbers = true;
 
     size_t max_bits_of_signed_integer = 0;
@@ -104,9 +119,11 @@ Status get_numeric_type(const TypeIndexSet& types, DataTypePtr* type) {
     if (max_bits_of_signed_integer || max_bits_of_unsigned_integer ||
         max_mantissa_bits_of_floating) {
         if (!all_numbers) {
-            LOG(INFO) << " because some of them are numbers and some of them are not";
             *type = nullptr;
-            return Status::InvalidArgument("some of them are numbers and some of them are not");
+            return throw_or_return(
+                    get_exception_message_prefix(types) +
+                            " because some of them are numbers and some of them are not",
+                    doris::ErrorCode::INVALID_ARGUMENT);
         }
 
         /// If there are signed and unsigned types of same bit-width, the result must be signed number with at least one more bit.
@@ -117,8 +134,9 @@ Status get_numeric_type(const TypeIndexSet& types, DataTypePtr* type) {
 
         /// If unsigned is not covered by signed.
         if (max_bits_of_signed_integer &&
-            max_bits_of_unsigned_integer >= max_bits_of_signed_integer)
+            max_bits_of_unsigned_integer >= max_bits_of_signed_integer) {
             ++min_bit_width_of_integer;
+        }
 
         /// If the result must be floating.
         if (max_mantissa_bits_of_floating) {
@@ -126,18 +144,21 @@ Status get_numeric_type(const TypeIndexSet& types, DataTypePtr* type) {
                     std::max(min_bit_width_of_integer, max_mantissa_bits_of_floating);
             if (min_mantissa_bits <= 24) {
                 *type = std::make_shared<DataTypeFloat32>();
-                return Status::OK();
+                return;
             } else if (min_mantissa_bits <= 53) {
                 *type = std::make_shared<DataTypeFloat64>();
-                return Status::OK();
+                return;
             } else {
                 LOG(INFO) << " because some of them are integers and some are floating point "
                              "but there is no floating point type, that can exactly represent "
                              "all required integers";
                 *type = nullptr;
-                return Status::InvalidArgument(
-                        "there is no floating point type, that can exactly represent "
-                        "all required integers");
+                return throw_or_return(
+                        get_exception_message_prefix(types) +
+                                " because some of them are integers and some are floating point "
+                                "but there is no floating point type, that can exactly represent "
+                                "all required integers",
+                        doris::ErrorCode::INVALID_ARGUMENT);
             }
         }
 
@@ -145,23 +166,25 @@ Status get_numeric_type(const TypeIndexSet& types, DataTypePtr* type) {
         if (max_bits_of_signed_integer) {
             if (min_bit_width_of_integer <= 8) {
                 *type = std::make_shared<DataTypeInt8>();
-                return Status::OK();
+                return;
             } else if (min_bit_width_of_integer <= 16) {
                 *type = std::make_shared<DataTypeInt16>();
-                return Status::OK();
+                return;
             } else if (min_bit_width_of_integer <= 32) {
                 *type = std::make_shared<DataTypeInt32>();
-                return Status::OK();
+                return;
             } else if (min_bit_width_of_integer <= 64) {
                 *type = std::make_shared<DataTypeInt64>();
-                return Status::OK();
+                return;
             } else {
                 LOG(INFO) << " because some of them are signed integers and some are unsigned "
                              "integers, but there is no signed integer type, that can exactly "
                              "represent all required unsigned integer values";
-                return Status::InvalidArgument(
-                        "there is no signed integer type, that can exactly "
-                        "represent all required unsigned integer values");
+                return throw_or_return(
+                        " because some of them are signed integers and some are unsigned "
+                        "integers, but there is no signed integer type, that can exactly "
+                        "represent all required unsigned integer values",
+                        doris::ErrorCode::INVALID_ARGUMENT);
             }
         }
 
@@ -169,43 +192,50 @@ Status get_numeric_type(const TypeIndexSet& types, DataTypePtr* type) {
         {
             if (min_bit_width_of_integer <= 8) {
                 *type = std::make_shared<DataTypeUInt8>();
-                return Status::OK();
+                return;
             } else if (min_bit_width_of_integer <= 16) {
                 *type = std::make_shared<DataTypeUInt16>();
-                return Status::OK();
+                return;
             } else if (min_bit_width_of_integer <= 32) {
                 *type = std::make_shared<DataTypeUInt32>();
-                return Status::OK();
+                return;
             } else if (min_bit_width_of_integer <= 64) {
                 *type = std::make_shared<DataTypeUInt64>();
-                return Status::OK();
+                return;
             } else {
-                LOG(FATAL) << "Logical error: "
-                           << "but as all data types are unsigned integers, we must have found "
-                              "maximum unsigned integer type";
+                LOG(WARNING) << "Logical error: "
+                             << "but as all data types are unsigned integers, we must have found "
+                                "maximum unsigned integer type";
                 *type = nullptr;
-                return Status::InvalidArgument(
-                        "all data types are unsigned integers, we must have found "
-                        "maximum unsigned integer type");
+                return throw_or_return(
+                        "Logical error: " + get_exception_message_prefix(types) +
+                                " but as all data types are unsigned integers, we must have found "
+                                "maximum unsigned integer type",
+                        doris::ErrorCode::INVALID_ARGUMENT);
             }
         }
     }
     *type = nullptr;
-    return Status::OK();
 }
 
 // TODO conflict type resolve
-Status get_least_supertype(const DataTypes& types, DataTypePtr* type, bool compatible_with_string) {
+void get_least_supertype(const DataTypes& types, DataTypePtr* type, bool compatible_with_string) {
     /// Trivial cases
-
+    auto throw_or_return = [&](std::string_view message, int error_code) {
+        if (compatible_with_string) {
+            *type = std::make_shared<DataTypeString>();
+            return;
+        }
+        throw doris::Exception(error_code, String(message));
+    };
     if (types.empty()) {
         *type = std::make_shared<DataTypeNothing>();
-        return Status::OK();
+        return;
     }
 
     if (types.size() == 1) {
         *type = types[0];
-        return Status::OK();
+        return;
     }
 
     /// All types are equal
@@ -220,7 +250,7 @@ Status get_least_supertype(const DataTypes& types, DataTypePtr* type, bool compa
 
         if (all_equal) {
             *type = types[0];
-            return Status::OK();
+            return;
         }
     }
 
@@ -231,12 +261,16 @@ Status get_least_supertype(const DataTypes& types, DataTypePtr* type, bool compa
         DataTypes non_nothing_types;
         non_nothing_types.reserve(types.size());
 
-        for (const auto& type : types)
-            if (!typeid_cast<const DataTypeNothing*>(type.get()))
+        for (const auto& type : types) {
+            if (!typeid_cast<const DataTypeNothing*>(type.get())) {
                 non_nothing_types.emplace_back(type);
+            }
+        }
 
-        if (non_nothing_types.size() < types.size())
-            return get_least_supertype(non_nothing_types, type, compatible_with_string);
+        if (non_nothing_types.size() < types.size()) {
+            get_least_supertype(non_nothing_types, type, compatible_with_string);
+            return;
+        }
     }
 
     /// For Nullable
@@ -251,27 +285,28 @@ Status get_least_supertype(const DataTypes& types, DataTypePtr* type, bool compa
                         typeid_cast<const DataTypeNullable*>(type.get())) {
                 have_nullable = true;
 
-                if (!type_nullable->only_null())
+                if (!type_nullable->only_null()) {
                     nested_types.emplace_back(type_nullable->get_nested_type());
-            } else
+                }
+            } else {
                 nested_types.emplace_back(type);
+            }
         }
 
         if (have_nullable) {
             DataTypePtr nested_type;
-            Status st = get_least_supertype(nested_types, &nested_type, compatible_with_string);
-            if (!st.ok()) {
-                return st;
-            }
+            get_least_supertype(nested_types, &nested_type, compatible_with_string);
             *type = std::make_shared<DataTypeNullable>(nested_type);
-            return st;
+            return;
         }
     }
 
     /// Non-recursive rules
 
     phmap::flat_hash_set<TypeIndex> type_ids;
-    for (const auto& type : types) type_ids.insert(type->get_type_id());
+    for (const auto& type : types) {
+        type_ids.insert(type->get_type_id());
+    }
 
     /// For String and FixedString, or for different FixedStrings, the common type is String.
     /// No other types are compatible with Strings. TODO Enums?
@@ -285,12 +320,14 @@ Status get_least_supertype(const DataTypes& types, DataTypePtr* type, bool compa
                 LOG(INFO)
                         << get_exception_message_prefix(types)
                         << " because some of them are String/FixedString and some of them are not";
-                return Status::InvalidArgument(
-                        "some of them are String/FixedString and some of them are not");
+                return throw_or_return(get_exception_message_prefix(types) +
+                                               " because some of them are String/FixedString and "
+                                               "some of them are not",
+                                       doris::ErrorCode::INVALID_ARGUMENT);
             }
 
             *type = std::make_shared<DataTypeString>();
-            return Status::OK();
+            return;
         }
     }
 
@@ -304,12 +341,14 @@ Status get_least_supertype(const DataTypes& types, DataTypePtr* type, bool compa
             if (!all_date_or_datetime) {
                 LOG(INFO) << get_exception_message_prefix(types)
                           << " because some of them are Date/DateTime and some of them are not";
-                return Status::InvalidArgument(
-                        "because some of them are Date/DateTime and some of them are not");
+                return throw_or_return(
+                        get_exception_message_prefix(types) +
+                                " because some of them are Date/DateTime and some of them are not",
+                        doris::ErrorCode::INVALID_ARGUMENT);
             }
 
             *type = std::make_shared<DataTypeDateTime>();
-            return Status::OK();
+            return;
         }
     }
 
@@ -340,8 +379,10 @@ Status get_least_supertype(const DataTypes& types, DataTypePtr* type, bool compa
             if (num_supported != type_ids.size()) {
                 LOG(INFO) << get_exception_message_prefix(types)
                           << " because some of them have no lossless convertion to Decimal";
-                return Status::InvalidArgument(
-                        "some of them have no lossless convertion to Decimal");
+                return throw_or_return(
+                        get_exception_message_prefix(types) +
+                                " because some of them have no lossless convertion to Decimal",
+                        doris::ErrorCode::INVALID_ARGUMENT);
             }
 
             UInt32 max_scale = 0;
@@ -364,50 +405,58 @@ Status get_least_supertype(const DataTypes& types, DataTypePtr* type, bool compa
                 LOG(INFO) << fmt::format("{} because the least supertype is Decimal({},{})",
                                          get_exception_message_prefix(types), min_precision,
                                          max_scale);
-                return Status::InvalidArgument(
-                        fmt::format("{} because the least supertype is Decimal({},{})",
-                                    get_exception_message_prefix(types), min_precision, max_scale));
+                return throw_or_return(get_exception_message_prefix(types) +
+                                               fmt::format(" because some of them have no lossless "
+                                                           "convertion to Decimal({},{})",
+                                                           min_precision, max_scale),
+                                       doris::ErrorCode::INVALID_ARGUMENT);
             }
 
             if (have_decimal128 || min_precision > DataTypeDecimal<Decimal64>::max_precision()) {
                 *type = std::make_shared<DataTypeDecimal<Decimal128>>(
                         DataTypeDecimal<Decimal128>::max_precision(), max_scale);
-                return Status::OK();
+                return;
             }
             if (have_decimal128i || min_precision > DataTypeDecimal<Decimal64>::max_precision()) {
                 *type = std::make_shared<DataTypeDecimal<Decimal128I>>(
                         DataTypeDecimal<Decimal128I>::max_precision(), max_scale);
-                return Status::OK();
+                return;
             }
             if (have_decimal64 || min_precision > DataTypeDecimal<Decimal32>::max_precision()) {
                 *type = std::make_shared<DataTypeDecimal<Decimal64>>(
                         DataTypeDecimal<Decimal64>::max_precision(), max_scale);
-                return Status::OK();
+                return;
             }
             *type = std::make_shared<DataTypeDecimal<Decimal32>>(
                     DataTypeDecimal<Decimal32>::max_precision(), max_scale);
-            return Status::OK();
+            return;
         }
     }
 
     /// For numeric types, the most complicated part.
     {
         DataTypePtr numeric_type = nullptr;
-        Status st = get_numeric_type(type_ids, &numeric_type);
+        get_numeric_type(type_ids, &numeric_type, compatible_with_string);
         if (numeric_type) {
-            DCHECK(st.ok());
             *type = numeric_type;
-            return Status::OK();
+            return;
         }
     }
 
     /// All other data types (UUID, AggregateFunction, Enum...) are compatible only if they are the same (checked in trivial cases).
     *type = nullptr;
-    return Status::InvalidArgument(get_exception_message_prefix(types));
+    return throw_or_return(get_exception_message_prefix(types), ErrorCode::INVALID_ARGUMENT);
 }
 
-Status get_least_supertype(const TypeIndexSet& types, DataTypePtr* type,
-                           bool compatible_with_string) {
+void get_least_supertype(const TypeIndexSet& types, DataTypePtr* type,
+                         bool compatible_with_string) {
+    auto throw_or_return = [&](std::string_view message, int error_code) {
+        if (compatible_with_string) {
+            *type = std::make_shared<DataTypeString>();
+            return;
+        }
+        throw doris::Exception(error_code, String(message));
+    };
     TypeIndexSet types_set;
     for (const auto& t : types) {
         if (WhichDataType(t).is_nothing()) continue;
@@ -416,8 +465,9 @@ Status get_least_supertype(const TypeIndexSet& types, DataTypePtr* type,
             LOG(INFO) << "Cannot get common type by type ids with parametric type"
                       << getTypeName(t);
             *type = nullptr;
-            return Status::InvalidArgument(
-                    "Cannot get common type by type ids with parametric type");
+            throw doris::Exception(ErrorCode::INVALID_ARGUMENT,
+                                   "Cannot get common type by type ids with parametric type {}",
+                                   type_to_string(t));
         }
 
         types_set.insert(t);
@@ -425,31 +475,33 @@ Status get_least_supertype(const TypeIndexSet& types, DataTypePtr* type,
 
     if (types_set.empty()) {
         *type = std::make_shared<DataTypeNothing>();
-        return Status::OK();
+        return;
     }
 
     if (types.count(TypeIndex::String)) {
-        if (types.size() != 1 && !compatible_with_string) {
+        if (types.size() != 1) {
             LOG(INFO) << " because some of them are String and some of them are not";
             *type = nullptr;
-            return Status::InvalidArgument("some of them are String and some of them are not");
+            return throw_or_return(
+                    get_exception_message_prefix(types) +
+                            " because some of them are String and some of them are not",
+                    ErrorCode::INVALID_ARGUMENT);
         }
 
         *type = std::make_shared<DataTypeString>();
-        return Status::OK();
+        return;
     }
 
     /// For numeric types, the most complicated part.
     DataTypePtr numeric_type = nullptr;
-    Status st = get_numeric_type(types, &numeric_type);
+    get_numeric_type(types, &numeric_type, compatible_with_string);
     if (numeric_type) {
-        DCHECK(st.ok());
         *type = numeric_type;
-        return Status::OK();
+        return;
     }
     /// All other data types (UUID, AggregateFunction, Enum...) are compatible only if they are the same (checked in trivial cases).
     *type = nullptr;
-    return Status::InvalidArgument("unknown type");
+    return throw_or_return(get_exception_message_prefix(types), ErrorCode::INVALID_ARGUMENT);
 }
 
 } // namespace doris::vectorized
