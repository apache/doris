diff a/be/src/vec/data_types/convert_field_to_type.cpp b/be/src/vec/data_types/convert_field_to_type.cpp	(rejected hunks)
@@ -30,6 +30,8 @@
 #include <type_traits>
 #include <vector>
 
+#include "common/exception.h"
+#include "common/status.h"
 #include "vec/common/field_visitors.h"
 #include "vec/common/typeid_cast.h"
 #include "vec/core/accurate_comparison.h"
@@ -94,8 +96,9 @@ Field convert_numeric_type_impl(const Field& from) {
     }
     return result;
 }
+
 template <typename To>
-Status convert_numric_type(const Field& from, const IDataType& type, Field* to) {
+void convert_numric_type(const Field& from, const IDataType& type, Field* to) {
     if (from.get_type() == Field::Types::UInt64) {
         *to = convert_numeric_type_impl<UInt64, To>(from);
     } else if (from.get_type() == Field::Types::Int64) {
@@ -107,18 +110,17 @@ Status convert_numric_type(const Field& from, const IDataType& type, Field* to)
     } else if (from.get_type() == Field::Types::Int128) {
         *to = convert_numeric_type_impl<Int128, To>(from);
     } else {
-        return Status::InvalidArgument(
-                fmt::format("Type mismatch in IN or VALUES section. Expected: {}. Got: {}",
-                            type.get_name(), from.get_type()));
+        throw doris::Exception(ErrorCode::INVALID_ARGUMENT,
+                               "Type mismatch in IN or VALUES section. Expected: {}. Got: {}",
+                               type.get_name(), from.get_type());
     }
-    return Status::OK();
 }
 
-Status convert_field_to_typeImpl(const Field& src, const IDataType& type,
-                                 const IDataType* from_type_hint, Field* to) {
+void convert_field_to_typeImpl(const Field& src, const IDataType& type,
+                               const IDataType* from_type_hint, Field* to) {
     if (from_type_hint && from_type_hint->equals(type)) {
         *to = src;
-        return Status::OK();
+        return;
     }
     WhichDataType which_type(type);
     // TODO add more types
@@ -163,16 +165,16 @@ Status convert_field_to_typeImpl(const Field& src, const IDataType& type,
             src.get_type() == Field::Types::UInt64) {
             /// We don't need any conversion UInt64 is under type of Date and DateTime
             *to = src;
-            return Status::OK();
+            return;
         }
     } else if (which_type.is_string_or_fixed_string()) {
         if (src.get_type() == Field::Types::String) {
             *to = src;
-            return Status::OK();
+            return;
         }
         // TODO this is a very simple translator, support more complex types
         *to = apply_visitor(FieldVisitorToStringSimple(), src);
-        return Status::OK();
+        return;
     } else if (const DataTypeArray* type_array = typeid_cast<const DataTypeArray*>(&type)) {
         if (src.get_type() == Field::Types::Array) {
             const Array& src_arr = src.get<Array>();
@@ -180,14 +182,14 @@ Status convert_field_to_typeImpl(const Field& src, const IDataType& type,
             const auto& element_type = *(type_array->get_nested_type());
             Array res(src_arr_size);
             for (size_t i = 0; i < src_arr_size; ++i) {
-                RETURN_IF_ERROR(convert_field_to_type(src_arr[i], element_type, &res[i]));
+                convert_field_to_type(src_arr[i], element_type, &res[i]);
                 if (res[i].is_null() && !element_type.is_nullable()) {
-                    return Status::InvalidArgument(
-                            fmt::format("Cannot convert NULL to {}", element_type.get_name()));
+                    throw doris::Exception(ErrorCode::INVALID_ARGUMENT, "Cannot convert NULL to {}",
+                                           element_type.get_name());
                 }
             }
             *to = Field(res);
-            return Status::OK();
+            return;
         }
     }
     // else if (const DataTypeTuple* type_tuple = typeid_cast<const DataTypeTuple*>(&type)) {
@@ -229,31 +231,31 @@ Status convert_field_to_typeImpl(const Field& src, const IDataType& type,
     //         return Status::OK();
     //     }
     // }
-    return Status::InvalidArgument(
-            fmt::format("Type mismatch in IN or VALUES section. Expected: {}. Got: {}",
-                        type.get_name(), src.get_type()));
+    throw doris::Exception(ErrorCode::INVALID_ARGUMENT,
+                           "Type mismatch in IN or VALUES section. Expected: {}. Got: {}",
+                           type.get_name(), src.get_type());
 }
 } // namespace
-Status convert_field_to_type(const Field& from_value, const IDataType& to_type, Field* to,
-                             const IDataType* from_type_hint) {
+void convert_field_to_type(const Field& from_value, const IDataType& to_type, Field* to,
+                           const IDataType* from_type_hint) {
     if (from_value.is_null()) {
         *to = from_value;
-        return Status::OK();
+        return;
     }
     if (from_type_hint && from_type_hint->equals(to_type)) {
         *to = from_value;
-        return Status::OK();
+        return;
     }
     if (const auto* nullable_type = typeid_cast<const DataTypeNullable*>(&to_type)) {
         const IDataType& nested_type = *nullable_type->get_nested_type();
         /// NULL remains NULL after any conversion.
         if (WhichDataType(nested_type).is_nothing()) {
             *to = {};
-            return Status::OK();
+            return;
         }
         if (from_type_hint && from_type_hint->equals(nested_type)) {
             *to = from_value;
-            return Status::OK();
+            return;
         }
         return convert_field_to_typeImpl(from_value, nested_type, from_type_hint, to);
     } else {
