// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

#include <chrono>

#include "common/logging.h"
#include "common/sync_point.h"
#include "meta-service/doris_txn.h"
#include "meta-service/meta_service.h"
#include "meta-service/meta_service_helper.h"
#include "meta-service/meta_service_tablet_stats.h"
#include "meta-service/txn_kv.h"
#include "meta-service/txn_kv_error.h"

using namespace std::chrono;

namespace doris::cloud {

//TODO: we need move begin/commit etc txn to TxnManager
void MetaServiceImpl::begin_txn(::google::protobuf::RpcController* controller,
                                const BeginTxnRequest* request, BeginTxnResponse* response,
                                ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(begin_txn);
    if (!request->has_txn_info()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        msg = "invalid argument, missing txn info";
        return;
    }

    auto& txn_info = const_cast<TxnInfoPB&>(request->txn_info());
    std::string label = txn_info.has_label() ? txn_info.label() : "";
    int64_t db_id = txn_info.has_db_id() ? txn_info.db_id() : -1;

    if (label.empty() || db_id < 0 || txn_info.table_ids().empty() || !txn_info.has_timeout_ms()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "invalid argument, label=" << label << " db_id=" << db_id;
        msg = ss.str();
        return;
    }

    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, cloud_unique_id);
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "cannot find instance_id with cloud_unique_id="
           << (cloud_unique_id.empty() ? "(empty)" : cloud_unique_id) << " label=" << label;
        msg = ss.str();
        return;
    }

    RPC_RATE_LIMIT(begin_txn)
    //1. Generate version stamp for txn id
    std::unique_ptr<Transaction> txn;
    TxnErrorCode err = txn_kv_->create_txn(&txn);
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::CREATE>(err);
        ss << "txn_kv_->create_txn() failed, err=" << err << " label=" << label
           << " db_id=" << db_id;
        msg = ss.str();
        return;
    }

    const std::string label_key = txn_label_key({instance_id, db_id, label});
    std::string label_val;
    err = txn->get(label_key, &label_val);
    if (err != TxnErrorCode::TXN_OK && err != TxnErrorCode::TXN_KEY_NOT_FOUND) {
        code = cast_as<ErrCategory::READ>(err);
        ss << "txn->get failed(), err=" << err << " label=" << label;
        msg = ss.str();
        return;
    }

    LOG(INFO) << "txn->get label_key=" << hex(label_key) << " label=" << label << " err=" << err;

    // err == OK means label has previous txn ids.
    if (err == TxnErrorCode::TXN_OK) {
        label_val = label_val.substr(0, label_val.size() - VERSION_STAMP_LEN);
    }

    //ret > 0, means label not exist previously.
    txn->atomic_set_ver_value(label_key, label_val);
    LOG(INFO) << "txn->atomic_set_ver_value label_key=" << hex(label_key);

    TEST_SYNC_POINT_CALLBACK("begin_txn:before:commit_txn:1", &label);
    err = txn->commit();
    TEST_SYNC_POINT_CALLBACK("begin_txn:after:commit_txn:1", &label);
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::COMMIT>(err);
        ss << "txn->commit failed(), label=" << label << " err=" << err;
        msg = ss.str();
        return;
    }
    //2. Get txn id from version stamp
    txn.reset();

    err = txn_kv_->create_txn(&txn);
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::CREATE>(err);
        ss << "failed to create txn when get txn id, label=" << label << " err=" << err;
        msg = ss.str();
        return;
    }

    label_val.clear();
    err = txn->get(label_key, &label_val);
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::READ>(err);
        ss << "txn->get() failed, label=" << label << " err=" << err;
        msg = ss.str();
        return;
    }

    LOG(INFO) << "txn->get label_key=" << hex(label_key) << " label=" << label << " err=" << err;

    // Generated by TxnKv system
    int64_t txn_id = 0;
    int ret =
            get_txn_id_from_fdb_ts(std::string_view(label_val).substr(
                                           label_val.size() - VERSION_STAMP_LEN, label_val.size()),
                                   &txn_id);
    if (ret != 0) {
        code = MetaServiceCode::TXN_GEN_ID_ERR;
        ss << "get_txn_id_from_fdb_ts() failed, label=" << label << " ret=" << ret;
        msg = ss.str();
        return;
    }

    LOG(INFO) << "get_txn_id_from_fdb_ts() label=" << label << " txn_id=" << txn_id
              << " label_val.size()=" << label_val.size();

    TxnLabelPB label_pb;
    if (label_val.size() > VERSION_STAMP_LEN) {
        //3. Check label
        //label_val.size() > VERSION_STAMP_LEN means label has previous txn ids.
        if (!label_pb.ParseFromArray(label_val.data(), label_val.size() - VERSION_STAMP_LEN)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            ss << "label_pb->ParseFromString() failed, txn_id=" << txn_id << " label=" << label;
            msg = ss.str();
            return;
        }

        // Check if label already used, by following steps
        // 1. get all existing transactions
        // 2. if there is a PREPARE transaction, check if this is a retry request.
        // 3. if there is a non-aborted transaction, throw label already used exception.

        for (auto& cur_txn_id : label_pb.txn_ids()) {
            const std::string cur_info_key = txn_info_key({instance_id, db_id, cur_txn_id});
            std::string cur_info_val;
            err = txn->get(cur_info_key, &cur_info_val);
            if (err != TxnErrorCode::TXN_OK && err != TxnErrorCode::TXN_KEY_NOT_FOUND) {
                code = cast_as<ErrCategory::READ>(err);
                ss << "txn->get() failed, cur_txn_id=" << cur_txn_id << " label=" << label
                   << " err=" << err;
                msg = ss.str();
                return;
            }

            if (err == TxnErrorCode::TXN_KEY_NOT_FOUND) {
                //label_to_idx and txn info inconsistency.
                code = MetaServiceCode::TXN_ID_NOT_FOUND;
                ss << "txn->get() failed, cur_txn_id=" << cur_txn_id << " label=" << label
                   << " err=" << err;
                msg = ss.str();
                return;
            }

            TxnInfoPB cur_txn_info;
            if (!cur_txn_info.ParseFromString(cur_info_val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "cur_txn_info->ParseFromString() failed, cur_txn_id=" << cur_txn_id
                   << " label=" << label << " err=" << err;
                msg = ss.str();
                return;
            }

            VLOG_DEBUG << "cur_txn_info=" << cur_txn_info.ShortDebugString();
            if (cur_txn_info.status() == TxnStatusPB::TXN_STATUS_ABORTED) {
                continue;
            }

            if (cur_txn_info.status() == TxnStatusPB::TXN_STATUS_PREPARED ||
                cur_txn_info.status() == TxnStatusPB::TXN_STATUS_PRECOMMITTED) {
                // clang-format off
                if (cur_txn_info.has_request_id() && txn_info.has_request_id() &&
                    ((cur_txn_info.request_id().hi() == txn_info.request_id().hi()) && 
                     (cur_txn_info.request_id().lo() == txn_info.request_id().lo()))) {

                    response->set_dup_txn_id(cur_txn_info.txn_id());
                    code = MetaServiceCode::TXN_DUPLICATED_REQ;
                    ss << "db_id=" << db_id << " label=" << label << " txn_id=" << cur_txn_info.txn_id() << " dup begin txn request.";
                    msg = ss.str();
                    return;
                }
                // clang-format on
            }
            code = MetaServiceCode::TXN_LABEL_ALREADY_USED;
            ss << "Label [" << label << "] has already been used, relate to txn ["
               << cur_txn_info.txn_id() << "]";
            msg = ss.str();
            return;
        }
    }

    // Update txn_info to be put into TxnKv
    // Update txn_id in PB
    txn_info.set_txn_id(txn_id);
    // TODO:
    // check initial status must be TXN_STATUS_PREPARED or TXN_STATUS_UNKNOWN
    txn_info.set_status(TxnStatusPB::TXN_STATUS_PREPARED);

    auto now_time = system_clock::now();
    uint64_t prepare_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();

    txn_info.set_prepare_time(prepare_time);
    //4. put txn info and db_tbl
    const std::string info_key = txn_info_key({instance_id, db_id, txn_id});
    std::string info_val;
    if (!txn_info.SerializeToString(&info_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize txn_info, label=" << label << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    const std::string index_key = txn_index_key({instance_id, txn_id});
    std::string index_val;
    TxnIndexPB index_pb;
    index_pb.mutable_tablet_index()->set_db_id(db_id);
    if (!index_pb.SerializeToString(&index_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize txn_index_pb "
           << "label=" << label << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    const std::string running_key = txn_running_key({instance_id, db_id, txn_id});
    std::string running_val;
    TxnRunningPB running_pb;
    running_pb.set_timeout_time(prepare_time + txn_info.timeout_ms());
    for (auto i : txn_info.table_ids()) {
        running_pb.add_table_ids(i);
    }
    VLOG_DEBUG << "label=" << label << " txn_id=" << txn_id
               << "running_pb=" << running_pb.ShortDebugString();
    if (!running_pb.SerializeToString(&running_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize running_pb label=" << label << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    label_pb.add_txn_ids(txn_id);
    VLOG_DEBUG << "label=" << label << " txn_id=" << txn_id
               << "txn_label_pb=" << label_pb.ShortDebugString();
    if (!label_pb.SerializeToString(&label_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize txn_label_pb label=" << label << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }
    txn->atomic_set_ver_value(label_key, label_val);
    LOG(INFO) << "txn->atomic_set_ver_value label_key=" << hex(label_key) << " label=" << label
              << " txn_id=" << txn_id;

    txn->put(info_key, info_val);
    txn->put(index_key, index_val);
    txn->put(running_key, running_val);
    LOG(INFO) << "xxx put info_key=" << hex(info_key) << " txn_id=" << txn_id;
    LOG(INFO) << "xxx put running_key=" << hex(running_key) << " txn_id=" << txn_id;
    LOG(INFO) << "xxx put index_key=" << hex(index_key) << " txn_id=" << txn_id;

    err = txn->commit();
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::COMMIT>(err);
        ss << "failed to commit txn kv, label=" << label << " txn_id=" << txn_id << " err=" << err;
        msg = ss.str();
        return;
    }
    TEST_SYNC_POINT_CALLBACK("begin_txn:after:commit_txn:2", &txn_id);
    response->set_txn_id(txn_id);
}

void MetaServiceImpl::precommit_txn(::google::protobuf::RpcController* controller,
                                    const PrecommitTxnRequest* request,
                                    PrecommitTxnResponse* response,
                                    ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(precommit_txn);
    int64_t txn_id = request->has_txn_id() ? request->txn_id() : -1;
    int64_t db_id = request->has_db_id() ? request->db_id() : -1;
    if ((txn_id < 0 && db_id < 0)) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "invalid argument, "
           << "txn_id=" << txn_id << " db_id=" << db_id;
        msg = ss.str();
        return;
    }

    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, cloud_unique_id);
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "cannot find instance_id with cloud_unique_id="
           << (cloud_unique_id.empty() ? "(empty)" : cloud_unique_id) << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }
    RPC_RATE_LIMIT(precommit_txn);
    std::unique_ptr<Transaction> txn;
    TxnErrorCode err = txn_kv_->create_txn(&txn);
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::CREATE>(err);
        ss << "txn_kv_->create_txn() failed, err=" << err << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    //not provide db_id, we need read from disk.
    if (db_id < 0) {
        const std::string index_key = txn_index_key({instance_id, txn_id});
        std::string index_val;
        err = txn->get(index_key, &index_val);
        if (err != TxnErrorCode::TXN_OK) {
            code = err == TxnErrorCode::TXN_KEY_NOT_FOUND ? MetaServiceCode::TXN_ID_NOT_FOUND
                                                          : cast_as<ErrCategory::READ>(err);
            ss << "failed to get db id with txn_id=" << txn_id << " err=" << err;
            msg = ss.str();
            return;
        }
        TxnIndexPB index_pb;
        if (!index_pb.ParseFromString(index_val)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            ss << "failed to parse txn_inf"
               << " txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
        DCHECK(index_pb.has_tablet_index() == true);
        DCHECK(index_pb.tablet_index().has_db_id() == true);
        db_id = index_pb.tablet_index().db_id();
        VLOG_DEBUG << " find db_id=" << db_id << " from index";
    } else {
        db_id = request->db_id();
    }

    // Get txn info with db_id and txn_id
    const std::string info_key = txn_info_key({instance_id, db_id, txn_id});
    std::string info_val; // Will be reused when saving updated txn
    err = txn->get(info_key, &info_val);
    if (err != TxnErrorCode::TXN_OK) {
        code = err == TxnErrorCode::TXN_KEY_NOT_FOUND ? MetaServiceCode::TXN_ID_NOT_FOUND
                                                      : cast_as<ErrCategory::READ>(err);
        ss << "failed to get db id with db_id=" << db_id << " txn_id=" << txn_id << " err=" << err;
        msg = ss.str();
        return;
    }

    TxnInfoPB txn_info;
    if (!txn_info.ParseFromString(info_val)) {
        code = MetaServiceCode::PROTOBUF_PARSE_ERR;
        ss << "failed to parse txn_inf db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    DCHECK(txn_info.txn_id() == txn_id);
    if (txn_info.status() == TxnStatusPB::TXN_STATUS_ABORTED) {
        code = MetaServiceCode::TXN_ALREADY_ABORTED;
        ss << "transaction is already aborted: db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    if (txn_info.status() == TxnStatusPB::TXN_STATUS_VISIBLE) {
        code = MetaServiceCode::TXN_ALREADY_VISIBLE;
        ss << "transaction is already visible: db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
    }

    if (txn_info.status() == TxnStatusPB::TXN_STATUS_PRECOMMITTED) {
        code = MetaServiceCode::TXN_ALREADY_PRECOMMITED;
        ss << "transaction is already precommited: db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
    }

    LOG(INFO) << "before update txn_info=" << txn_info.ShortDebugString();

    // Update txn_info
    txn_info.set_status(TxnStatusPB::TXN_STATUS_PRECOMMITTED);

    auto now_time = system_clock::now();
    uint64_t precommit_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();
    txn_info.set_precommit_time(precommit_time);
    if (request->has_commit_attachment()) {
        txn_info.mutable_commit_attachment()->CopyFrom(request->commit_attachment());
    }
    LOG(INFO) << "after update txn_info=" << txn_info.ShortDebugString();

    info_val.clear();
    if (!txn_info.SerializeToString(&info_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize txn_info when saving, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    txn->put(info_key, info_val);
    LOG(INFO) << "xxx put info_key=" << hex(info_key) << " txn_id=" << txn_id;

    const std::string running_key = txn_running_key({instance_id, db_id, txn_id});
    std::string running_val;

    TxnRunningPB running_pb;
    running_pb.set_timeout_time(precommit_time + txn_info.precommit_timeout_ms());
    if (!running_pb.SerializeToString(&running_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize running_pb, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    LOG(INFO) << "xxx put running_key=" << hex(running_key) << " txn_id=" << txn_id;
    txn->put(running_key, running_val);

    err = txn->commit();
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::COMMIT>(err);
        ss << "failed to commit txn kv, txn_id=" << txn_id << " err=" << err;
        msg = ss.str();
        return;
    }
}

/**
 * 0. Extract txn_id from request
 * 1. Get db id from TxnKv with txn_id
 * 2. Get TxnInfo from TxnKv with db_id and txn_id
 * 3. Get tmp rowset meta, there may be several or hundred of tmp rowsets
 * 4. Get versions of each rowset
 * 5. Put rowset meta, which will be visible to user
 * 6. Put TxnInfo back into TxnKv with updated txn status (committed)
 * 7. Update versions of each partition
 * 8. Remove tmp rowset meta
 *
 * Note: getting version and all changes maded are in a single TxnKv transaction:
 *       step 5, 6, 7, 8
 */
void MetaServiceImpl::commit_txn(::google::protobuf::RpcController* controller,
                                 const CommitTxnRequest* request, CommitTxnResponse* response,
                                 ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(commit_txn);
    if (!request->has_txn_id()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        msg = "invalid argument, missing txn id";
        return;
    }

    int64_t txn_id = request->txn_id();

    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, cloud_unique_id);
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        msg = "empty instance_id";
        LOG(INFO) << msg << ", cloud_unique_id=" << cloud_unique_id << " txn_id=" << txn_id;
        return;
    }

    RPC_RATE_LIMIT(commit_txn)

    // Create a readonly txn for scan tmp rowset
    std::unique_ptr<Transaction> txn;
    TxnErrorCode err = txn_kv_->create_txn(&txn);
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::CREATE>(err);
        ss << "filed to create txn, txn_id=" << txn_id << " err=" << err;
        msg = ss.str();
        return;
    }

    //Get db id with txn id
    std::string index_val;
    const std::string index_key = txn_index_key({instance_id, txn_id});
    err = txn->get(index_key, &index_val);
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::READ>(err);
        ss << "failed to get db id, txn_id=" << txn_id << " err=" << err;
        msg = ss.str();
        return;
    }

    TxnIndexPB index_pb;
    if (!index_pb.ParseFromString(index_val)) {
        code = MetaServiceCode::PROTOBUF_PARSE_ERR;
        ss << "failed to parse txn_index_pb, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    DCHECK(index_pb.has_tablet_index() == true);
    DCHECK(index_pb.tablet_index().has_db_id() == true);
    int64_t db_id = index_pb.tablet_index().db_id();

    // Get temporary rowsets involved in the txn
    // This is a range scan
    MetaRowsetTmpKeyInfo rs_tmp_key_info0 {instance_id, txn_id, 0};
    MetaRowsetTmpKeyInfo rs_tmp_key_info1 {instance_id, txn_id + 1, 0};
    std::string rs_tmp_key0;
    std::string rs_tmp_key1;
    meta_rowset_tmp_key(rs_tmp_key_info0, &rs_tmp_key0);
    meta_rowset_tmp_key(rs_tmp_key_info1, &rs_tmp_key1);
    // Get rowset meta that should be commited
    //                   tmp_rowset_key -> rowset_meta
    std::vector<std::pair<std::string, doris::RowsetMetaCloudPB>> tmp_rowsets_meta;

    int num_rowsets = 0;
    std::unique_ptr<int, std::function<void(int*)>> defer_log_range(
            (int*)0x01, [rs_tmp_key0, rs_tmp_key1, &num_rowsets, &txn_id](int*) {
                LOG(INFO) << "get tmp rowset meta, txn_id=" << txn_id
                          << " num_rowsets=" << num_rowsets << " range=[" << hex(rs_tmp_key0) << ","
                          << hex(rs_tmp_key1) << ")";
            });

    std::unique_ptr<RangeGetIterator> it;
    do {
        err = txn->get(rs_tmp_key0, rs_tmp_key1, &it);
        if (err != TxnErrorCode::TXN_OK) {
            code = cast_as<ErrCategory::READ>(err);
            ss << "internal error, failed to get tmp rowset while committing, txn_id=" << txn_id
               << " err=" << err;
            msg = ss.str();
            return;
        }

        while (it->has_next()) {
            auto [k, v] = it->next();
            LOG(INFO) << "range_get rowset_tmp_key=" << hex(k) << " txn_id=" << txn_id;
            tmp_rowsets_meta.emplace_back();
            if (!tmp_rowsets_meta.back().second.ParseFromArray(v.data(), v.size())) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "malformed rowset meta, unable to initialize, txn_id=" << txn_id;
                msg = ss.str();
                ss << " key=" << hex(k);
                LOG(WARNING) << ss.str();
                return;
            }
            // Save keys that will be removed later
            tmp_rowsets_meta.back().first = std::string(k.data(), k.size());
            ++num_rowsets;
            if (!it->has_next()) rs_tmp_key0 = k;
        }
        rs_tmp_key0.push_back('\x00'); // Update to next smallest key for iteration
    } while (it->more());

    VLOG_DEBUG << "txn_id=" << txn_id << " tmp_rowsets_meta.size()=" << tmp_rowsets_meta.size();

    // Create a read/write txn for guarantee consistency
    txn.reset();
    err = txn_kv_->create_txn(&txn);
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::CREATE>(err);
        ss << "filed to create txn, txn_id=" << txn_id << " err=" << err;
        msg = ss.str();
        return;
    }

    int64_t put_size = 0;
    int64_t del_size = 0;
    int num_put_keys = 0, num_del_keys = 0;

    // Get txn info with db_id and txn_id
    std::string info_val; // Will be reused when saving updated txn
    const std::string info_key = txn_info_key({instance_id, db_id, txn_id});
    err = txn->get(info_key, &info_val);
    if (err != TxnErrorCode::TXN_OK) {
        code = err == TxnErrorCode::TXN_KEY_NOT_FOUND ? MetaServiceCode::TXN_ID_NOT_FOUND
                                                      : cast_as<ErrCategory::READ>(err);
        ss << "failed to get txn_info, db_id=" << db_id << " txn_id=" << txn_id << " err=" << err;
        msg = ss.str();
        return;
    }

    TxnInfoPB txn_info;
    if (!txn_info.ParseFromString(info_val)) {
        code = MetaServiceCode::PROTOBUF_PARSE_ERR;
        ss << "failed to parse txn_info, db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    // TODO: do more check like txn state, 2PC etc.
    DCHECK(txn_info.txn_id() == txn_id);
    if (txn_info.status() == TxnStatusPB::TXN_STATUS_ABORTED) {
        code = MetaServiceCode::TXN_ALREADY_ABORTED;
        ss << "transaction is already aborted: db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    if (txn_info.status() == TxnStatusPB::TXN_STATUS_VISIBLE) {
        code = MetaServiceCode::TXN_ALREADY_VISIBLE;
        if (request->has_is_2pc() && request->is_2pc()) {
            ss << "transaction [" << txn_id << "] is already visible, not pre-committed.";
            msg = ss.str();
            response->mutable_txn_info()->CopyFrom(txn_info);
            return;
        }
        ss << "transaction is already visible: db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        response->mutable_txn_info()->CopyFrom(txn_info);
        return;
    }

    if (request->has_is_2pc() && request->is_2pc() &&
        txn_info.status() == TxnStatusPB::TXN_STATUS_PREPARED) {
        code = MetaServiceCode::TXN_INVALID_STATUS;
        ss << "transaction is prepare, not pre-committed: db_id=" << db_id << " txn_id" << txn_id;
        msg = ss.str();
        return;
    }

    LOG(INFO) << "txn_id=" << txn_id << " txn_info=" << txn_info.ShortDebugString();

    // Prepare rowset meta and new_versions
    std::vector<std::pair<std::string, std::string>> rowsets;
    std::map<std::string, uint64_t> new_versions;
    std::map<int64_t, TabletStats> tablet_stats; // tablet_id -> stats
    std::map<int64_t, TabletIndexPB> table_ids;  // tablet_id -> {table/index/partition}_id
    std::map<int64_t, std::vector<int64_t>> table_id_tablet_ids; // table_id -> tablets_ids
    rowsets.reserve(tmp_rowsets_meta.size());
    for (auto& [_, i] : tmp_rowsets_meta) {
        int64_t tablet_id = i.tablet_id();
        // Get version for the rowset
        if (table_ids.count(tablet_id) == 0) {
            MetaTabletIdxKeyInfo key_info {instance_id, tablet_id};
            auto [key, val] = std::make_tuple(std::string(""), std::string(""));
            meta_tablet_idx_key(key_info, &key);
            TxnErrorCode err = txn->get(key, &val);
            if (err != TxnErrorCode::TXN_OK) { // Must be TXN_OK, an existing value
                code = cast_as<ErrCategory::READ>(err);
                ss << "failed to get tablet table index ids,"
                   << (err == TxnErrorCode::TXN_KEY_NOT_FOUND ? " not found" : " internal error")
                   << " tablet_id=" << tablet_id << " key=" << hex(key);
                msg = ss.str();
                LOG(INFO) << msg << " err=" << err << " txn_id=" << txn_id;
                return;
            }
            if (!table_ids[tablet_id].ParseFromString(val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "malformed tablet index value tablet_id=" << tablet_id
                   << " txn_id=" << txn_id;
                msg = ss.str();
                return;
            }
            table_id_tablet_ids[table_ids[tablet_id].table_id()].push_back(tablet_id);
            VLOG_DEBUG << "tablet_id:" << tablet_id
                       << " value:" << table_ids[tablet_id].ShortDebugString();
        }

        int64_t table_id = table_ids[tablet_id].table_id();
        int64_t partition_id = i.partition_id();

        std::string ver_key = version_key({instance_id, db_id, table_id, partition_id});
        int64_t version = -1;
        std::string ver_val_str;
        int64_t new_version = -1;
        VersionPB version_pb;
        if (new_versions.count(ver_key) == 0) {
            err = txn->get(ver_key, &ver_val_str);
            if (err != TxnErrorCode::TXN_OK && err != TxnErrorCode::TXN_KEY_NOT_FOUND) {
                code = cast_as<ErrCategory::READ>(err);
                ss << "failed to get version, table_id=" << table_id
                   << "partition_id=" << partition_id << " key=" << hex(ver_key);
                msg = ss.str();
                LOG(INFO) << msg << " txn_id=" << txn_id;
                return;
            }

            if (err == TxnErrorCode::TXN_KEY_NOT_FOUND) {
                // Maybe first version
                version = 1;
            } else {
                if (!version_pb.ParseFromString(ver_val_str)) {
                    code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                    ss << "failed to parse ver_val_str"
                       << " txn_id=" << txn_id << " key=" << hex(ver_key);
                    msg = ss.str();
                    return;
                }
                version = version_pb.version();
            }
            new_version = version + 1;
            new_versions.insert({std::move(ver_key), new_version});
        } else {
            new_version = new_versions[ver_key];
        }

        // Update rowset version
        i.set_start_version(new_version);
        i.set_end_version(new_version);

        std::string key = meta_rowset_key({instance_id, tablet_id, i.end_version()});
        std::string val;
        if (!i.SerializeToString(&val)) {
            code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
            ss << "failed to serialize rowset_meta, txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
        rowsets.emplace_back(std::move(key), std::move(val));

        // Accumulate affected rows
        auto& stats = tablet_stats[tablet_id];
        stats.data_size += i.data_disk_size();
        stats.num_rows += i.num_rows();
        ++stats.num_rowsets;
        stats.num_segs += i.num_segments();
    } // for tmp_rowsets_meta

    // process mow table, check lock and remove pending key
    for (auto table_id : request->mow_table_ids()) {
        std::string lock_key = meta_delete_bitmap_update_lock_key({instance_id, table_id, -1});
        std::string lock_val;
        err = txn->get(lock_key, &lock_val);
        LOG(INFO) << "get delete bitmap update lock info, table_id=" << table_id
                  << " key=" << hex(lock_key) << " err=" << err;
        if (err != TxnErrorCode::TXN_OK) {
            ss << "failed to get delete bitmap update lock key info, instance_id=" << instance_id
               << " table_id=" << table_id << " key=" << hex(lock_key) << " err=" << err;
            msg = ss.str();
            code = cast_as<ErrCategory::READ>(err);
            return;
        }
        DeleteBitmapUpdateLockPB lock_info;
        if (!lock_info.ParseFromString(lock_val)) [[unlikely]] {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            msg = "failed to parse DeleteBitmapUpdateLockPB";
            return;
        }
        if (lock_info.lock_id() != request->txn_id()) {
            msg = "lock is expired";
            code = MetaServiceCode::LOCK_EXPIRED;
            return;
        }
        txn->remove(lock_key);
        LOG(INFO) << "xxx remove delete bitmap lock, lock_key=" << hex(lock_key)
                  << " txn_id=" << txn_id;

        for (auto tablet_id : table_id_tablet_ids[table_id]) {
            std::string pending_key = meta_pending_delete_bitmap_key({instance_id, tablet_id});
            txn->remove(pending_key);
            LOG(INFO) << "xxx remove delete bitmap pending key, pending_key=" << hex(pending_key)
                      << " txn_id=" << txn_id;
        }
    }

    // Save rowset meta
    num_put_keys += rowsets.size();
    for (auto& i : rowsets) {
        size_t rowset_size = i.first.size() + i.second.size();
        txn->put(i.first, i.second);
        put_size += rowset_size;
        LOG(INFO) << "xxx put rowset_key=" << hex(i.first) << " txn_id=" << txn_id
                  << " rowset_size=" << rowset_size;
    }

    // Save versions
    num_put_keys += new_versions.size();
    for (auto& i : new_versions) {
        std::string ver_val;
        VersionPB version_pb;
        version_pb.set_version(i.second);
        if (!version_pb.SerializeToString(&ver_val)) {
            code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
            ss << "failed to serialize version_pb when saving, txn_id=" << txn_id;
            msg = ss.str();
            return;
        }

        txn->put(i.first, ver_val);
        put_size += i.first.size() + ver_val.size();
        LOG(INFO) << "xxx put version_key=" << hex(i.first) << " version:" << i.second
                  << " txn_id=" << txn_id;

        std::string_view ver_key = i.first;
        //VersionKeyInfo  {instance_id, db_id, table_id, partition_id}
        ver_key.remove_prefix(1); // Remove key space
        std::vector<std::tuple<std::variant<int64_t, std::string>, int, int>> out;
        int ret = decode_key(&ver_key, &out);
        if (ret != 0) [[unlikely]] {
            // decode version key error means this is something wrong,
            // we can not continue this txn
            LOG(WARNING) << "failed to decode key, ret=" << ret << " key=" << hex(ver_key);
            code = MetaServiceCode::UNDEFINED_ERR;
            msg = "decode version key error";
            return;
        }

        int64_t table_id = std::get<int64_t>(std::get<0>(out[4]));
        int64_t partition_id = std::get<int64_t>(std::get<0>(out[5]));
        VLOG_DEBUG << " table_id=" << table_id << " partition_id=" << partition_id;

        response->add_table_ids(table_id);
        response->add_partition_ids(partition_id);
        response->add_versions(i.second);
    }

    LOG(INFO) << " before update txn_info=" << txn_info.ShortDebugString();

    // Update txn_info
    txn_info.set_status(TxnStatusPB::TXN_STATUS_VISIBLE);

    auto now_time = system_clock::now();
    uint64_t commit_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();
    if ((txn_info.prepare_time() + txn_info.timeout_ms()) < commit_time) {
        code = MetaServiceCode::UNDEFINED_ERR;
        msg = fmt::format("txn is expired, not allow to commit txn_id={}", txn_id);
        LOG(INFO) << msg << " prepare_time=" << txn_info.prepare_time()
                  << " timeout_ms=" << txn_info.timeout_ms() << " commit_time=" << commit_time;
        return;
    }
    txn_info.set_commit_time(commit_time);
    txn_info.set_finish_time(commit_time);
    if (request->has_commit_attachment()) {
        txn_info.mutable_commit_attachment()->CopyFrom(request->commit_attachment());
    }
    LOG(INFO) << "after update txn_info=" << txn_info.ShortDebugString();
    info_val.clear();
    if (!txn_info.SerializeToString(&info_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize txn_info when saving, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }
    txn->put(info_key, info_val);
    put_size += info_key.size() + info_val.size();
    ++num_put_keys;
    LOG(INFO) << "xxx put info_key=" << hex(info_key) << " txn_id=" << txn_id;

    // Update stats of affected tablet
    std::deque<std::string> kv_pool;
    std::function<void(const StatsTabletKeyInfo&, const TabletStats&)> update_tablet_stats;
    if (config::split_tablet_stats) {
        update_tablet_stats = [&](const StatsTabletKeyInfo& info, const TabletStats& stats) {
            if (stats.num_segs > 0) {
                auto& data_size_key = kv_pool.emplace_back();
                stats_tablet_data_size_key(info, &data_size_key);
                txn->atomic_add(data_size_key, stats.data_size);
                auto& num_rows_key = kv_pool.emplace_back();
                stats_tablet_num_rows_key(info, &num_rows_key);
                txn->atomic_add(num_rows_key, stats.num_rows);
                auto& num_segs_key = kv_pool.emplace_back();
                stats_tablet_num_segs_key(info, &num_segs_key);
                txn->atomic_add(num_segs_key, stats.num_segs);
                put_size += data_size_key.size() + num_rows_key.size() + num_segs_key.size() + 24;
                num_put_keys += 3;
            }
            auto& num_rowsets_key = kv_pool.emplace_back();
            stats_tablet_num_rowsets_key(info, &num_rowsets_key);
            txn->atomic_add(num_rowsets_key, stats.num_rowsets);
            put_size += num_rowsets_key.size() + 8;
            ++num_put_keys;
        };
    } else {
        update_tablet_stats = [&](const StatsTabletKeyInfo& info, const TabletStats& stats) {
            auto& key = kv_pool.emplace_back();
            stats_tablet_key(info, &key);
            auto& val = kv_pool.emplace_back();
            TxnErrorCode err = txn->get(key, &val);
            if (err != TxnErrorCode::TXN_OK) {
                code = err == TxnErrorCode::TXN_KEY_NOT_FOUND ? MetaServiceCode::TABLET_NOT_FOUND
                                                              : cast_as<ErrCategory::READ>(err);
                msg = fmt::format("failed to get tablet stats, err={} tablet_id={}", err,
                                  std::get<4>(info));
                return;
            }
            TabletStatsPB stats_pb;
            if (!stats_pb.ParseFromString(val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                msg = fmt::format("malformed tablet stats value, key={}", hex(key));
                return;
            }
            stats_pb.set_data_size(stats_pb.data_size() + stats.data_size);
            stats_pb.set_num_rows(stats_pb.num_rows() + stats.num_rows);
            stats_pb.set_num_rowsets(stats_pb.num_rowsets() + stats.num_rowsets);
            stats_pb.set_num_segments(stats_pb.num_segments() + stats.num_segs);
            stats_pb.SerializeToString(&val);
            txn->put(key, val);
            put_size += key.size() + val.size();
            ++num_put_keys;
        };
    }
    for (auto& [tablet_id, stats] : tablet_stats) {
        DCHECK(table_ids.count(tablet_id));
        auto& tablet_idx = table_ids[tablet_id];
        StatsTabletKeyInfo info {instance_id, tablet_idx.table_id(), tablet_idx.index_id(),
                                 tablet_idx.partition_id(), tablet_id};
        update_tablet_stats(info, stats);
        if (code != MetaServiceCode::OK) return;
    }
    // Remove tmp rowset meta
    num_del_keys += tmp_rowsets_meta.size();
    for (auto& [k, _] : tmp_rowsets_meta) {
        txn->remove(k);
        del_size += k.size();
        LOG(INFO) << "xxx remove tmp_rowset_key=" << hex(k) << " txn_id=" << txn_id;
    }

    const std::string running_key = txn_running_key({instance_id, db_id, txn_id});
    LOG(INFO) << "xxx remove running_key=" << hex(running_key) << " txn_id=" << txn_id;
    txn->remove(running_key);
    del_size += running_key.size();
    ++num_del_keys;

    std::string recycle_val;
    std::string recycle_key = recycle_txn_key({instance_id, db_id, txn_id});
    RecycleTxnPB recycle_pb;
    recycle_pb.set_creation_time(commit_time);
    recycle_pb.set_label(txn_info.label());

    if (!recycle_pb.SerializeToString(&recycle_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize recycle_pb, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }
    txn->put(recycle_key, recycle_val);
    put_size += recycle_key.size() + recycle_val.size();
    ++num_put_keys;

    if (txn_info.load_job_source_type() ==
        LoadJobSourceTypePB::LOAD_JOB_SRC_TYPE_ROUTINE_LOAD_TASK) {
        if (!request->has_commit_attachment()) {
            ss << "failed to get commit attachment from req, db_id=" << db_id
               << " txn_id=" << txn_id;
            msg = ss.str();
            return;
        }

        TxnCommitAttachmentPB txn_commit_attachment = request->commit_attachment();
        RLTaskTxnCommitAttachmentPB commit_attachment =
                txn_commit_attachment.rl_task_txn_commit_attachment();
        int64_t job_id = commit_attachment.job_id();

        std::string rl_progress_key;
        std::string rl_progress_val;
        bool prev_progress_existed = true;
        RLJobProgressKeyInfo rl_progress_key_info {instance_id, db_id, job_id};
        rl_job_progress_key_info(rl_progress_key_info, &rl_progress_key);
        TxnErrorCode err = txn->get(rl_progress_key, &rl_progress_val);
        if (err != TxnErrorCode::TXN_OK) {
            if (err == TxnErrorCode::TXN_KEY_NOT_FOUND) {
                prev_progress_existed = false;
            } else {
                code = cast_as<ErrCategory::READ>(err);
                ss << "failed to get txn_info, db_id=" << db_id << " txn_id=" << txn_id
                   << " err=" << err;
                msg = ss.str();
                return;
            }
        }

        RoutineLoadProgressPB prev_progress_info;
        if (prev_progress_existed) {
            if (!prev_progress_info.ParseFromString(rl_progress_val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "failed to parse txn_info, db_id=" << db_id << " txn_id=" << txn_id;
                msg = ss.str();
                return;
            }

            int cal_row_num = 0;
            for (auto const& elem : commit_attachment.progress().partition_to_offset()) {
                if (elem.second >= 0) {
                    auto it = prev_progress_info.partition_to_offset().find(elem.first);
                    if (it != prev_progress_info.partition_to_offset().end() && it->second >= 0) {
                        cal_row_num += elem.second - it->second;
                    } else {
                        cal_row_num += elem.second + 1;
                    }
                }
            }

            LOG(INFO) << " calculated row num " << cal_row_num << " actual row num "
                      << commit_attachment.loaded_rows() << " prev progress "
                      << prev_progress_info.DebugString();

            if (cal_row_num == 0) {
                LOG(WARNING) << " repeated to load task in routine load, db_id=" << db_id
                             << " txn_id=" << txn_id << " calculated row num " << cal_row_num
                             << " actual row num " << commit_attachment.loaded_rows();
                return;
            }
        }

        std::string new_progress_val;
        RoutineLoadProgressPB new_progress_info;
        new_progress_info.CopyFrom(commit_attachment.progress());
        for (auto const& elem : prev_progress_info.partition_to_offset()) {
            auto it = new_progress_info.partition_to_offset().find(elem.first);
            if (it == new_progress_info.partition_to_offset().end()) {
                new_progress_info.mutable_partition_to_offset()->insert(elem);
            }
        }

        if (!new_progress_info.SerializeToString(&new_progress_val)) {
            code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
            ss << "failed to serialize new progress val, txn_id=" << txn_info.txn_id();
            msg = ss.str();
            return;
        }
        txn->put(rl_progress_key, new_progress_val);
    }

    LOG(INFO) << "xxx commit_txn put recycle_key key=" << hex(recycle_key) << " txn_id=" << txn_id;
    LOG(INFO) << "commit_txn put_size=" << put_size << " del_size=" << del_size
              << " num_put_keys=" << num_put_keys << " num_del_keys=" << num_del_keys
              << " txn_id=" << txn_id;

    // Finally we are done...
    err = txn->commit();
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::COMMIT>(err);
        ss << "failed to commit kv txn, txn_id=" << txn_id << " err=" << err;
        msg = ss.str();
        return;
    }
    response->mutable_txn_info()->CopyFrom(txn_info);
} // end commit_txn

void MetaServiceImpl::abort_txn(::google::protobuf::RpcController* controller,
                                const AbortTxnRequest* request, AbortTxnResponse* response,
                                ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(abort_txn);
    // Get txn id
    int64_t txn_id = request->has_txn_id() ? request->txn_id() : -1;
    std::string label = request->has_label() ? request->label() : "";
    int64_t db_id = request->has_db_id() ? request->db_id() : -1;
    if (txn_id < 0 && (label.empty() || db_id < 0)) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "invalid txn id and label, db_id=" << db_id << " txn_id=" << txn_id
           << " label=" << label;
        msg = ss.str();
        return;
    }

    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, request->cloud_unique_id());
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "cannot find instance_id with cloud_unique_id="
           << (cloud_unique_id.empty() ? "(empty)" : cloud_unique_id) << " label=" << label
           << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    RPC_RATE_LIMIT(abort_txn);
    std::unique_ptr<Transaction> txn;
    TxnErrorCode err = txn_kv_->create_txn(&txn);
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::CREATE>(err);
        ss << "filed to txn_kv_->create_txn(), txn_id=" << txn_id << " label=" << label
           << " err=" << err;
        msg = ss.str();
        return;
    }

    std::string info_key; // Will be used when saving updated txn
    std::string info_val; // Will be reused when saving updated txn
    TxnInfoPB txn_info;
    //TODO: split with two function.
    //there two ways to abort txn:
    //1. abort txn by txn id
    //2. abort txn by label and db_id
    if (txn_id > 0) {
        VLOG_DEBUG << "abort_txn by txn_id";
        //abort txn by txn id
        // Get db id with txn id

        std::string index_key;
        std::string index_val;
        //not provide db_id, we need read from disk.
        if (!request->has_db_id()) {
            index_key = txn_index_key({instance_id, txn_id});
            err = txn->get(index_key, &index_val);
            if (err != TxnErrorCode::TXN_OK) {
                code = err == TxnErrorCode::TXN_KEY_NOT_FOUND ? MetaServiceCode::TXN_ID_NOT_FOUND
                                                              : cast_as<ErrCategory::READ>(err);
                ss << "failed to get db id, txn_id=" << txn_id << " err=" << err;
                msg = ss.str();
                return;
            }

            TxnIndexPB index_pb;
            if (!index_pb.ParseFromString(index_val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "failed to parse txn_index_val"
                   << " txn_id=" << txn_id;
                msg = ss.str();
                return;
            }
            DCHECK(index_pb.has_tablet_index() == true);
            DCHECK(index_pb.tablet_index().has_db_id() == true);
            db_id = index_pb.tablet_index().db_id();
        } else {
            db_id = request->db_id();
        }

        // Get txn info with db_id and txn_id
        info_key = txn_info_key({instance_id, db_id, txn_id});
        err = txn->get(info_key, &info_val);
        if (err != TxnErrorCode::TXN_OK) {
            code = err == TxnErrorCode::TXN_KEY_NOT_FOUND ? MetaServiceCode::TXN_ID_NOT_FOUND
                                                          : cast_as<ErrCategory::READ>(err);
            ss << "failed to get txn_info, db_id=" << db_id << "txn_id=" << txn_id << "err=" << err;
            msg = ss.str();
            return;
        }

        if (!txn_info.ParseFromString(info_val)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            ss << "failed to parse txn_info db_id=" << db_id << "txn_id=" << txn_id;
            msg = ss.str();
            return;
        }

        DCHECK(txn_info.txn_id() == txn_id);

        //check state is valid.
        if (txn_info.status() == TxnStatusPB::TXN_STATUS_ABORTED) {
            code = MetaServiceCode::TXN_ALREADY_ABORTED;
            ss << "transaction is already abort db_id=" << db_id << "txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
        if (txn_info.status() == TxnStatusPB::TXN_STATUS_VISIBLE) {
            code = MetaServiceCode::TXN_ALREADY_VISIBLE;
            ss << "transaction is already visible db_id=" << db_id << "txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
    } else {
        VLOG_DEBUG << "abort_txn by db_id and txn label";
        //abort txn by label.
        std::string label_key = txn_label_key({instance_id, db_id, label});
        std::string label_val;
        err = txn->get(label_key, &label_val);
        if (err != TxnErrorCode::TXN_OK) {
            code = cast_as<ErrCategory::READ>(err);
            ss << "txn->get() failed, label=" << label << " err=" << err;
            msg = ss.str();
            return;
        }

        //label index not exist
        if (err == TxnErrorCode::TXN_KEY_NOT_FOUND) {
            code = MetaServiceCode::TXN_LABEL_NOT_FOUND;
            ss << "label not found, db_id=" << db_id << " label=" << label << " err=" << err;
            msg = ss.str();
            return;
        }

        TxnLabelPB label_pb;
        DCHECK(label_val.size() > VERSION_STAMP_LEN);
        if (!label_pb.ParseFromArray(label_val.data(), label_val.size() - VERSION_STAMP_LEN)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            ss << "txn_label_pb->ParseFromString() failed, label=" << label;
            msg = ss.str();
            return;
        }

        int64_t prepare_txn_id = 0;
        //found prepare state txn for abort
        for (auto& cur_txn_id : label_pb.txn_ids()) {
            std::string cur_info_key = txn_info_key({instance_id, db_id, cur_txn_id});
            std::string cur_info_val;
            err = txn->get(cur_info_key, &cur_info_val);
            if (err != TxnErrorCode::TXN_OK) {
                code = cast_as<ErrCategory::READ>(err);
                std::stringstream ss;
                ss << "txn->get() failed, cur_txn_id=" << cur_txn_id << " err=" << err;
                msg = ss.str();
                return;
            }
            // ret == 0
            TxnInfoPB cur_txn_info;
            if (!cur_txn_info.ParseFromString(cur_info_val)) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                std::stringstream ss;
                ss << "cur_txn_info->ParseFromString() failed, cur_txn_id=" << cur_txn_id;
                msg = ss.str();
                return;
            }
            VLOG_DEBUG << "cur_txn_info=" << cur_txn_info.ShortDebugString();
            //TODO: 2pc else need to check TxnStatusPB::TXN_STATUS_PRECOMMITTED
            if ((cur_txn_info.status() == TxnStatusPB::TXN_STATUS_PREPARED) ||
                (cur_txn_info.status() == TxnStatusPB::TXN_STATUS_PRECOMMITTED)) {
                prepare_txn_id = cur_txn_id;
                txn_info = std::move(cur_txn_info);
                info_key = std::move(cur_info_key);
                DCHECK_EQ(prepare_txn_id, txn_info.txn_id())
                        << "prepare_txn_id=" << prepare_txn_id << " txn_id=" << txn_info.txn_id();
                break;
            }
        }

        if (prepare_txn_id == 0) {
            code = MetaServiceCode::TXN_INVALID_STATUS;
            std::stringstream ss;
            ss << "running transaction not found, db_id=" << db_id << " label=" << label;
            msg = ss.str();
            return;
        }
    }

    auto now_time = system_clock::now();
    uint64_t finish_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();

    // Update txn_info
    txn_info.set_status(TxnStatusPB::TXN_STATUS_ABORTED);
    txn_info.set_finish_time(finish_time);
    request->has_reason() ? txn_info.set_reason(request->reason())
                          : txn_info.set_reason("User Abort");

    if (request->has_commit_attachment()) {
        txn_info.mutable_commit_attachment()->CopyFrom(request->commit_attachment());
    }

    info_val.clear();
    if (!txn_info.SerializeToString(&info_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize txn_info when saving, txn_id=" << txn_info.txn_id();
        msg = ss.str();
        return;
    }
    LOG(INFO) << "check watermark conflict, txn_info=" << txn_info.ShortDebugString();
    txn->put(info_key, info_val);
    LOG(INFO) << "xxx put info_key=" << hex(info_key) << " txn_id=" << txn_info.txn_id();

    std::string running_key = txn_running_key({instance_id, db_id, txn_info.txn_id()});
    txn->remove(running_key);
    LOG(INFO) << "xxx remove running_key=" << hex(running_key) << " txn_id=" << txn_info.txn_id();

    std::string recycle_key = recycle_txn_key({instance_id, db_id, txn_info.txn_id()});
    std::string recycle_val;
    RecycleTxnPB recycle_pb;
    recycle_pb.set_creation_time(finish_time);
    recycle_pb.set_label(txn_info.label());

    if (!recycle_pb.SerializeToString(&recycle_val)) {
        code = MetaServiceCode::PROTOBUF_SERIALIZE_ERR;
        ss << "failed to serialize recycle_pb, txn_id=" << txn_info.txn_id();
        msg = ss.str();
        return;
    }
    txn->put(recycle_key, recycle_val);
    LOG(INFO) << "xxx put recycle_key=" << hex(recycle_key) << " txn_id=" << txn_info.txn_id();

    err = txn->commit();
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::COMMIT>(err);
        ss << "failed to commit kv txn, txn_id=" << txn_info.txn_id() << " err=" << err;
        msg = ss.str();
        return;
    }
    response->mutable_txn_info()->CopyFrom(txn_info);
}

void MetaServiceImpl::get_txn(::google::protobuf::RpcController* controller,
                              const GetTxnRequest* request, GetTxnResponse* response,
                              ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(get_txn);
    int64_t txn_id = request->has_txn_id() ? request->txn_id() : -1;
    int64_t db_id = request->has_db_id() ? request->db_id() : -1;
    if (txn_id < 0) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "invalid txn_id, it may be not given or set properly, txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, cloud_unique_id);
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "cannot find instance_id with cloud_unique_id="
           << (cloud_unique_id.empty() ? "(empty)" : cloud_unique_id);
        msg = ss.str();
        return;
    }

    RPC_RATE_LIMIT(get_txn)
    std::unique_ptr<Transaction> txn;
    TxnErrorCode err = txn_kv_->create_txn(&txn);
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::CREATE>(err);
        ss << "failed to create txn, txn_id=" << txn_id << " err=" << err;
        msg = ss.str();
        return;
    }

    //not provide db_id, we need read from disk.
    if (db_id < 0) {
        const std::string index_key = txn_index_key({instance_id, txn_id});
        std::string index_val;
        err = txn->get(index_key, &index_val);
        if (err != TxnErrorCode::TXN_OK) {
            code = err == TxnErrorCode::TXN_KEY_NOT_FOUND ? MetaServiceCode::TXN_ID_NOT_FOUND
                                                          : cast_as<ErrCategory::READ>(err);
            ss << "failed to get db id with txn_id=" << txn_id << " err=" << err;
            msg = ss.str();
            return;
        }

        TxnIndexPB index_pb;
        if (!index_pb.ParseFromString(index_val)) {
            code = MetaServiceCode::PROTOBUF_PARSE_ERR;
            ss << "failed to parse txn_inf"
               << " txn_id=" << txn_id;
            msg = ss.str();
            return;
        }
        DCHECK(index_pb.has_tablet_index() == true);
        DCHECK(index_pb.tablet_index().has_db_id() == true);
        db_id = index_pb.tablet_index().db_id();
        if (db_id <= 0) {
            ss << "internal error: unexpected db_id " << db_id;
            code = MetaServiceCode::UNDEFINED_ERR;
            msg = ss.str();
            return;
        }
    }

    // Get txn info with db_id and txn_id
    const std::string info_key = txn_info_key({instance_id, db_id, txn_id});
    std::string info_val;
    err = txn->get(info_key, &info_val);
    if (err != TxnErrorCode::TXN_OK) {
        code = err == TxnErrorCode::TXN_KEY_NOT_FOUND ? MetaServiceCode::TXN_ID_NOT_FOUND
                                                      : cast_as<ErrCategory::READ>(err);
        ss << "failed to get db id with db_id=" << db_id << " txn_id=" << txn_id << " err=" << err;
        msg = ss.str();
        return;
    }

    TxnInfoPB txn_info;
    if (!txn_info.ParseFromString(info_val)) {
        code = MetaServiceCode::PROTOBUF_PARSE_ERR;
        ss << "failed to parse txn_info db_id=" << db_id << " txn_id=" << txn_id;
        msg = ss.str();
        return;
    }

    VLOG_DEBUG << "txn_info=" << txn_info.ShortDebugString();
    DCHECK(txn_info.txn_id() == txn_id);
    response->mutable_txn_info()->CopyFrom(txn_info);
}

//To get current max txn id for schema change watermark etc.
void MetaServiceImpl::get_current_max_txn_id(::google::protobuf::RpcController* controller,
                                             const GetCurrentMaxTxnRequest* request,
                                             GetCurrentMaxTxnResponse* response,
                                             ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(get_current_max_txn_id);
    // TODO: For auth
    instance_id = get_instance_id(resource_mgr_, request->cloud_unique_id());
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        msg = "empty instance_id";
        LOG(INFO) << msg << ", cloud_unique_id=" << request->cloud_unique_id();
        return;
    }
    RPC_RATE_LIMIT(get_current_max_txn_id)
    std::unique_ptr<Transaction> txn;
    TxnErrorCode err = txn_kv_->create_txn(&txn);
    if (err != TxnErrorCode::TXN_OK) {
        msg = "failed to create txn";
        code = cast_as<ErrCategory::CREATE>(err);
        return;
    }

    const std::string key = "schema change";
    std::string val;
    err = txn->get(key, &val);
    if (err != TxnErrorCode::TXN_OK && err != TxnErrorCode::TXN_KEY_NOT_FOUND) {
        code = cast_as<ErrCategory::READ>(err);
        std::stringstream ss;
        ss << "txn->get() failed, err=" << err;
        msg = ss.str();
        return;
    }
    int64_t read_version = 0;
    err = txn->get_read_version(&read_version);
    if (err != TxnErrorCode::TXN_OK) {
        code = cast_as<ErrCategory::READ>(err);
        std::stringstream ss;
        ss << "get read version failed, ret=" << err;
        msg = ss.str();
        return;
    }

    int64_t current_max_txn_id = read_version << 10;
    VLOG_DEBUG << "read_version=" << read_version << " current_max_txn_id=" << current_max_txn_id;
    response->set_current_max_txn_id(current_max_txn_id);
}

void MetaServiceImpl::check_txn_conflict(::google::protobuf::RpcController* controller,
                                         const CheckTxnConflictRequest* request,
                                         CheckTxnConflictResponse* response,
                                         ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(check_txn_conflict);
    if (!request->has_db_id() || !request->has_end_txn_id() || (request->table_ids_size() <= 0)) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        msg = "invalid db id, end txn id or table_ids.";
        return;
    }
    // TODO: For auth
    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, cloud_unique_id);
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "cannot find instance_id with cloud_unique_id="
           << (cloud_unique_id.empty() ? "(empty)" : cloud_unique_id);
        msg = ss.str();
        return;
    }
    RPC_RATE_LIMIT(check_txn_conflict)
    int64_t db_id = request->db_id();

    std::string begin_running_key = txn_running_key({instance_id, db_id, 0});
    std::string end_running_key = txn_running_key({instance_id, db_id, request->end_txn_id()});
    LOG(INFO) << "begin_running_key:" << hex(begin_running_key)
              << " end_running_key:" << hex(end_running_key);

    std::unique_ptr<Transaction> txn;
    TxnErrorCode err = txn_kv_->create_txn(&txn);
    if (err != TxnErrorCode::TXN_OK) {
        msg = "failed to create txn";
        code = cast_as<ErrCategory::CREATE>(err);
        return;
    }

    //TODO: use set to replace
    std::vector<int64_t> src_table_ids(request->table_ids().begin(), request->table_ids().end());
    std::sort(src_table_ids.begin(), src_table_ids.end());
    std::unique_ptr<RangeGetIterator> it;
    int64_t skip_timeout_txn_cnt = 0;
    int total_iteration_cnt = 0;
    do {
        err = txn->get(begin_running_key, end_running_key, &it, true);
        if (err != TxnErrorCode::TXN_OK) {
            code = cast_as<ErrCategory::READ>(err);
            ss << "failed to get txn running info. err=" << err;
            msg = ss.str();
            LOG(WARNING) << msg;
            return;
        }

        VLOG_DEBUG << "begin_running_key=" << hex(begin_running_key)
                   << " end_running_key=" << hex(end_running_key)
                   << " it->has_next()=" << it->has_next();

        auto now_time = system_clock::now();
        uint64_t check_time = duration_cast<milliseconds>(now_time.time_since_epoch()).count();
        while (it->has_next()) {
            total_iteration_cnt++;
            auto [k, v] = it->next();
            LOG(INFO) << "check watermark conflict range_get txn_run_key=" << hex(k);
            TxnRunningPB running_pb;
            if (!running_pb.ParseFromArray(v.data(), v.size())) {
                code = MetaServiceCode::PROTOBUF_PARSE_ERR;
                ss << "malformed txn running info";
                msg = ss.str();
                ss << " key=" << hex(k);
                LOG(WARNING) << ss.str();
                return;
            }

            if (running_pb.timeout_time() < check_time) {
                skip_timeout_txn_cnt++;
                break;
            }

            LOG(INFO) << "check watermark conflict range_get txn_run_key=" << hex(k)
                      << " running_pb=" << running_pb.ShortDebugString();
            std::vector<int64_t> running_table_ids(running_pb.table_ids().begin(),
                                                   running_pb.table_ids().end());
            std::sort(running_table_ids.begin(), running_table_ids.end());
            std::vector<int64_t> result(std::min(running_table_ids.size(), src_table_ids.size()));
            std::vector<int64_t>::iterator iter = std::set_intersection(
                    src_table_ids.begin(), src_table_ids.end(), running_table_ids.begin(),
                    running_table_ids.end(), result.begin());
            result.resize(iter - result.begin());
            if (result.size() > 0) {
                response->set_finished(false);
                LOG(INFO) << "skip timeout txn count: " << skip_timeout_txn_cnt
                          << " total iteration count: " << total_iteration_cnt;
                return;
            }

            if (!it->has_next()) {
                begin_running_key = k;
            }
        }
        begin_running_key.push_back('\x00'); // Update to next smallest key for iteration
    } while (it->more());
    LOG(INFO) << "skip timeout txn count: " << skip_timeout_txn_cnt
              << " total iteration count: " << total_iteration_cnt;
    response->set_finished(true);
}

/**
 * @brief 
 * 
 * @param txn_kv 
 * @param instance_id 
 * @param db_id 
 * @param label_key 
 * @return TxnErrorCode
 */
TxnErrorCode internal_clean_label(std::shared_ptr<TxnKv> txn_kv, const std::string_view instance_id,
                                  int64_t db_id, const std::string_view label_key) {
    std::string label_val;
    TxnLabelPB label_pb;

    int64_t key_size = 0;
    int64_t val_size = 0;
    std::vector<int64_t> survival_txn_ids;
    std::vector<int64_t> clean_txn_ids;

    std::unique_ptr<Transaction> txn;
    TxnErrorCode err = txn_kv->create_txn(&txn);
    if (err != TxnErrorCode::TXN_OK) {
        LOG(WARNING) << "failed to create txn. err=" << err << " db_id=" << db_id
                     << " label_key=" << hex(label_key);
        return err;
    }

    err = txn->get(label_key, &label_val);
    if (err != TxnErrorCode::TXN_OK && err != TxnErrorCode::TXN_KEY_NOT_FOUND) {
        LOG(WARNING) << "failed to txn get err=" << err << " db_id=" << db_id
                     << " label_key=" << hex(label_key);
        return err;
    }
    if (err == TxnErrorCode::TXN_KEY_NOT_FOUND) {
        LOG(INFO) << "txn get err=" << err << " db_id=" << db_id << " label_key=" << hex(label_key);
        return TxnErrorCode::TXN_OK;
    }

    if (label_val.size() <= VERSION_STAMP_LEN) {
        LOG(INFO) << "label_val.size()=" << label_val.size() << " db_id=" << db_id
                  << " label_key=" << hex(label_key);
        return TxnErrorCode::TXN_OK;
    }

    if (!label_pb.ParseFromArray(label_val.data(), label_val.size() - VERSION_STAMP_LEN)) {
        LOG(WARNING) << "failed to parse txn label"
                     << " db_id=" << db_id << " label_key=" << hex(label_key)
                     << " label_val.size()=" << label_val.size();
        return TxnErrorCode::TXN_UNIDENTIFIED_ERROR;
    }

    for (auto txn_id : label_pb.txn_ids()) {
        const std::string recycle_key = recycle_txn_key({instance_id, db_id, txn_id});
        const std::string index_key = txn_index_key({instance_id, txn_id});
        const std::string info_key = txn_info_key({instance_id, db_id, txn_id});

        std::string info_val;
        err = txn->get(info_key, &info_val);
        if (err != TxnErrorCode::TXN_OK) {
            LOG_WARNING("info_key get failed")
                    .tag("info_key", hex(info_key))
                    .tag("label_key", hex(label_key))
                    .tag("db_id", db_id)
                    .tag("txn_id", txn_id)
                    .tag("err", err);
            return err;
        }

        TxnInfoPB txn_info;
        if (!txn_info.ParseFromString(info_val)) {
            LOG_WARNING("info_val parse failed")
                    .tag("info_key", hex(info_key))
                    .tag("label_key", hex(label_key))
                    .tag("db_id", db_id)
                    .tag("txn_id", txn_id)
                    .tag("size", info_val.size());
            return TxnErrorCode::TXN_UNIDENTIFIED_ERROR;
        }

        std::string recycle_val;
        if ((txn_info.status() != TxnStatusPB::TXN_STATUS_ABORTED) &&
            (txn_info.status() != TxnStatusPB::TXN_STATUS_VISIBLE)) {
            // txn status is not final status
            LOG(INFO) << "txn not final state, label_key=" << hex(label_key)
                      << " txn_id=" << txn_id;
            survival_txn_ids.push_back(txn_id);
            DCHECK_EQ(txn->get(recycle_key, &recycle_val), TxnErrorCode::TXN_KEY_NOT_FOUND);
            continue;
        }

        DCHECK_EQ(txn->get(recycle_key, &recycle_val), TxnErrorCode::TXN_OK);
        DCHECK((txn_info.status() == TxnStatusPB::TXN_STATUS_ABORTED) ||
               (txn_info.status() == TxnStatusPB::TXN_STATUS_VISIBLE));

        txn->remove(index_key);
        key_size += index_key.size();

        txn->remove(info_key);
        key_size += info_key.size();

        txn->remove(recycle_key);
        key_size += recycle_key.size();
        clean_txn_ids.push_back(txn_id);
        LOG(INFO) << "remove index_key=" << hex(index_key) << " info_key=" << hex(info_key)
                  << " recycle_key=" << hex(recycle_key);
    }
    if (label_pb.txn_ids().size() == clean_txn_ids.size()) {
        txn->remove(label_key);
        key_size += label_key.size();
        LOG(INFO) << "remove label_key=" << hex(label_key);
    } else {
        label_pb.clear_txn_ids();
        for (auto txn_id : survival_txn_ids) {
            label_pb.add_txn_ids(txn_id);
        }
        LOG(INFO) << "rewrite label_pb=" << label_pb.ShortDebugString();
        label_val.clear();
        if (!label_pb.SerializeToString(&label_val)) {
            LOG(INFO) << "failed to serialize label_pb=" << label_pb.ShortDebugString()
                      << " label_key=" << hex(label_key);
            return TxnErrorCode::TXN_UNIDENTIFIED_ERROR;
        }
        txn->atomic_set_ver_value(label_key, label_val);
        key_size += label_key.size();
        val_size += label_val.size();
    }

    err = txn->commit();
    TEST_SYNC_POINT_CALLBACK("internal_clean_label:err", &err);
    if (err != TxnErrorCode::TXN_OK) {
        LOG(INFO) << fmt::format(
                "label_key={} key_size={} val_size={} label_pb={} clean_txn_ids={}", hex(label_key),
                key_size, val_size, label_pb.ShortDebugString(), fmt::join(clean_txn_ids, " "));
    }
    return err;
}

void MetaServiceImpl::clean_txn_label(::google::protobuf::RpcController* controller,
                                      const CleanTxnLabelRequest* request,
                                      CleanTxnLabelResponse* response,
                                      ::google::protobuf::Closure* done) {
    RPC_PREPROCESS(clean_txn_label);
    if (!request->has_db_id()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        msg = "missing db id";
        LOG(WARNING) << msg;
        return;
    }

    std::string cloud_unique_id = request->has_cloud_unique_id() ? request->cloud_unique_id() : "";
    instance_id = get_instance_id(resource_mgr_, cloud_unique_id);
    if (instance_id.empty()) {
        code = MetaServiceCode::INVALID_ARGUMENT;
        ss << "cannot find instance_id with cloud_unique_id="
           << (cloud_unique_id.empty() ? "(empty)" : cloud_unique_id);
        msg = ss.str();
        LOG(WARNING) << msg;
        return;
    }
    RPC_RATE_LIMIT(clean_txn_label)
    const int64_t db_id = request->db_id();

    // clean label only by db_id
    if (request->labels().empty()) {
        std::string begin_label_key = txn_label_key({instance_id, db_id, ""});
        const std::string end_label_key = txn_label_key({instance_id, db_id + 1, ""});

        std::unique_ptr<RangeGetIterator> it;
        bool snapshot = true;
        int limit = 1000;
        TEST_SYNC_POINT_CALLBACK("clean_txn_label:limit", &limit);
        do {
            std::unique_ptr<Transaction> txn;
            auto err = txn_kv_->create_txn(&txn);
            if (err != TxnErrorCode::TXN_OK) {
                msg = "failed to create txn";
                code = cast_as<ErrCategory::CREATE>(err);
                LOG(INFO) << msg << " err=" << err << " begin=" << hex(begin_label_key)
                          << " end=" << hex(end_label_key);
                return;
            }

            err = txn->get(begin_label_key, end_label_key, &it, snapshot, limit);
            if (err != TxnErrorCode::TXN_OK) {
                msg = "failed to txn range get";
                code = cast_as<ErrCategory::READ>(err);
                LOG(WARNING) << msg << " err=" << err << " begin=" << hex(begin_label_key)
                             << " end=" << hex(end_label_key);
                return;
            }

            if (!it->has_next()) {
                LOG(INFO) << "no keys in the range. begin=" << hex(begin_label_key)
                          << " end=" << hex(end_label_key);
                break;
            }
            while (it->has_next()) {
                auto [k, v] = it->next();
                if (!it->has_next()) {
                    begin_label_key = k;
                    LOG(INFO) << "iterator has no more kvs. key=" << hex(k);
                }
                err = internal_clean_label(txn_kv_, instance_id, db_id, k);
                if (err != TxnErrorCode::TXN_OK) {
                    code = cast_as<ErrCategory::READ>(err);
                    msg = "failed to clean txn label.";
                    LOG(WARNING) << msg << " err=" << err << " db_id=" << db_id;
                    return;
                }
            }
            begin_label_key.push_back('\x00');
        } while (it->more());
    } else {
        const std::string& label = request->labels(0);
        const std::string label_key = txn_label_key({instance_id, db_id, label});
        TxnErrorCode err = internal_clean_label(txn_kv_, instance_id, db_id, label_key);
        if (err != TxnErrorCode::TXN_OK) {
            code = cast_as<ErrCategory::READ>(err);
            msg = "failed to clean txn label.";
            LOG(WARNING) << msg << " err=" << err << " db_id=" << db_id
                         << " label_key=" << hex(label_key);
            return;
        }
    }

    code = MetaServiceCode::OK;
}

} // namespace doris::cloud
