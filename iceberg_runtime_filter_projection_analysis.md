# Iceberg Runtime Filter 投影机制分析与实现方案

## 一、参考文档的核心思想

参考文档 `/Users/xiaogangsu/code/iceberg/transform_partition_pruning_analysis.md` 描述了 Iceberg 的分区裁剪投影机制：

### 1.1 投影机制

**Inclusive 投影**：将行级谓词转换为分区级谓词，保证：**如果原始表达式匹配一行数据，那么投影后的表达式会匹配该行的分区值**。

**示例**：
- 查询条件：`ts >= '2024-01-15 10:00:00'`
- 分区：`day(ts)`
- Inclusive 投影：`day >= 2024-01-15`
- 逻辑：如果 `ts >= '2024-01-15 10:00:00'`，那么 `day(ts) >= 2024-01-15` 一定成立

### 1.2 时间 Transform 的投影规则

对于时间相关的 transform（`day`, `hour`, `month`, `year`），投影规则如下：

| 原始谓词 | Transform | Inclusive 投影 | 说明 |
|---------|-----------|---------------|------|
| `ts >= '2024-01-15 10:00:00'` | `day(ts)` | `day >= 2024-01-15` | 取日期部分 |
| `ts < '2024-01-15 10:00:00'` | `day(ts)` | `day < 2024-01-16` | 需要向上取整 |
| `ts = '2024-01-15 10:00:00'` | `day(ts)` | `day = 2024-01-15` | 精确匹配 |
| `ts IN ('2024-01-15 10:00:00', '2024-01-16 20:00:00')` | `day(ts)` | `day IN (2024-01-15, 2024-01-16)` | 集合投影 |

## 二、当前实现 vs 投影机制

### 2.1 当前实现（反向转换）

**当前方法**：将分区值转换为源列范围，然后与 runtime filter 谓词比较

**流程**：
1. 分区值：`day = "2024-01-15"`
2. 转换为源列范围：`["2024-01-15 00:00:00", "2024-01-16 00:00:00")`
3. 使用 lower bound：`"2024-01-15 00:00:00"`
4. 与 runtime filter 谓词比较：`"2024-01-15 00:00:00" >= '2024-01-15 10:00:00'` → `false`
5. 结论：不能过滤（保守策略）

**优点**：
- 实现简单，直接复用现有的 runtime filter 执行逻辑
- 不需要修改谓词表达式结构

**缺点**：
- 需要将分区值转换为源列范围（字符串操作，可能有性能开销）
- 只能使用 lower bound 进行保守判断，可能错过一些可以过滤的情况
- 对于某些谓词类型（如 `IN`），转换逻辑复杂

### 2.2 投影机制（正向投影）

**投影方法**：将 runtime filter 谓词投影到分区值上，然后直接比较分区值

**流程**：
1. Runtime filter 谓词：`ts >= '2024-01-15 10:00:00'`
2. 投影到分区值：`day >= 2024-01-15`
3. 分区值：`day = "2024-01-15"`
4. 直接比较：`"2024-01-15" >= "2024-01-15"` → `true`
5. 结论：分区可能包含匹配数据，不能过滤（保守策略）

**优点**：
- 更符合 Iceberg 的设计理念
- 不需要转换分区值，直接在分区值层面比较
- 对于某些谓词类型（如 `IN`），投影逻辑更清晰
- 可以更精确地判断是否可以过滤

**缺点**：
- 需要实现投影逻辑（将源列谓词转换为分区值谓词）
- 需要修改或扩展 runtime filter 的执行逻辑
- 对于复杂的谓词表达式，投影可能比较复杂

## 三、实现投影机制的可行性分析

### 3.1 技术可行性

**可行**，但需要以下工作：

1. **投影函数实现**：
   - 实现时间 transform 的投影逻辑（`day`, `year`, `month`, `hour`）
   - 支持常见的谓词类型：`=`, `!=`, `>`, `>=`, `<`, `<=`, `IN`, `BETWEEN`

2. **谓词表达式修改**：
   - 在 `_process_runtime_filters_partition_prune()` 中，对每个 runtime filter 谓词进行投影
   - 将投影后的谓词应用到分区值上

3. **分区值比较**：
   - 将分区值反序列化为对应的数据类型（DATE, INT 等）
   - 使用投影后的谓词进行比较

### 3.2 实现复杂度

**中等复杂度**：

- **简单场景**（`=`, `>`, `<` 等单值比较）：投影逻辑相对简单
- **复杂场景**（`IN`, `BETWEEN`, 复合谓词）：投影逻辑较复杂，需要处理边界情况

### 3.3 性能考虑

**投影机制可能更高效**：

- **减少字符串操作**：不需要将分区值转换为源列范围
- **更精确的过滤**：可以更准确地判断是否可以过滤，减少不必要的读取
- **更早的过滤**：在分区值层面就可以判断，不需要反序列化到源列类型

## 四、实现方案

### 4.1 方案 A：混合方案（推荐）

**思路**：保留当前实现作为基础，添加投影机制作为优化

**实现步骤**：

1. **添加投影函数**：
   ```cpp
   // 将源列谓词投影到分区值谓词
   Status project_predicate_to_partition(
       const VExprSPtr& source_predicate,
       const std::string& transform,
       const DataTypePtr& partition_data_type,
       VExprSPtr& projected_predicate);
   ```

2. **在 `_process_runtime_filters_partition_prune()` 中**：
   - 对于时间 transform（`day`, `year`, `month`, `hour`），尝试投影
   - 如果投影成功，使用投影后的谓词直接比较分区值
   - 如果投影失败或不支持，回退到当前实现（转换分区值到源列范围）

3. **投影实现示例**：
   ```cpp
   // 对于 `ts >= '2024-01-15 10:00:00'`，transform = "day"
   // 投影为：`day >= 2024-01-15`
   // 然后直接比较分区值 `day = "2024-01-15"` 是否满足 `day >= 2024-01-15`
   ```

### 4.2 方案 B：完全投影方案

**思路**：完全采用投影机制，移除当前的反向转换逻辑

**优点**：
- 代码更统一，逻辑更清晰
- 更符合 Iceberg 的设计理念

**缺点**：
- 需要实现完整的投影逻辑
- 改动较大，风险较高

### 4.3 方案 C：保持当前实现

**思路**：继续使用当前的反向转换方法

**优点**：
- 实现简单，风险低
- 已经可以工作

**缺点**：
- 可能错过一些优化机会
- 对于某些谓词类型，逻辑可能不够精确

## 五、推荐方案：方案 A（混合方案）

### 5.1 为什么选择混合方案

1. **渐进式改进**：保留现有实现作为回退，降低风险
2. **性能优化**：对于支持的场景，使用更高效的投影机制
3. **兼容性**：对于不支持的场景，回退到当前实现

### 5.2 实现优先级

**Phase 1**：实现简单谓词的投影（`=`, `>`, `>=`, `<`, `<=`）
- 这些是最常用的谓词类型
- 投影逻辑相对简单
- 可以带来明显的性能提升

**Phase 2**：实现复杂谓词的投影（`IN`, `BETWEEN`）
- 这些谓词类型使用频率较低
- 投影逻辑较复杂
- 可以逐步完善

**Phase 3**：优化和性能调优
- 根据实际使用情况优化投影逻辑
- 考虑缓存投影结果等优化

### 5.3 实现细节

#### 5.3.1 投影函数签名

```cpp
// 投影源列谓词到分区值谓词
// 返回值：true 表示投影成功，false 表示不支持投影（需要回退到当前实现）
bool project_source_predicate_to_partition(
    const VExprSPtr& source_predicate,
    const std::string& transform,
    const DataTypePtr& partition_data_type,
    VExprSPtr& projected_predicate);
```

#### 5.3.2 投影规则实现

**Day Transform**：
- `ts >= '2024-01-15 10:00:00'` → `day >= 2024-01-15`
- `ts < '2024-01-15 10:00:00'` → `day < 2024-01-15`
- `ts = '2024-01-15 10:00:00'` → `day = 2024-01-15`

**Year Transform**：
- `ts >= '2024-06-15 10:00:00'` → `year >= 2024`
- `ts < '2024-06-15 10:00:00'` → `year < 2024`（需要检查是否跨年）

**Month Transform**：
- `ts >= '2024-01-15 10:00:00'` → `month >= 202401`
- `ts < '2024-01-15 10:00:00'` → `month < 202401`

**Hour Transform**：
- `ts >= '2024-01-15 10:30:00'` → `hour >= 2024011510`
- `ts < '2024-01-15 10:30:00'` → `hour < 2024011510`

#### 5.3.3 在 `_process_runtime_filters_partition_prune()` 中的使用

```cpp
// 对于时间 transform，尝试投影
if (!transform.empty() && (transform == "day" || transform == "year" ||
                            transform == "month" || transform == "hour")) {
    VExprSPtr projected_predicate;
    if (project_source_predicate_to_partition(
            runtime_filter_predicate, transform, partition_data_type, 
            projected_predicate)) {
        // 使用投影后的谓词直接比较分区值
        // 将分区值反序列化为分区数据类型
        // 使用投影后的谓词进行评估
        // ...
    } else {
        // 投影失败，回退到当前实现（转换分区值到源列范围）
        // ...
    }
}
```

## 六、总结

### 6.1 可行性结论

**可以实现**，推荐使用混合方案（方案 A）：
- 保留当前实现作为回退
- 添加投影机制作为优化
- 渐进式改进，降低风险

### 6.2 预期收益

1. **性能提升**：
   - 减少字符串转换操作
   - 更精确的过滤判断
   - 更早的过滤决策

2. **代码质量**：
   - 更符合 Iceberg 的设计理念
   - 逻辑更清晰，易于维护

3. **功能完善**：
   - 支持更多谓词类型的精确过滤
   - 为未来扩展打下基础

### 6.3 下一步行动

1. **评估工作量**：实现投影机制的工作量评估
2. **设计详细方案**：设计投影函数的具体实现
3. **实现和测试**：实现 Phase 1 的功能，并进行充分测试
4. **性能对比**：对比投影机制和当前实现的性能差异

